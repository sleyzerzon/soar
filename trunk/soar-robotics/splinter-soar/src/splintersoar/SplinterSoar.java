package splintersoar;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import lcm.lcm.LCM;

import april.config.Config;
import april.config.ConfigFile;
import lcmtypes.differential_drive_command_t;

import orc.util.GamePad;

import splintersoar.laserloc.LaserLoc;
import splintersoar.orc.OrcInterface;
import splintersoar.ranger.RangerManager;
import splintersoar.soar.SoarInterface;

/**
 * @author voigtjr
 * Top-level management of the Soar/uOrc interface. Also responsible for injecting override splinter input using the game pad.
 */
public class SplinterSoar {
	SoarInterface soar;
	OrcInterface orc;
	/**
	 * Manages converting the front laser data in to a format soar can use.
	 */
	RangerManager ranger;
	/**
	 * Manages converting the localizing laser data in to coordinates.
	 */
	LaserLoc laserloc;
	/**
	 * Drive commands use the L1 network. Generated by SoarInterface and this
	 * class when override is active.
	 */
	LCM lcmL1;
	/**
	 * Used for override input.
	 */
	GamePad gamePad;

	/**
	 * The main loop that watches the game pad stops running when this is set to false.
	 */
	boolean running = true;

	private Logger logger;
	Configuration cnf;

	/**
	 * @param args Takes an optional configuration file.
	 */
	public SplinterSoar(String args[]) {

		{
			Config config = null;
			if (args.length == 1) {
				try {
					config = (new ConfigFile(args[0])).getConfig();
				} catch (IOException ex) {
					System.err.println("Couldn't open config file: " + args[0]);
					System.exit(1);
				}
			}
			cnf = new Configuration(config);
		}
		
		// create logger first
		logger = LogFactory.createSimpleLogger("SplinterSoar", cnf.loglevel);
		// warnings during configuration file load, above.
		cnf.dumpWarnings(logger);
		
		if (cnf.everythingDisabled()) {
			logger.severe("All components are disabled by configuration.");
			System.exit(1);
		}
		
		if (!cnf.llocDisabled) {
			logger.info("Starting laserloc");
			laserloc = new LaserLoc(cnf);
			// lloc thread should not keep the process alive
			laserloc.setDaemon(true);
			laserloc.start();
		}
		
		if (!cnf.orcDisabled) {
			logger.info("Starting orc interface");
			orc = new OrcInterface(cnf);
		}
		
		if (!cnf.rangerDisabled) {
			logger.info("Starting ranger manager");
			ranger = new RangerManager(cnf);
		}
		
		if (!cnf.soarDisabled) {
			logger.info("Starting Soar interface");
			soar = new SoarInterface(ranger, cnf);
		}

		if (!cnf.gamepadDisabled && (!cnf.orcDisabled || !cnf.soarDisabled)) {
			try {
				logger.info(String.format("Using %s for %s provider URL.", LCMInfo.L1_NETWORK, LCMInfo.DRIVE_COMMANDS_CHANNEL));
				lcmL1 = new LCM(LCMInfo.L1_NETWORK);

			} catch (IOException e) {
				logger.severe("Error creating lcmL1.");
				e.printStackTrace();
				System.exit(1);
			}
			logger.info("Creating game pad for override");
			gamePad = new GamePad();
		}
		
		Runtime.getRuntime().addShutdownHook(new ShutdownHook());

		logger.info("Ready");
		while (running) {
			try {
				if (!cnf.gamepadDisabled) {
					updateOverride();
					updateStartStop();
				} else {
					synchronized(this) {
						// block as long as possible
						this.wait();
					}
				}
			} catch (InterruptedException ignored) {
			}
		}
	}

	/**
	 * True when override mode is enabled.
	 */
	boolean overrideEnabled = false;
	/**
	 * The current state of the button, used to "latch" changing modes.
	 */
	boolean overrideButton = false;
	/**
	 * The current command from override, cached because it needs to be transmitted often.
	 */
	differential_drive_command_t overrideCommand = new differential_drive_command_t();
	/**
	 * Static configuration, tank mode means that two joysticks are used,
	 * one for each wheel. Non-tank mode is one joystick where up down is 
	 * forward/backward and left/right rotate. Both have ups and downs.
	 */
	boolean tankMode = false;

	private void updateOverride() {
		boolean currentOverrideButton = gamePad.getButton(0);
		// change on trailing edge
		if (overrideButton && !currentOverrideButton) {
			overrideEnabled = !overrideEnabled;
			if (soar != null) {
				// tell soar so that it stops posting drive commands
				soar.setOverride(overrideEnabled);
			}

			if (overrideEnabled) {
				// assemble command, set throttles to zero
				overrideCommand.left_enabled = true;
				overrideCommand.right_enabled = true;
				overrideCommand.left = 0;
				overrideCommand.right = 0;
				overrideCommand.utime = System.nanoTime() / 1000;
				if (logger.isLoggable(Level.FINEST))
					logger.finest(String.format("Sending override %f %f", overrideCommand.left, overrideCommand.right));
				lcmL1.publish(LCMInfo.DRIVE_COMMANDS_CHANNEL, overrideCommand);
			}

			logger.info("Override " + (overrideEnabled ? "enabled" : "disabled"));
		}
		overrideButton = currentOverrideButton;

		if (overrideEnabled) {
			differential_drive_command_t newCommand = new differential_drive_command_t();
			newCommand.left_enabled = true;
			newCommand.right_enabled = true;

			if (tankMode) {
				newCommand.left = gamePad.getAxis(1) * -1;
				newCommand.right = gamePad.getAxis(3) * -1;
			} else {
				// this should not be linear, it is difficult to precicely control
				double fwd = -1 * gamePad.getAxis(3); // +1 = forward, -1 = back
				double lr = -1 * gamePad.getAxis(2); // +1 = left, -1 = right

				newCommand.left = fwd - lr;
				newCommand.right = fwd + lr;

				double max = Math.max(Math.abs(newCommand.left), Math.abs(newCommand.right));
				if (max > 1) {
					newCommand.left /= max;
					newCommand.right /= max;
				}
			}
			if (shouldTransmitDrive() || (newCommand.left != overrideCommand.left) || (newCommand.right != overrideCommand.right)) {
				overrideCommand = newCommand;
				overrideCommand.utime = System.nanoTime() / 1000;
				if (logger.isLoggable(Level.FINEST))
					logger.finest(String.format("Sending override %f %f", overrideCommand.left, overrideCommand.right));
				lcmL1.publish(LCMInfo.DRIVE_COMMANDS_CHANNEL, overrideCommand);
			}
		}
	}

	long lastDriveTransmission = 0;
	/**
	 * @return Returns true if the drive command should be transmitted, even if it didn't change.
	 * 
	 * This is necessary because drive commands could be lost
	 * due to the nature of lcm/udp
	 */
	private boolean shouldTransmitDrive() {
		long current = System.nanoTime();
		if ((current - lastDriveTransmission) > cnf.orc.updateHz) {
			lastDriveTransmission = current;
			if (logger.isLoggable(Level.FINEST))
				logger.finest(String.format("Should transmit returning true."));
			return true;
		}
		if (logger.isLoggable(Level.FINEST))
			logger.finest(String.format("Should transmit returning false."));
		return false;
	}

	/**
	 * Soar control button state
	 */
	boolean startStopButton = false;
	/**
	 * Soar control state
	 */
	boolean startStop = false;

	/**
	 * Used to control soar from the game pad
	 */
	private void updateStartStop() {
		if (soar == null)
			return;

		boolean currentStartStopButton = gamePad.getButton(1);
		// change on trailing edge
		if (startStopButton && !currentStartStopButton) {
			startStop = !startStop;

			if (startStop) {
				logger.info("Starting Soar");
				soar.start();
			} else {
				logger.info("Stop Soar requested");
				soar.stop();
			}
		}
		startStopButton = currentStartStopButton;
	}

	/**
	 * @author voigtjr
	 *
	 * Captures control-c and attempts a clean shutdown.
	 */
	public class ShutdownHook extends Thread {
		@Override
		public void run() {
			running = false;

			if (soar != null)
				soar.shutdown();

			if (orc != null)
				orc.shutdown();

			System.out.flush();
			System.err.println("Terminated");
			System.err.flush();
		}
	}

	/**
	 * @param args Configuration file.
	 * 
	 * Entry point for most splinter soar applications, takes a configuration file.
	 */
	public static void main(String args[]) {
		new SplinterSoar(args);
	}
}

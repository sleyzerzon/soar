##########################################################
# Top-level mode switch
# mixed-mode is sim except real hardware listens to commands and laser data is a min merge
mixed-mode = false;

##########################################################
# lcm-spy, set enabled true to enable
lcm-spy {
	enabled = false;
	
	# args = { yada, yada };
}

##########################################################
command {
	productions = "../../book-robot/clean-house-new.soar";
	spawnDebugger = false;

	# limitLinVelMax
	# limitLinVelMin
	# limitAngVelMax
	# limitAngVelMin
	# geomLength
	# geomWidth
	# geomHeight
	# geomWheelbase
	# lengthUnits
	# speedUnits
	# angleUnits
	# angleResolution
	# poseTranslation
	# headingGains
	# angularGains
	# linearGains
	# rangeCount
	# fieldOfView
	# visibleSeconds
	# manipulationDistance
	# gamepadZeroThreshold
	# lidarCacheTimeSeconds
}

##########################################################
# mixed-mode only
splinter {
	# tickMeters
	# baselineMeters
	# maxThrottleAccelleration
	# updateHz
	orcHostname = 192.168.237.7;
	# ports
	# invert
	# captureOdometry
}

##########################################################
# This is all generated from the image file.
metadata {
	# image file newlab.png
	# 165 inches (4.191 meters) by 256 inches (6.5024 meters)
	# rounded to 4.2 meters (42 pixels) by 6.5 meters (65 pixels)

	units = pixels;

	# Areas, rectangles with optional door tag
	areas = [ one, one-two-w, one-two-e, two, two-three, two-four, two-five, three, four, five ];

	one {
		pos = [ 43, 55 ]; size = [ 42, 20 ];
	}
	one-two-w {
		pos = [ 43, 75 ]; size = [ 11, 1 ];
		door = true;
	}
	one-two-e {
		pos = [ 76, 75 ]; size = [ 9, 1 ];
		door = true;
	}
	two {
		pos = [ 43, 76 ]; size = [ 42, 23 ];
	}
	two-three {
		pos = [ 43, 99 ]; size = [ 11, 1 ];
		door = true;
	}
	two-four {
		pos = [ 68, 99 ]; size = [ 9, 1 ];
		door = true;
	}
	two-five {
		pos = [ 78, 99 ]; size = [ 7, 1 ];
		door = true;
	}
	three {
		pos = [ 43, 100 ]; size = [ 11, 20 ];
	}
	four {
		pos = [ 55, 100 ]; size = [ 22, 20 ];
	}
	five {
		pos = [ 78, 100 ]; size = [ 7, 20 ];
	}
	
	# Gateways, points connecting two areas. 
	#	to: the connected areas
	#	dir: what wall the gateway is on in the corresponding area in "to"
	gateways = [ one-sw, one-se, two-nw, two-ne, two-three, two-four, two-five, three, four, five ];

	one-sw {
		to = [ one, one-two-w ];
		dir = [ south, north ];
		pos = [ 48, 74 ];
	}
	one-se {
		to = [ one, one-two-e ];
		dir = [ south, north ];
		pos = [ 80, 74 ];
	}
	two-nw {
		to = [ one-two-w, two ];
		dir = [ south, north ];
		pos = [ 48, 76 ];
	}
	two-ne {
		to = [ one-two-e, two ];
		dir = [ south, north ];
		pos = [ 80, 76 ];
	}
	two-three {
		to = [ two, two-three ];
		dir = [ south, north ];
		pos = [ 48, 99 ];
	}
	two-four {
		to = [ two, two-four ];
		dir = [ south, north ];
		pos = [ 65, 99 ];
	}
	two-five {
		to = [ two, two-five ];
		dir = [ south, north ];
		pos = [ 82, 99 ];
	}
	three {
		to = [ two-three, three ];
		dir = [ south, north ];
		pos = [ 48, 101 ];
	}
	four {
		to = [ two-four, four ];
		dir = [ south, north ];
		pos = [ 65, 101 ];
	}
	five {
		to = [ two-five, five ];
		dir = [ south, north ];
		pos = [ 82, 101 ];
	}
	
	# Movable objects
}

##########################################################
viewer {
	viewobjects = [ lidars, robot, remotelog, mapimage, waypoints, areas, obstacles ];

	robot {
		class = "april.viewer.ViewRobot";

		avatar {
			path = "config/meshmodels/cy.rwx";
			scale = 7;

			position = [ 0, 0, 0 ];
			rollpitchyaw_degrees = [ 90, 0, 90 ];
		}
	}

	remotelog {
		class = "april.viewer.RemoteLogEventHandler";
	}

	lidars {
		class = "april.viewer.ViewLaser";
	}

	lcmgl {
		class = "april.viewer.ViewLCMGL";
	}

	mapimage {
		class = "april.viewer.ViewMapImage";
		obstacles {
			image_path = "five-rooms.png";
			image_origin = [ 11,51 ];
			meters_per_pixel = 0.15;
		}
	}

	waypoints {
		class = "april.viewer.ViewWaypoints";
	}

	areas {
		class = "april.viewer.ViewAreaDescriptions";
	}

	obstacles {
		class = "april.viewer.ViewObstaclesReadOnly";
	}    
}

##########################################################
# Simulator has two required sections: obstacles and simobjects. All
# other parameters are "discovered" through the simobjects reflection
# mechanism.
simulator {
	obstacles {
		image_path = "five-rooms.png";
		image_origin = [ 11,51 ];
		meters_per_pixel = 0.15;
	}

	# Generic simulation instantiation: add a configuration block to
	# the list of "sims", then define the parameters in the
	# corresponding block. The block must have an entry named "class",
	# which specifies the java class that will be created and passed
	# the remainder of the arguments.
	simobjects = [ simsplinter, SIM_LIDAR_FRONT ];

	simsplinter {
		class = "april.sim.SimSplinter";
	}

	# Use an anonymous enclosure so we can inherit laser properties
	# amongst all lidars.  Individual lidars should be named according
	# to the LCM channel they publish on, and so that the extrinsics
	# can be found in the global scope.
	{
		class = "april.sim.SimLaser";

		degree0 = -90;
		degree_step = 1;
		nranges = 180;
		range_noise_m = 0.01;
		theta_noise_degrees = 0.25;
		max_range_m = 30;
		hz = 7;

		SIM_LIDAR_FRONT {
		    # no additional parameters to specify!
		}
	}
}

##########################################################
# the robot's coordinate frame has the vehicle at the origin, looking
# down the X axis, with +Y = left and +Z = up.
SIM_LIDAR_FRONT {
	position = [ 0, 0, 0.5 ];
	rollpitchyaw_degrees = [ 0, 0, 0 ];
	color = [1, 0, 0];
}

SICK_LIDAR_FRONT {
	position = [ 0, 0, 0.5 ];
	rollpitchyaw_degrees = [ 0, 0, 0 ];
	color = [0, 1, 0];
}

# This must be here for the viewer
LIDAR_LOWRES {
	position = [ 0, 0, 0.5 ];
	rollpitchyaw_degrees = [ 0, 0, 0 ];
	color = [0, 0, 1];
}


##########################################################
controller
{
	productions = "agents/jon-agent.soar";
}

##########################################################
metadata 
{
	areas = [ a1, a2, a3 ];
	a1 
	{
		pos = [ -5.09, 4.46 ];
		size = [ 5.88, 4.64 ];
	}
	a2 
	{
		door = true;
		pos = [ -0.78, 3.95 ];
		size = [ 1.57, 0.51 ];
	}
	a3 
	{
		pos = [ -0.78, -1.02 ];
		size = [ 1.57, 4.97 ];
	}
	
	gateways = [ g1, g2 ];
	g1 
	{
		to = [ a1, a2 ];
		pos = [ 0, 4.46 ];
	}
	g2 
	{
		to = [ a2, a3 ];
		pos = [ 0, 3.95 ];
	}
}

##########################################################
viewer
{
    viewobjects = [ lidars, robot, remotelog, mapimage, waypoints, areas ];

    robot {
        class = "april.viewer.ViewRobot";

        avatar {
            path = "config/meshmodels/cy.rwx";
            scale = 7;

            position = [ 0, 0, 0 ];
            rollpitchyaw_degrees = [ 90, 0, 90 ];
        }
    }

    remotelog {
        class = "april.viewer.RemoteLogEventHandler";
    }

    lidars {
        class = "april.viewer.ViewLaser";
    }

    lcmgl {
        class = "april.viewer.ViewLCMGL";
    }
    
    mapimage {
    	class = "april.viewer.ViewMapImage";
    	obstacles
	    {
    	    image_path = "lab.png";
        	image_origin = [ 555,916 ];
	        meters_per_pixel = 0.01;
    	}
	}

    waypoints {
        class = "april.viewer.ViewWaypoints";
    }
    
    areas {
        class = "april.viewer.ViewAreaDescriptions";
    }
    
}

##########################################################
# Simulator has two required sections: obstacles and simobjects. All
# other parameters are "discovered" through the simobjects reflection
# mechanism.
simulator
{
    obstacles
    {
        image_path = "lab.png";
        image_origin = [ 555,916 ];
        meters_per_pixel = 0.01;

        #geometry_path = "simple_indoor.obst";
    }

    # Generic simulation instantiation: add a configuration block to
    # the list of "sims", then define the parameters in the
    # corresponding block. The block must have an entry named "class",
    # which specifies the java class that will be created and passed
    # the remainder of the arguments.
    simobjects = [ simsplinter, LIDAR_FRONT ];

    simsplinter
    {
        class = "april.sim.SimSplinter";
    }

    # Use an anonymous enclosure so we can inherit laser properties
    # amongst all lidars.  Individual lidars should be named according
    # to the LCM channel they publish on, and so that the extrinsics
    # can be found in the global scope.
    {
        class = "april.sim.SimLaser";

        degree0 = -90;
        degree_step = 1;
        nranges = 180;
        range_noise_m = 0.01;
        theta_noise_degrees = 0.25;
        max_range_m = 30;
        hz = 7;

        LIDAR_FRONT
        {
            # no additional parameters to specify!
        }
    }
}

##########################################################

# the robot's coordinate frame has the vehicle at the origin, looking
# down the X axis, with +Y = left and +Z = up.
LIDAR_FRONT {
    position = [ 0, 0, 0.5 ];
    rollpitchyaw_degrees = [ 0, 0, 0 ];
    color = [1, 0, 0];
}

# the robot's coordinate frame has the vehicle at the origin, looking
# down the X axis, with +Y = left and +Z = up.
LIDAR_LOWRES {
    position = [ 0, 0, 0.5 ];
    rollpitchyaw_degrees = [ 0, 0, 0 ];
    color = [0, 1, 0];
}

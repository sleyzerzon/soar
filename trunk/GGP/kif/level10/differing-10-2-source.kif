;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; micro-Rogue (mRogue) GDL Rule Set
;;; Example: TL Level 10, Scenario 2, Source Task 
; This scenario adds a fireball scroll to the normal mRogue concepts.
; The fireball scroll allows the hero to destroy enemies that are one 
; square in any direction, making it similar to an area-of-effect weapon,
; such as the grenade from Wargame.
; 
; Also, auto-healing is turned off.
;
; 8/13: Initial Release
; 8/14: Turned off auto-healing; made scenario simpler
; 9/14: MCM: Updated to revised core rules for differing scenarios
; 9/21: MCM: Goals containing wrong role corrected.
; 9/24: SW: fixed multiple monster problems
; 
; Verified Solution, length 14: NNEEES<read scroll1>ESWSSSE
; mRogue was developed by Tom Hinrichs, Sam Wintermute, & David Aha
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file: Map (and Legend)
;               + = Corner
;    012345     - = Horizontal wall
;   +------+    | = Vertical wall
;  0|...s..|    . = A room location
;  1|......|    # = A corridor location
;  2|H@w.B.|    @ = hero
;  3+----#-+    a = armor, p = potion, s = scroll,
;  4|......|    w = weapon, ! = amulet, * = gold
;  5|.....>|    > = exit
;   +------+    K = kestral
;               H = hobgoblin
;               B = bat
;               S = snake
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Debugger: "http://games.stanford.edu:5999/director/debugrawgame?"
;
; Hero commands/actions:
; - Move(dir): N, E, S, W (All can cause attacks on an adjacent monster)
; - Drop(item): Drop item from sack (only if full and floor is clear)
; - Read(scroll): Read scroll currently in the sack
; - Quaff(potion): Quaff potion currently in the sack
; - Throw(arrow,dir): Throws arrow in quiver from sack (direction dir)
;
; Properties of objects:
; - All objects (armor, amulet, potions, scrolls, weapons)
;   - Are picked up automatically when moved on, if room in sack
;   - burden=1 (except gold)
;   - Can be dropped (if sack is full)
; - Sack
;   - Has a max capacity (maxBurden)
;   - Items wielded or worn continue to count towards carrying burden
; - Armor: Defense values in [1,3]
;   - None: 1         ; No defense against monsterattacks
;   - Ring mail: 2    ; First monster attack does not decrease health
;   - Banded mail: 3  ; First 2 monster attacks do not decrease health
; - Potions (deleted after use)
;   - Speed (Doubles speed for 5 turns)
;   - Strength (Increases attack value by 1 for 5 turns)
;   - Invisibility (note: cannot implement blindness)
; - Scrolls (deleted after use)
;   - Restore health (to maximum value)
;   - Armor enhance (Increases armor strength by 1, to max 3)
;   - Sleep (forces sleeping for 2 turns)
; - Weapon: Offensive value in [1,3]
;   - None: 1 (melee only)
;   - Mace: 2 (melee only)
;   - Sword: 3 (melee only)
;   - Bow: 1 (when throwing arrow) (bow+quiver has burden of 1)
;     - Can only throw an arrow when wielding a bow
;       - Decrements number of arrows in a quiver
;       - Assume arrow always hit a target if it is thrown towards target
;       - Assume arrow has unlimited range, and disappears after thrown 
; - Monsters: Name (Character) [Initial health, Damage when attacking, Base speed]
;   - Bat (B) [3, 2, 1]: Asleep unless/until attacked
;   - Hobgoblin (H) [5, 3, 1]: Toughest monster in domain
;   - Kestral (K) [2, 2, 2]: Moves at twice speed unless hitting
;   - Snake (S) [4, 2, 0.5]: Moves at half speed
;
; Notes:
;   0. Turn-taking: The hero and the monsters rotate turns
;   1. The hero cannot share a location with a monster.
;   2. When in the same room or corridor as a monster that is not asleep,
;      the monster will advance towards the hero.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; GDL State Machine Model Components:
;   1. Role: Players of the game
;   2. Init: Facts true in the initial state (initial state of fluents)
;   3. Transitions: Rules for determining what is/will be true in the world
;   4. Legal: Legal moves for a <player,state> pair
;   5. Goal: Value of a (final) state for a player
;   6. Terminal: Terminal state
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1. Role
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Meaning: This is a one-player game
(role hero)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2. Init
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;---------------------------------------------------------------------------
; 2.1 Things that differ among tasks
;---------------------------------------------------------------------------
; >>>>>
; Monsters and their types
(monster hobgoblin1 hobgoblin)
(monster bat1 bat)

; Initial health of monsters (hero's health is defined in 2.3)
(init (health hobgoblin1 5)) 
(init (health bat1 3))

; Bat is asleep
(init (asleep bat1 1)) 

; Items (that can be picked up by Hero) (amulet & gold are defined in 2.3)
(item scroll1)
(item weapon1)

; Item typings (note: a bow includes a quiver and a set of arrows)
(scroll scroll1 fireball)
(weapon weapon1 sword)

; Locations of character and items (North Room)
(init (location bat1 4 2))         ; Monster
(init (location hobgoblin1 0 2))         ; Monster
(init (location hero 1 2))           ; our Hero
(init (location scroll1 3 0))
(init (location weapon1 2 2))

; Locations of character and items (South Room)
(init (location exit 5 5))           ; exit
; <<<<<

;---------------------------------------------------------------------------
; 2.2 Rooms and corridor
; - Same representation of walls as Wargame and Escape
;---------------------------------------------------------------------------
; Room: <topLeft_x topLeft_y bottomRight_x bottomRight_y>
(room 0 0 5 2)    ; North room
(room 0 4 5 5)    ; South room

; Corridor location: <x y>
(corridor 4 3) ; Corridor/doorway between north and south rooms
(init (blocked west 4 3))
(init (blocked east 4 3))

; North room
(init (blocked west 0 0))
(init (blocked west 0 1))
(init (blocked west 0 2))
(init (blocked north 0 0))
(init (blocked north 1 0))
(init (blocked north 2 0))
(init (blocked north 3 0))
(init (blocked north 4 0))
(init (blocked north 5 0))
(init (blocked east 5 0))
(init (blocked east 5 1))
(init (blocked east 5 2))
(init (blocked south 0 2))
(init (blocked south 1 2))
(init (blocked south 2 2))
(init (blocked south 3 2))
(init (blocked south 5 2))

; South room
(init (blocked west 0 4))
(init (blocked west 0 5))
(init (blocked north 0 4))
(init (blocked north 1 4))
(init (blocked north 2 4))
(init (blocked north 3 4))
(init (blocked north 5 4))
(init (blocked east 5 4))
(init (blocked east 5 5))
(init (blocked south 0 5))
(init (blocked south 1 5))
(init (blocked south 2 5))
(init (blocked south 3 5))
(init (blocked south 4 5))
(init (blocked south 5 5))

;---------------------------------------------------------------------------
; 2.3 Things we don't typically change from one task to another
;---------------------------------------------------------------------------
; Player starts at step/state 1. Game has finite length.
(init (step 1))

; Hero's initial health
(init (health hero 4))

; Burden/1: <burdenamount>
; Meaning: Initially the sack is empty.
(init (burden 0))

; Quiversize/2: <size>
(init (quiverSize 5))

; Parity counters for half & quarter speed movement
(init odd)
(init (slomo-time 1))

; The exit location
(exitType exit)

;----------------------------------------------------------------------
; 2.4 Constants
;----------------------------------------------------------------------

; Meaning: Sack can contain at most this number of items
(maxBurden 5)

; Meaning: Maximum health a hero can ever attain
(maxHealth hero 4)

; Meaning: The maximum defined time-step (t = 30)
(maxTime 30)

;----------------------------------------------------------------------
; 2.5 Scenario-specific rules
;----------------------------------------------------------------------

; Hero recovers no hit points (HP) iff not attacked/etc.
; MCM (9/4): Rewrite to healthIncrease.
(<= (healthIncrease hero 0)
    (totalMonsterDamage 0)
    (not (healthRestoredByScroll))
    (true (health hero ?hp))
    (maxHealth hero ?maxHealth)
    (> ?maxHealth ?hp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 3. Goal: Value of a (final) state for a player
; MCM: Moved goal up to facilitate separation of core and scenario-specific
;      rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Pts Alive Exit Amulet Gold KilledMonster Weapon Armor 
;  0    0    *    *      *     *            *      *
;  50   1    NOT_ALL_THESE_OTHERS
; 100   1    1    1      1     1            1      1

; If he makes it to the exit, he wins.
(<= (goal hero 100)
   (not (dead hero))    ; Endgame
   atexit)

; Give him half credit for being alive
(<= (goal hero 50)
   (not (dead hero))    ; Endgame
   (not atexit))

; Dead
(<= (goal hero 0)
   (dead hero))         ; Endgame


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 4. Transitions: Rules used to reason about states
;    - Specifies the dynamics of fluents
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;----------------------------------------------------------------------
; 4.1 Location updates
;----------------------------------------------------------------------

; Meaning: Blocked locations are persistent
(<= (next (blocked ?dir ?x ?y))
    (true (blocked ?dir ?x ?y)))

; Meaning: Updates hero location
(<= (next (location hero ?x ?y))
    (nextHeroLocation ?x ?y))                 ; Action

; Meaning: Updates monster location
(<= (next (location ?monster ?x ?y))
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (health ?monster ?health))
   (> ?health 0)                             ; built-in
   (nextMonsterLocation ?monster ?x ?y))     ; Action

; Meaning: The exit does not move
(<= (next (location ?exit ?x ?y))
    (exitType ?exit)
    (true (location ?exit ?x ?y)))

; Meaning: Items remain on the ground until they are picked up
(<= (next (location ?item ?x ?y))
   (item ?item)
   (true (location ?item ?x ?y))
   (not (pickedUp ?item)))        ; Object-interaction

; Meaning: Dropped objects are placed at the hero's current location
(<= (next (location ?item ?x ?y))
   (does hero (drop ?item))
   (true (location hero ?x ?y)))

; DA (7/13): Must also drop a weapon if picking up another
(<= (next (location ?oldWeapon ?x ?y))
   (changeWeapon ?oldWeapon)            ; DA: We pickedUp another!
   (true (location hero ?x ?y)))

;----------------------------------------------------------------------
; 4.2 Health updates for hero
;     - If the hero is attacked, his health is decreased by difference
;       of 1 + (monster's attack value - hero defense value)
;     - Health goes to max if hero reads restoreHealth scroll
;; MCM: Rewriting for a health increase/decrease system.
;; MCM: There can't actually be an increase and a decrease 
;; simultaneously; this is only done to make it look more like Wargame.
;----------------------------------------------------------------------

; Meaning: Hero incurs damage
; Note: totalMonsterDamage maxes out at hero's current health, so
; we shouldn't need to check for negative health here.
; DA: If the restore health scroll is simultaneously read, and
; monster damage is nonzero, then the scroll has no effect!
;(<= (next (health hero ?hpNew))
;   (totalMonsterDamage ?hitPointsLost)
;   (> ?hitPointsLost 0)
;   (true (health hero ?hpOld))
;   (- ?hpOld ?hitPointsLost ?hpNew))

; Note: totalMonsterDamage maxes out at hero's current health, so
; we shouldn't need to check for negative health here.
; DA: If the restore health scroll is simultaneously read, and
; monster damage is nonzero, then the scroll has no effect!
; MCM: Rewrite to healthDecrease.
(<= (healthDecrease hero ?dec)
	(totalMonsterDamage ?dec)) 

; Hero recovers a hit point (HP) iff not attacked/etc.
;(<= (next (health hero ?hpNew))
;    (totalMonsterDamage 0)
;    (not (healthRestoredByScroll))
;    (true (health hero ?hpOld))
;    (maxHealth hero ?maxHealth)
;    (> ?maxHealth ?hpOld)
;    (+ ?hpOld 1 ?hpNew))

; Hero recovers no hit points while at maxhealth.
; MCM: Rewrite to healthIncrease.
(<= (healthIncrease hero 0)
    (totalMonsterDamage 0)
    (not (healthRestoredByScroll))
    (true (health hero ?hp))
    (maxHealth hero ?maxHealth)
    (>= ?hp ?maxHealth))

; Hero recovers no hit points when attacked.
; MCM: Rewrite to healthIncrease.
(<= (healthIncrease hero 0)
    (totalMonsterDamage ?x)
    (distinct ?x 0))

; Meaning: Hero already at maxHealth and not attacked
;(<= (next (health hero ?maxHealth))
;   (totalMonsterDamage 0)
;   (maxHealth hero ?maxHealth)
;   (true (health hero ?maxHealth)))

; Meaning: Hero read a restoreHealth scroll to regain maximum health
;(<= (next (health hero ?maxHealth))
;   (totalMonsterDamage 0)
;   (healthRestoredByScroll)
;   (maxHealth hero ?maxHealth))

; Meaning: Hero read a restoreHealth scroll to regain maximum health
; MCM: Rewrite to healthIncrease.
(<= (healthIncrease hero ?increase)
   (totalMonsterDamage 0)
   (healthRestoredByScroll)
   (true (health hero ?health))
   (maxHealth hero ?maxHealth)
   (- ?maxHealth ?health ?increase))

;----------------------------------------------------------------------
; 4.3 Health updates for monsters
;     - If attacked by hero, health decreases by attack value of hero's
;       wielded weapon!
;     - Simplification: Only arrows can be thrown, and only when hero
;       wields a bow
;; MCM: Rewriting for a health increase/decrease system.
;----------------------------------------------------------------------

; Meaning: Hero kills the monster (melee)
;(<= (next (health ?monster 0))
;   (monster ?monster ?monster-type)
;   (monsterAttacked ?monster)
;   (true (health ?monster ?hpOld))
;   (heroOffense ?wDamage)
;   (>= ?wDamage ?hpOld))

; Meaning: Hero hurts the monster (melee)
;(<= (next (health ?monster ?hpNew))
;   (monster ?monster ?monster-type)
;   (monsterAttacked ?monster)
;   (true (health ?monster ?hpOld))
;   (heroOffense ?wDamage)
;   (> ?hpOld ?wDamage)
;   (- ?hpOld ?wDamage ?hpNew))

; Meaning: Hero hurts the monster (melee)
(<= (healthDecrease ?monster ?dec)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (monsterAttacked ?monster)
   (heroOffense ?dec))

; Meaning: Hero kills the monster (by throwing an arrow)
; Hardcoding the damage value of arrows: 2
;(<= (next (health ?monster 0))
;   (monster ?monster ?monster-type)
;   (hitByArrow ?monster)
;   (true (health ?monster ?hpOld))
;   (>= 2 ?hpOld))

; Meaning: Hero hurts the monster (by throwing an arrow)
; Hardcoding the damage value of arrows: 2
;(<= (next (health ?monster ?hpNew))
;   (monster ?monster ?monster-type)
;   (true (health ?monster ?hpOld))
;   (> ?hpOld 2)
;   (hitByArrow ?monster)
;   (- ?hpOld 2 ?hpNew))

; Meaning: Hero hurts the monster (by shooting)
; Hardcoding the damage value of arrows: 2
; MCM: Rewrite to healthDecrease
(<= (healthDecrease ?monster 2)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (hitByArrow ?monster))

; Meaning: Unattacked monster's health is unchanged
;(<= (next (health ?monster ?hp))
;   (monster ?monster ?monster-type)
;   (not (monsterAttacked ?monster))
;   (not (hitByArrow ?monster))
;   (true (health ?monster ?hp)))

; Meaning: Hero kills the monster by casting a fireball
(<= (healthDecrease ?monster ?hp)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (hitByFireball ?monster)
   (true (health ?monster ?hp)))

; Meaning: Unattacked monster's health is not decreased
(<= (healthDecrease ?monster 0)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (not (monsterAttacked ?monster))
   (not (hitByArrow ?monster))
   (not (hitByFireball ?monster)))
   
; Meaning: Monster's health is never increased
; MCM: Added for health inc/dec
(<= (healthIncrease ?monster 0)
   (type ?monster monster-type)) ; MCM (9/14): Updated to type
   
; Meaning: General health arithmetic
; MCM: Added for health inc/dec
(<= (next (health ?anyone ?newHealth))
	(true (health ?anyone ?oldHealth))
	(healthIncrease ?anyone ?increase)
	(healthDecrease ?anyone ?decrease)
	(- ?increase ?decrease ?totalChange)
	(+ ?oldHealth ?totalChange ?unboundedHealth)
	(max ?unboundedHealth 0 ?newHealth))

;----------------------------------------------------------------------
; 4.4 Burden-related updates
;     - Sack, armor, and weaponry
;----------------------------------------------------------------------

;--------------------------------------------------
; 4.4.1: Burden maintenance relations
;--------------------------------------------------

; Meaning: Items remain in hero's sack when picked up
(<= (next (carrying ?item))
   (item ?item)
   (pickedUp ?item))                  ; Object-interaction

; Meaning: Items in sack stay in sack unless dropped
(<= (next (carrying ?item))
   (true (carrying ?item))
   (not (changeWeapon ?item))         ; It's not a weapon we're auto-dropping
   (not (use ?item)))  ;; MCM (9/6): Changed from decrementBurden to use to 
                       ;;            align structure with other domains

; Meaning: Maintain size of burden if it's not changed
(<= (next (burden ?burden))
   (not burdenChanged)
   (true (burden ?burden)))

; Meaning: Increment burden by picking up an item
; Note: we don't have to check maxBurden here, because it's checked in pickedUp.
(<= (next (burden ?newBurden))
   (pickedUp ?item)                   ; Object-interaction
   (distinct ?item gold)
   (not (weaponChange ?item))         ; DA (7/13): burden doesn't change when changing weapons
   (true (burden ?oldBurden))
   (succ ?oldBurden ?newBurden))      ; Arithmetic

; Meaning: Decrement burden by dropping an item or using a scroll or potion
(<= (next (burden ?newBurden))
   (decrementsBurden ?item)
   (true (burden ?oldBurden))
   (succ ?newBurden ?oldBurden))      ; Arithmetic

;--------------------------------------------------
; 4.4.2 Quiver size (i.e., # arrows in it)
;--------------------------------------------------

; Meaning: Quiver size doesn't change when no arrows are thrown.
; Note: we don't have to check here for wielding the bow or
; carrying it.  If that's not true, then hero can't legally
; throw an arrow.
; Also: don't reify the quiver apart from the bow.  It's a
; package, like a clip of ammo in a gun.
(<= (next (quiverSize ?oldSize))
   (not arrowThrown)
   (true (quiverSize ?oldSize)))

; Meaning: Quiver size decreases when throwing arrow w/ a bow
; - Ensures quiver contains at least one arrow
;(<= (next (quiverSize ?newSize))
;   (does hero (throw arrow ?dir))
;   (true (quiverSize ?oldSize))
;   (- ?oldSize 1 ?newSize))           ; Arithmetic

; Meaning: Quiver size decreases when throwing arrow w/ a bow
; - Ensures quiver contains at least one arrow
(<= (next (quiverSize ?newSize))
   (does hero (shoot-monster ?monster))
   (true (quiverSize ?oldSize))
   (- ?oldSize 1 ?newSize))           ; Arithmetic

;--------------------------------------------------
; 4.4.3: Armor-wearing relations
; -- DA (7/13): Only 1 armor max in game!!!
;--------------------------------------------------

; Meaning: Hero continues wearing armor until it is dropped
(<= (next (wearing ?item))
   (true (wearing ?item))
   (not (does hero (drop ?item))))  ; note: drops can occur only if sack is full

; Meaning: Hero is wearing armor that is newly picked up
(<= (next (wearing ?armor))
   (armor ?armor ?armor-type)
   (pickedUp ?armor))

;--------------------------------------------------
; 4.4.4: Weapon-wielding relations
;--------------------------------------------------

; Meaning: Continue wielding a weapon wielded unless exchanging or dropping
(<= (next (wielding ?weapon))
   (true (wielding ?weapon))
   (not (changeWeapon ?weapon))      
   (not (does hero (drop ?weapon)))) ; note: drops can occur only if sack is full

; Meaning: Wield a weapon automatically if it is picked up
; Note: Any currently-wielded weapon would be dropped (elsewhere)
(<= (next (wielding ?weapon))
   (type ?weapon weapon-type)
   (pickedUp ?weapon))

;--------------------------------------------------
; 4.4.5: Sleep relations
;--------------------------------------------------

; Meaning: Reading the sleep scroll induces 2 turns of sleep
(<= (next (asleep hero 2))
   (does hero (read ?scroll))
   (scroll ?scroll sleepInduce))

; Meaning: Sleep decrement
(<= (next (asleep hero ?n))
   (true (asleep hero ?old-n))
   (distinct ?old-n 1)
   (- ?old-n 1 ?n))

; Meaning: Let sleeping monsters sleep
(<= (next (asleep ?monster ?n))
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (asleep ?monster ?n))
   (true (health ?monster ?hp))
   (distinct ?hp 0)
   (not (provoked ?monster))) ; in this case, attacked or hit with an arrow

;--------------------------------------------------
; 4.4.6: Visibility
;--------------------------------------------------

;;; Meaning: hero is invisible to monsters for the next 5 turns
(<= (next (invisible hero 5))
   (does hero (quaff ?potion))
   (potion ?potion invisibility))

(<= (next (invisible hero ?n))
   (true (invisible hero ?old-n))
   (distinct ?old-n 1)
   (- ?old-n 1 ?n))

;--------------------------------------------------
; 4.4.7: Enhanced Speed, Strength, Armor
;--------------------------------------------------

; Meaning: Hero's speed is enhanced by 1 for 5 turns
(<= (next (enhancedSpeed hero 5))
   (does hero (quaff ?potion))
   (potion ?potion speed))

(<= (next (enhancedSpeed hero ?n))
   (true (enhancedSpeed hero ?old-n))
   (distinct ?old-n 1)
   (- ?old-n 1 ?n))

; Meaning: Hero's attack strength is enhanced by 1 for 5 turns
(<= (next (enhancedStrength hero 5))
   (does hero (quaff ?potion))
   (potion ?potion strength))

(<= (next (enhancedStrength hero ?n))
   (true (enhancedStrength hero ?old-n))
   (distinct ?old-n 1)
   (- ?old-n 1 ?n))

(<= (next (enhancedArmor hero 5))
   (does hero (read ?scroll))
   (scroll ?scroll armorEnhance)
   (true (wearing ?armor))  ; You have to be wearing armor first
   (armor ?armor ?armor-type)
   (armorstrength ?armor-type ?amt)
   (>= 3 ?amt))

(<= (next (enhancedArmor hero ?n))
    (true (enhancedArmor hero ?old-n))
    (distinct ?old-n 1)
    (- ?old-n 1 ?n))

;---------------------------------------------------------------------------
;;; 4.5 Standard GDL support rule
;---------------------------------------------------------------------------

; Meaning: Time advances in one step increments
; MCM: Revised to use real arithmetic, like Wargame
(<= (next (step ?next))
    (true (step ?current))
    (+ ?current 1 ?next))          ; Arithmetic
;;;    (succ ?current ?next))          ; Arithmetic

;---------------------------------------------------------------------------
;;; 4.6 Movement speed rules
; SW: Changed to only update the parity counters when they are being used.
; This isn't a useless groundings problem, but it actually breaks our
; spatial assumptions, since if we see a game state change, the agent
; can use no knowledge about what directions are redundant to move
; in. So we need to minimize useless game state changes.
;---------------------------------------------------------------------------
(<= (monsterIsMoving)
   (provoked ?monster))

(<= (noMonsterMoving)
  (not (monsterIsMoving)))

(<= (slomoMonsterMoving ?monster)
   (currentlyEnhancedSpeed hero)
   (provoked ?monster)
   (monster ?monster ?monster-type)
   (monsterSpeed ?monster-type .5))

; Parity counter for 1/2 speed movement
(<= (next odd)
   (not (noMonsterMoving))
   (true even))
(<= (next even)
   (not (noMonsterMoving))
   (true odd))
(<= (next even)
   (not (monsterIsMoving))
   (true even))
(<= (next odd)
   (not (monsterIsMoving))
   (true odd))

; Meaning: slow-motion or "matrix" time counter for sluggish snakes
(<= (next (slomo-time 1))
   (slomoMonsterMoving ?monster)
   (true (slomo-time 4)))
(<= (next (slomo-time 2))
   (slomoMonsterMoving ?monster)
   (true (slomo-time 1)))
(<= (next (slomo-time 3))
   (slomoMonsterMoving ?monster)
   (true (slomo-time 2)))
(<= (next (slomo-time 4))
   (slomoMonsterMoving ?monster)
   (true (slomo-time 3)))

(<= (next (slomo-time ?t))
   (true (slomo-time ?t))
   (not (currentlyEnhancedSpeed hero)))

; Meaning: An arrow can hit a monster (unlimited range)
; SW: changed to two rules, for x==x and y==y, so we don't need arbitrary nCells (very expensive for us)
(<= (canShootAt ?monster)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (location hero ?x ?y1))
   (true (location ?monster ?x ?y2))
   (not (y-blocked ?x ?y1 ?y2)))

(<= (canShootAt ?monster)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (location hero ?x1 ?y))
   (true (location ?monster ?x2 ?y))
   (not (x-blocked ?x1 ?x2 ?y)))
   
(<= (x-blocked ?x1 ?x2 ?y)
	(int ?y)
  (>= ?y 0) ; SW 9/24 added to minimize groundings
	(between ?x1 ?x3 ?x2)
	(not (traversible ?x3 ?y)))
	
(<= (y-blocked ?x ?y1 ?y2)
	(int ?x)
  (>= ?x 0) ; SW 9/24 added
	(between ?y1 ?y3 ?y2)
	(not (traversible ?x ?y3)))
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 5. Legal: Specifies legal moves for players
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Meaning: The hero can rest (and do nothing) at any time
; (legal hero (rest))

; Meaning: The hero may move anywhere within rooms and corridors
; - BUT: Moving to a monster's location is an attack, not a move!
; MCM (8/31): Introduced stepBlocked, removed traversible
(<= (legal hero (move ?dir))
   (not (currentlyAsleep hero))
   (true (location hero ?xOld ?yOld))
   (direction ?dir)                         ; Generic spatial
   (not (stepBlocked ?dir ?xOld ?yOld))     ; Generic spatial
   (nextCell ?dir ?xOld ?yOld ?xNew ?yNew)) ; Movement

;(<= (legal hero (move ?dir))
;   (not (currentlyAsleep hero))
;   (true (location hero ?xOld ?yOld))
;   (direction ?dir)                        ; Generic spatial
;   (nextCell ?dir ?xOld ?yOld ?xNew ?yNew) ; Movement
;   (traversible ?xNew ?yNew))              ; Generic spatial

; Meaning: Hero can drop an item (being carried) if sack is full
(<= (legal hero (drop ?item))
   (true (burden ?max-burden))             ; New constraint (7/13)
   (maxBurden ?max-burden)                 ; New constraint (7/13)
   (not (currentlyAsleep hero))
   (true (carrying ?item)))

; Meaning: Hero can read a scroll (being carried)
(<= (legal hero (read ?scroll))
   (not (currentlyAsleep hero))
   (true (carrying ?scroll))
   (type ?scroll scroll-type))            ; Init

; Meaning: Hero can quaff a potion (being carried)
(<= (legal hero (quaff ?potion))
   (not (currentlyAsleep hero))
   (true (carrying ?potion))
   (type ?potion potion-type))            ; Init

; Meaning: Hero can throw an arrow (if carrying a non-empty quiver)
;(<= (legal hero (throw arrow ?dir))
;   (not (currentlyAsleep hero))
;   (true (wielding ?weapon))
;   (weapon ?weapon bow)                    ; Init
;   (true (quiverSize ?numarrows))
;   (> ?numarrows 0)
;   (direction ?dir))                       ; Generic spatial

; Meaning: Hero can shoot a monster (if has quiver, bow, monster in range)
(<= (legal hero (shoot-monster ?monster))
   (not (currentlyAsleep hero))
   (true (wielding ?weapon))
   (weapon ?weapon bow)                    ; Init
   (true (quiverSize ?numarrows))
   (> ?numarrows 0)
   (canShootAt ?monster))                       ; Generic spatial

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 6. Terminal: Terminal state
;    - specifies the conditions under which the game has ended
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Meaning: The game is over if time runs out
(<= terminal
    timeOut)

; Meaning: The game is over if the hero is killed
;MCM: changed "(true (health hero 0))" to "(dead hero)"
(<= terminal
    (dead hero))         ; Endgame

; Meaning: The game is over if the hero has escaped with the amulet
(<= terminal
    atExit)              ; Endgame

;=============================================================================
; Supporting (Low-Level) Relations
;=============================================================================

;----------------------------------------------------------------------
; Type relations
;----------------------------------------------------------------------

(<= (type ?monster monster-type)
    (monster ?monster ?monster-type))
    
(<= (type ?weapon weapon-type)
    (weapon ?weapon ?weapon-type))
    
(<= (type ?scroll scroll-type)
    (scroll ?scroll ?scroll-type))
    
(<= (type ?potion potion-type)
    (potion ?potion ?potion-type))

;----------------------------------------------------------------------
; Battle relations
;----------------------------------------------------------------------

; Meaning: The amount of damage incurred by monster attacks (on possibly
; two fronts).  This should return 0 if hero is not attacked and should
; max out at hero's current health.
(<= (totalMonsterDamage 0)
   (nextHeroLocation ?x ?y)
   (not (attackedBySomeMonster ?x ?y)))

; Meaning: First monster damage
(<= (totalMonsterDamage ?damage)
   (nextHeroLocation ?x ?y)
   (monster ?monster ?monster-type)
   (attackedByMonster ?monster ?x ?y)
   (monsterStrength ?monster-type ?strength)
   (totalMonsterDamage1 ?monster ?strength ?x ?y ?damage))

; Meaning: No second monster attack
(<= (totalMonsterDamage1 ?monster ?strength ?x ?y ?damage)
   (nextHeroLocation ?x ?y) ; SW added
   (type ?monster monster-type) ; SW added ; MCM (9/14): Updated to type
   (attackedByMonster ?monster ?x ?y) ; SW added   ****
   (not (attackedBy2ndMonster ?monster ?x ?y))
   (amountOfMonsterDamage ?strength ?d1)
   (true (health hero ?hp))
   (min ?d1 ?hp ?damage))

; Meaning: Check second monster damage
(<= (totalMonsterDamage1 ?monster1 ?strength ?x ?y ?damage)
   (totalMonsterDamage2 ?monster1 ?strength ?x ?y ?damage))

; Meaning: combined damage from two monsters
(<= (totalMonsterDamage2 ?monster1 ?strength1 ?x ?y ?damage)
   (nextHeroLocation ?x ?y) ; SW added
   (monster ?monster2 ?monster-type)
   (monster ?monster1 ?monster-type2) ; SW added   ****
   (distinct ?monster2 ?monster1)
   (attackedByMonster ?monster1 ?x ?y) ; SW added   ****
   (attackedByMonster ?monster2 ?x ?y)
   (monsterStrength ?monster-type ?strength1) ; SW added  ****
   (monsterStrength ?monster-type2 ?strength2)
   (+ ?strength1 ?strength2 ?strength)
   (amountOfMonsterDamage ?strength ?combined-damage)
   (true (health hero ?hp))
   (min ?combined-damage ?hp ?damage))

; Meaning: There exists some monster that attacks hero at ?x ?y
(<= (attackedBySomeMonster ?x ?y)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (attackedByMonster ?monster ?x ?y))

; Meaning: Monster attacks hero when provoked and within one spot of
; hero's next location
(<= (attackedByMonster ?monster ?x2 ?y2)
   (provoked ?monster)                            ; Generic monster
   (nextHeroLocation ?x2 ?y2) ; SW added  ****
   (true (location ?monster ?x1 ?y1))
   (adjacent ?x1 ?y1 ?x2 ?y2))                    ; Generic spatial

; Meaning: Monster1 and monster2 both attack simultaneously.
(<= (attackedBy2ndMonster ?monster1 ?x ?y)
   (type ?monster2 monster-type) ; MCM (9/14): Updated to type
   (type ?monster1 monster-type) ; SW **** ; MCM (9/14): Updated to type
   (distinct ?monster2 ?monster1)
   (attackedByMonster ?monster2 ?x ?y)
   (attackedByMonster ?monster1 ?x ?y))

; Meaning: No damage if monster's attack is less than defense
; Offensive-strength is the combined strength of attacking monsters.
; - Open to debate
(<= (amountOfMonsterDamage ?offensive-strength 0)
   (attackedByMonster ?monster ?x ?y)                  ; SW   ****
   (monster ?monster ?monster-type)                    ; SW   ****
   (monsterStrength ?monster-type ?offensive-strength) ; SW   ****
   (heroDefense ?defense)                          ; Battle
   (> ?defense ?offensive-strength)) ; SW ****: changed from >=, bug? Would imply that no damage occurs if offense == defense..

; Meaning: Attacks whose value is equal to or greater than armor value
; - Open to debate (i.e., Attack value is 1 + (offense - defense))
(<= (amountOfMonsterDamage ?offensive-strength ?hitPointsLost)
   (attackedByMonster ?monster ?x ?y)                  ; SW   ****
   (monster ?monster ?monster-type)                    ; SW   ****
   (monsterStrength ?monster-type ?offensive-strength) ; SW   ****
   (heroDefense ?defense)                          ; Battle
   (>= ?offensive-strength ?defense) ; SW: this seems necessary
   (-  ?offensive-strength ?defense ?diff)         ; Arithmetic
   (+ ?diff 1 ?hitPointsLost))                     ; Arithmetic

; Meaning: The current defensive strength of armor worn (if any)
(<= (heroDefense 1)
   (not (armored hero)))

(<= (heroDefense ?defense)
   (not (currentlyEnhancedArmor hero))
   (true (wearing ?item))
   (armor ?item ?armor-type)
   (armorstrength ?armor-type ?defense))

(<= (heroDefense ?defense)
   (int ?n)         ; ?n is how many turns it will remain in effect (0 - 5)
   (true (enhancedArmor hero ?n))
   (true (wearing ?item))
   (armor ?item ?armor-type)
   (armorstrength ?armor-type ?base-defense)
   (+ ?base-defense 1 ?defense))

; Meaning: The current offense strength of weapons wielded (if any)
(<= (heroOffense 1)
   (not (armed hero)))

(<= (heroOffense ?offense)
   (not (currentlyEnhancedStrength hero))
   (true (wielding ?weapon))
   (weapon ?weapon ?weapon-type)                  ; Init
   (weaponStrength ?weapon-type ?offense))        ; Generic weapon

(<= (heroOffense ?offense)
   (currentlyEnhancedStrength hero)
   (true (wielding ?weapon))
   (weapon ?weapon ?weapon-type)                  ; Init
   (weaponStrength ?weapon-type ?offense))        ; Generic weapon SW: fixed variable name

; Meaning: Hero attacks the monster
(<= (monsterAttacked ?monster)
   (true (location hero ?x1 ?y1))
   (true (location ?monster ?x2 ?y2))
   (type ?monster monster-type) ; SW added ; MCM (9/14): Updated to type
   (adjacent ?x1 ?y1 ?x2 ?y2)
   (does hero (move ?dir))
   (nextCell ?dir ?x1 ?y1 ?x2 ?y2))

;----------------------------------------------------------------------
; Movement relations (non-recursive)
;----------------------------------------------------------------------

; Meaning: Exhausted our travel distance
(<= (nStepsTowardsHero ?monster 0 ?startx ?starty ?startx ?starty)
   (cellNearMonster ?monster ?startx ?starty)) ; SW

(<= (nStepsTowardsHero ?monster 1 ?startx ?starty ?finalx ?finaly)
   (cellNearMonster ?monster ?startx ?starty) ; SW
   (cellNearMonster ?monster ?finalx ?finaly) ; SW
   (singleStepTowardsHero ?monster ?startx ?starty ?finalx ?finaly))

(<= (nStepsTowardsHero ?monster 2 ?startx ?starty ?finalx ?finaly)
 (cellNearMonster ?monster ?startx ?starty)
 (cellNearMonster ?monster ?finalx ?finaly)
 (singleStepTowardsHero ?monster ?startx ?starty ?x2 ?y2)
 (cellNearMonster ?monster ?x2 ?y2)
 (singleStepTowardsHero ?monster ?x2 ?y2 ?finalx ?finaly))

; Meaning: Take one step toward destination only if you won't run into hero.
(<= (singleStepTowardsHero ?monster ?startx ?starty ?nextx ?nexty)
   (oneStepTowardsHero ?monster ?startx ?starty ?nextx ?nexty)
    (traversible ?nextx ?nexty)
    (nextHeroLocation ?herox ?heroy)
    (not (sameLocation ?nextx ?nexty ?herox ?heroy)))

; Meaning: Stay put and attack the hero.
(<= (singleStepTowardsHero ?monster ?startx ?starty ?startx ?starty)
    (nextHeroLocation ?herox ?heroy)
   (oneStepTowardsHero ?monster ?startx ?starty ?herox ?heroy))

;;; Rather than having horizontal or vertical movement preferences
;;; as in Wargame, in mRogue we alternate each turn.

; Meaning: Move one step (horizontally or vertically) towards destination
(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x3 ?y1)  ; go west
   (nextHeroLocation ?x2 ?y1)
  (cellNearMonster ?monster ?x1 ?y1)
   (> ?x1 ?x2)
   (- ?x1 1 ?x3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x3 ?y1)  ; go east
   (nextHeroLocation ?x2 ?y1)
  (cellNearMonster ?monster ?x1 ?y1)
   (> ?x2 ?x1)
   (+ ?x1 1 ?x3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x1 ?y3)  ; go north
   (nextHeroLocation ?x1 ?y2)
  (cellNearMonster ?monster ?x1 ?y1)
   (> ?y1 ?y2)
   (- ?y1 1 ?y3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x1 ?y3)  ; go south
   (nextHeroLocation ?x1 ?y2)
  (cellNearMonster ?monster ?x1 ?y1)
   (> ?y2 ?y1)
   (+ ?y1 1 ?y3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x3 ?y1)    ; go west
   (nextHeroLocation ?x2 ?y2)
  (cellNearMonster ?monster ?x1 ?y1)
   (> ?x1 ?x2)
   (distinct ?y1 ?y2)
   (true odd)
   (- ?x1 1 ?x3))

(<= (otherStepTowardsHero ?monster ?x1 ?y1 ?x3 ?y1)    ; go west
   (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
 (> ?x1 ?x2)
 (distinct ?y1 ?y2)
 (true even)
 (- ?x1 1 ?x3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x3 ?y1)    ; go east
 (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
   (> ?x2 ?x1)
   (distinct ?y1 ?y2)
   (true odd)
   (+ ?x1 1 ?x3))

(<= (otherStepTowardsHero ?monster ?x1 ?y1 ?x3 ?y1)    ; go east
   (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
 (> ?x2 ?x1)
 (distinct ?y1 ?y2)
 (true even)
 (+ ?x1 1 ?x3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x1 ?y3)  ; go north
 (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
   (> ?y1 ?y2)
   (distinct ?x1 ?x2)
   (true even)
   (- ?y1 1 ?y3))

(<= (otherStepTowardsHero ?monster ?x1 ?y1 ?x1 ?y3)  ; go north
   (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
 (> ?y1 ?y2)
 (distinct ?x1 ?x2)
 (true odd)
 (- ?y1 1 ?y3))

(<= (oneStepTowardsHero ?monster ?x1 ?y1 ?x1 ?y3)  ; go south
 (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
   (> ?y2 ?y1)
   (distinct ?x1 ?x2)
   (true even)
 (+ ?y1 1 ?y3))

(<= (otherStepTowardsHero ?monster ?x1 ?y1 ?x1 ?y3)  ; go south
 (nextHeroLocation ?x2 ?y2)
 (cellNearMonster ?monster ?x1 ?y1)
 (> ?y2 ?y1)
 (distinct ?x1 ?x2)
 (true odd)
   (+ ?y1 1 ?y3))

; Meaning: Direction-based relationships between coordinates
; - Read: one cell in ?direction of ?x1 ?y1 is ?x2 ?y2
; I had hoped to get rid of this, but it's used in determining
; legal moves.
(<= (nextCell north ?x ?y1 ?x ?y2)
   (int ?x)
   (int ?y1) ; SW- new groundings
   (- ?y1 1 ?y2))
(<= (nextCell south ?x ?y1 ?x ?y2)
   (int ?x)
   (int ?y1) ; SW- new groundings
   (+ ?y1 1 ?y2))
(<= (nextCell east ?x1 ?y ?x2 ?y)
   (int ?y)
   (int ?x1) ; SW- new groundings
   (+ ?x1 1 ?x2))
(<= (nextCell west ?x1 ?y ?x2 ?y)
   (int ?y)
   (int ?x1) ; SW- new groundings
   (- ?x1 1 ?x2))

;----------------------------------------------------------------------
; Generic spatial relations
;----------------------------------------------------------------------

; Roomlocation: <x y>  (derived from "room")
(<= (roomlocation ?x ?y)
   (room ?tlx ?tly ?brx ?bry)
   (between ?tlx ?x ?brx)        ; Generic spatial
   (between ?tly ?y ?bry))       ; Generic spatial

; Meaning: ?a <= ?b <= ?c (note: permits them all to be equal)
(<= (between ?a ?b ?c)
   (int ?a) ; SW- must ground these
   (int ?b)
   (int ?c)
   (>= ?a 0) ; SW 9/24 added to minimize groundings
   (>= ?b 0)
   (>= ?c 0)
   (>= ?b ?a)                    ; Arithmetic
   (>= ?c ?b))                   ; Arithmetic

; Meaning: <x,y> can be traversed by a character (or hold an item)
; We actually don't need this for monster movement because so long
; as they only pursue hero within a room, they'll never try to
; go through walls or cut corners.  If we change monster behavior
; or have non-rectangular rooms, then oneStepTowards will have to
; check.
(<= (traversible ?x ?y)
    (roomlocation ?x ?y))   ; Generic spatial
(<= (traversible ?x ?y)
    (corridor ?x ?y))     ; Generic spatial

; Meaning: Four possible directions of movement
(direction north)
(direction south)
(direction east)
(direction west)

(verticalDir north)
(verticalDir south)
(horizontalDir east)
(horizontalDir west)

; Meaning: Same location
(<= (sameLocation ?x ?y ?x ?y) ; SW -- must be ints
    (int ?x)
    (int ?y))

; Meaning: Adjacent locations (diagonal is not adjacent)
(<= (adjacent ?x ?y1 ?x ?y2)
    (int ?x)      ; SW
    (diff ?y1 ?y2 1))
(<= (adjacent ?x1 ?y ?x2 ?y)
    (int ?y)      ; SW
    (diff ?x1 ?x2 1))

;MCM: Added stepBlocked from wargame to make spatial logic more similar.
;	  Traversible (based on room definition) no longer relevant.
(<= (stepBlocked ?dir ?x ?y)
    (true (blocked ?dir ?x ?y)))

;----------------------------------------------------------------------
; Generic monster relations
;----------------------------------------------------------------------
(initialHealth   bat 3)
(monsterStrength bat 2)
(monsterSpeed    bat 1)

(initialHealth hobgoblin 5)
(monsterStrength hobgoblin 3)
(monsterSpeed hobgoblin 1)

(initialHealth kestral 2)
(monsterStrength kestral 2)
(monsterSpeed kestral 2)

(initialHealth snake 4)
(monsterStrength snake 2)
(monsterSpeed snake 0.5)

(speedNumber 0.5) ; SW: need these so we can ground potential speeds.
(speedNumber 1)
(speedNumber 2)

; Meaning: Monsters attack when in the same room as the hero.
; If they're asleep, they wake up when hero attacks them or
; throws an arrow at them.
(<= (provoked ?monster)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (not (currentlyAsleep ?monster))
   (true (location ?monster ?x ?y))
   (room ?lx ?ty ?rx ?by)
   (between ?lx  ?x ?rx)
   (between ?ty ?y ?by)
   (nextHeroLocation ?hx ?hy)
   (between ?lx  ?hx ?rx)
   (between ?ty ?hy ?by))

(<= (provoked ?monster)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (asleep ?monster ?n))
   (monsterAttacked ?monster))

(<= (provoked ?monster)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (asleep ?monster ?n))
   (hitByArrow ?monster))

;----------------------------------------------------------------------
; Generic item relations
;----------------------------------------------------------------------

; Armor strength (defense)
(armorstrength ringmail 2)
(armorstrength bandedmail 3)

; Weapon strength (offense)
(weaponStrength mace 2)
(weaponStrength sword 3)
(weaponStrength bow 1)


;----------------------------------------------------------------------
; Endgame relations
;----------------------------------------------------------------------

; Mearning: True if the hero is at the same location as the exit
(<= atExit
   (true (location hero ?x ?y))
   (true (location exit ?x ?y)))

; Meaning: Time's run out for our hero!
(<= timeOut
   (true (step ?t))
   (maxTime ?t))

; MCM: Adding "dead" to increase mappings between wargame and rogue.
(<= (dead ?anyone)
    (true (health ?anyone 0)))

; killing a monster is a victory condition
;MCM: changed "(true (health ?monster 0))" to "(dead ?anymonster)"
(<= killedMonster
   (type ?anymonster monster-type) ; MCM (9/14): Updated to type
   (dead ?anymonster))

;----------------------------------------------------------------------
; Arithmetic relations
;----------------------------------------------------------------------

; Meaning: Absolute value of difference
(<= (diff ?n1 ?n2 ?diff)
   (int ?n1) ; SW- new groundings
   (int ?n2) ; SW- new groundings
   (> ?n1 ?n2)
   (- ?n1 ?n2 ?diff))

(<= (diff ?n1 ?n2 ?diff)
   (int ?n1) ; SW- new groundings
   (int ?n2) ; SW- new groundings
   (>= ?n2 ?n1)
   (- ?n2 ?n1 ?diff))


; Meaning: Minimum
(<= (min ?n1 ?n2 ?n2)
   (int ?n1) ; SW: must ground these
   (int ?n2)
   (> ?n1 ?n2))
(<= (min ?n1 ?n2 ?n1)
   (int ?n1) ; SW: must ground these
   (int ?n2)
   (>= ?n2 ?n1))

; Meaning: Maximum
(<= (max ?x ?y ?x)
	(int ?x)
	(int ?y)
	(> ?x ?y))

(<= (max ?x ?y ?y)
	(int ?x)
	(int ?y)
	(> ?y ?x))

(<= (max ?x ?x ?x)
	(int ?x))

; Meaning: Defines a (finite) succesor relation
(succ 0 1)
(succ 1 2)
(succ 2 3)
(succ 3 4)
(succ 4 5)
(succ 5 6)
(succ 6 7)
(succ 7 8)
(succ 8 9)
(succ 9 10)
(succ 10 11)
(succ 11 12)
(succ 12 13)
(succ 13 14)
(succ 14 15)
(succ 15 16)
(succ 16 17)
(succ 17 18)
(succ 18 19)
(succ 19 20)
(succ 20 21)
(succ 21 22)
(succ 22 23)
(succ 23 24)
(succ 24 25)
(succ 25 26)
(succ 26 27)
(succ 27 28)
(succ 28 29)
(succ 29 30)
(succ 30 31)
(succ 31 32)
(succ 32 33)
(succ 33 34)
(succ 34 35)
(succ 35 36)
(succ 36 37)
(succ 37 38)
(succ 38 39)
(succ 39 40)
(succ 40 41)
(succ 41 42)
(succ 42 43)
(succ 43 44)
(succ 44 45)
(succ 45 46)
(succ 46 47)
(succ 47 48)
(succ 48 49)
(succ 49 50)
(succ 50 51)

; Meaning: The integers in [-5,7]
; SW -- these are used in lots of other places now
; MCM (9/4): Added some negative integers to handle negative 
; unbounded health values
(int -5)
(int -4)
(int -3)
(int -2)
(int -1)
(int 0)
(int 1)
(int 2)
(int 3)
(int 4)
(int 5)
(int 6)
(int 7)

;---------------------------------------------------------------------------
; Action relations
;---------------------------------------------------------------------------

; Meaning: Hero moves one cell in direction ?dir from ?x1 ?y1
; - If <x1,y1> is not currently occupied by a monster.
(<= (nextHeroLocation ?x2 ?y2)
   (true (location hero ?x1 ?y1))
   (does hero (move ?dir))
   (nextCell ?dir ?x1 ?y1 ?x2 ?y2)
   (not (monsterAt ?x2 ?y2)))

; Meaning: Hero's location is unchanged if attacking a monster
(<= (nextHeroLocation ?x1 ?y1)
   (true (location hero ?x1 ?y1))
   (does hero (move ?dir))
   (nextCell ?dir ?x1 ?y1 ?x2 ?y2)
   (monsterAt ?x2 ?y2))

; Meaning: Non-moving hero actions
(<= (nextHeroLocation ?x ?y)
   (true (location hero ?x ?y))
   (not (heroMoves)))

; Meaning: Hero moved in some direction
(<= (heroMoves)
   (does hero (move ?dir)))

; Meaning: There's a monster currently at ?x ?y
(<= (monsterAt ?x ?y)
   (true (location ?monster ?x ?y))
 (type ?monster monster-type))

; Meaning: If another monster is stationed where you are
(<= (nextMonsterLocation ?monster ?x2 ?y2)
      (type ?monster monster-type)
      (monsterAlternateLocation ?monster ?x2 ?y2)
      (not (otherMonsterAlternateLocation ?monster ?x2 ?y2)))

; Meaning: Backup plan if original planned location unavailable.
(<= (monsterAlternateLocation ?monster ?x2 ?y2)
 (true (location ?monster ?x1 ?y1))
 (type ?monster monster-type)
 (not (monsterGetsALocation ?monster))
 (otherStepTowardsHero ?monster ?x1 ?y1 ?x2 ?y2))

(<= (monsterGetsALocation ?monster)
       (int ?x)
       (int ?y)
       (monsterGetsLocation ?monster ?x ?y))

(<= (otherMonsterAlternateLocation ?monster ?x ?y)
      (type ?monster monster-type)
      (type ?monster2 monster-type)
      (distinct ?monster ?monster2)
      (monsterAlternateLocation ?monster2 ?x ?y))

(<= (nextMonsterLocation ?monster ?x ?y)
      (monsterGetsLocation ?monster ?x ?y))

; MCM: Note: This logic may need to change for >2 monsters.
; Meaning: If no other monster wants to be there, you get your spot.
(<= (monsterGetsLocation ?monster ?x ?y)
      (type ?monster monster-type)
      (monsterPlannedLocation ?monster ?x ?y)
      (not (otherMonsterPlannedLocation ?monster ?x ?y))
      (type ?monster2 monster-type)
      (distinct ?monster ?monster2) ; SW 8/29
      (not (true (location ?monster ?x ?y))) ; SW 8/29- the other rule for monsterGetsLocation handles this case
      (not (monsterStationedLocation ?monster2 ?x ?y)))

; Meaning: Move provoked monsters towards hero according to ?speed
; - BUT: Cannot stop on same location as hero's location
;   We'll make nStepsTowardsHero stop when the next location will be
;   occupied by the hero.
(<= (monsterPlannedLocation ?monster ?x2 ?y2)
   (not (currentlyInvisible hero))
   (provoked ?monster)
   (true (location ?monster ?x1 ?y1))
   (monster ?monster ?monster-type)
   (monsterSpeed ?monster-type ?base-speed)
   (relativeSpeed ?base-speed ?speed)
      (nStepsTowardsHero ?monster ?speed ?x1 ?y1 ?x2 ?y2))

; Meaning: A different monster has reserved this spot for its next location.
(<= (otherMonsterPlannedLocation ?monster ?x ?y)
      (type ?monster monster-type)
      (type ?monster2 monster-type)
      (monsterPlannedLocation ?monster2 ?x ?y)
      (distinct ?monster ?monster2))

; Meaning: Monsters who stay where they are get first priority.
(<= (monsterGetsLocation ?monster ?x ?y)
      (type ?monster monster-type)
      (monsterPlannedLocation ?monster ?x ?y)
      (true (location ?monster ?x ?y)))

; Meaning: Unprovoked monsters don't move
(<= (monsterPlannedLocation ?monster ?x ?y)
 (type ?monster monster-type)
   (not (provoked ?monster))
   (true (location ?monster ?x ?y)))

(<= (monsterPlannedLocation ?monster ?x ?y)
 (type ?monster monster-type)
   (provoked ?monster)                             ; Added 8/2/07 thanks to SW
   (true (invisible hero ?n))                      ; invisible for n more turns
   (true (location ?monster ?x ?y)))


; Meaning: How many steps can monster take this turn?
; We slow all monsters down when hero has enhancedSpeed
(<= (relativeSpeed 0.5 ?speed)
   (not (currentlyEnhancedSpeed hero))
   (halfSpeed ?speed))
(<= (relativeSpeed 0.5 ?speed)
   (true (enhancedSpeed hero ?n))
   (quarterSpeed ?speed))
(<= (relativeSpeed ?base-speed ?base-speed)
   (speedNumber ?base-speed)                        ; SW ****
   (distinct ?base-speed 0.5)
   (not (currentlyEnhancedSpeed hero)))
(<= (relativeSpeed 1 ?speed)
   (true (enhancedSpeed hero ?n))
   (halfSpeed ?speed))
(<= (relativeSpeed 2 1)
   (true (enhancedSpeed hero ?n)))

; Anything that moves slower than Hero is handled by
; flipping speed from 1 to 0 every other turn
; (or every fourth turn for 1/4 speed monsters)
(<= (halfSpeed 1)
   (true odd))
(<= (halfSpeed 0)
   (true even))
(<= (quarterSpeed 1)
   (true (slomo-time 4)))
(<= (quarterSpeed 0)
   (true (slomo-time ?n))
   (distinct ?n 4))

; Meaning: Conditions when health is restored via restoreHealth scroll
(<= (healthRestoredByScroll)
   (does hero (read ?scroll))
   (scroll ?scroll restoreHealth)
   (true (health hero ?health))
   (maxHealth hero ?maxHealth)
   (distinct ?health ?maxHealth))

;----------------------------------------------------------------------
; Object-interaction relations
;----------------------------------------------------------------------

; Meaning: The monster is hit by an arrow (unlimited range)
; SW: changed to two rules, for x==x and y==y, so we don't need arbitrary nCells (very expensive for us)
;(<= (hitByArrow ?monster)
;   (monster ?monster ?monster-type)               ; Generic monster
;   (does hero (throw arrow ?dir))
;   (true (location hero ?x ?y1))
;   (true (location ?monster ?x ?y2)))             ; Action

;(<= (hitByArrow ?monster)
;   (monster ?monster ?monster-type)               ; Generic monster
;   (does hero (throw arrow ?dir))
;   (true (location hero ?x1 ?y))
;   (true (location ?monster ?x2 ?y)))             ; Action

; If it's legal, it must succeed, now.
(<= (hitByArrow ?monster)
	(does hero (shoot-monster ?monster)))

;; Meaning: The fireball hits monsters next to the hero.
(<= (hitByFireball ?monster)
   (does hero (read ?scroll))
   (scroll ?scroll fireball)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (location ?monster ?x1 ?y1))
   (true (location hero ?x2 ?y2))
   (adjacent ?x1 ?y1 ?x2 ?y2))

; Meaning: Hero adds item to sack if on it at end of time step
; - And it wasn't dropped in this time step
(<= (pickedUp ?item)
   (item ?item)                         ; Generic item
   (distinct ?item gold)
   (true (burden ?burden))
   (maxBurden ?max-burden)              ; Generic sack
   (> ?max-burden ?burden)              ; Arithmetic
   (true (location hero ?x1 ?y1))
   (nextHeroLocation ?x2 ?y2)           ; Action
   (not (sameLocation ?x1 ?y1 ?x2 ?y2)) ; Don't re-pick up an item after dropping it
   (true (location ?item ?x2 ?y2)))

; Handle gold specially since it is not limited by maxBurden
(<= (pickedUp gold)
   (nextHeroLocation ?x ?y)
   (true (location gold ?x ?y)))

; Meaning: Read scrolls and quaffed potions are eliminated from burden
(<= (decrementsBurden ?item)
    (use ?item))

; Meaning: Dropped items are elminated from burden
(<= (decrementsBurden ?item)
   (does hero (drop ?item)))

; Meaning: Picking up a non-gold item changes the burden
(<= burdenChanged
   (pickedUp ?item)            ; acquired new item
   (not (weaponChange ?item))  ; DA: No change if changing a weapon
   (distinct ?item gold))      ; No change if it's gold

; Meaning: Any decrement to the burden changes the burden
(<= burdenChanged
   (decrementsBurden ?item)            ; successful drop or use
   (distinct ?item gold))

; Meaning: This can happen when we pickup a new weapon
(<= (changeWeapon ?currentWeapon)
   (true (wielding ?currentWeapon))       ; SW: need to ground ?weapon
   (type ?newWeapon weapon-type)    ; DA: Sam - is this ordering ok? ; MCM (9/14): Changed to type
   (pickedUp ?newWeapon)                  ; DA: Also new
   (distinct ?currentWeapon ?newWeapon))

; DA (7/13): Newly inserted - used in next (to prevent burden updates) and burdenChanged/0
; -- Same as changeWeapon/1, but this time the argument represents the *new* weapon
(<= (weaponChange ?newWeapon)
   (type ?newWeapon weapon-type) ; MCM (9/14): Changed to type
   (pickedUp ?newWeapon)
   (true (wielding ?currentWeapon))
   (distinct ?newWeapon ?currentWeapon))

;(<= arrowThrown
;   (direction ?dir)
;   (does hero (throw arrow ?dir)))

(<= arrowThrown
   (does hero (shoot-monster ?monster)))

; Meaning: hero is invisible at the moment.
; helper predicate to avoid unbound vars in negative statement
(<= (currentlyInvisible hero)
   (true (invisible hero ?n)))

(<= (currentlyAsleep ?agent)
   (true (asleep ?agent ?n)))

(<= (currentlyEnhancedArmor hero)
   (true (enhancedArmor hero ?n)))

(<= (currentlyEnhancedStrength hero)
   (true (enhancedStrength hero ?n)))

(<= (currentlyEnhancedSpeed hero)
   (true (enhancedSpeed hero ?n)))

(<= (armored hero)
   (true (wearing ?armor))
   (armor ?armor ?armor-type))

(<= (armed hero)
   (true (wielding ?weapon))
   (type ?weapon weapon-type)) ;MCM (9/14): Changed to type

; Meaning: Hero quaffs a potion currently in the sack
; This is just a convenience relation that indicates an item has been
; used up and no longer counts as a burden.  The effect of the
; quaff or read must be handled in a next rule.
(<= (use ?potion)
   (does hero (quaff ?potion)))

; Meaning: Hero reads a scroll currently in the sack
(<= (use ?scroll)
   (does hero (read ?scroll)))

; Meaning: The location of a provoked monster
(<= (relevantMonsterCell ?monster ?x ?y)
   (type ?monster monster-type) ; MCM (9/14): Updated to type
   (true (location ?monster ?x ?y))
   (provoked ?monster))

; Meaning: cellNearMonster is true for any cell within manhattan
; distance 2 of a provoked monster (including the cell the monster is in)
(<= (cellNearMonster ?monster ?x ?y)
  (relevantMonsterCell ?monster ?x ?y))

(<= (cellNearMonster ?monster ?x1 ?y)
  (relevantMonsterCell ?monster ?x ?y)
   (int ?d)        ; must ground ?d
   (> ?d 0)
   (> 3 ?d)        ; There is no < (lessThan)
   (- ?x ?d ?x1))

(<= (cellNearMonster ?monster ?x1 ?y)
  (relevantMonsterCell ?monster ?x ?y)
   (int ?d)
   (> ?d 0)
   (> 3 ?d)
   (+ ?x ?d ?x1))

(<= (cellNearMonster ?monster ?x ?y1)
  (relevantMonsterCell ?monster ?x ?y)
   (int ?d)
   (> ?d 0)
   (> 3 ?d)
   (- ?y ?d ?y1))

(<= (cellNearMonster ?monster ?x ?y1)
  (relevantMonsterCell ?monster ?x ?y)
   (int ?d)
   (> ?d 0)
   (> 3 ?d)
   (+ ?y ?d ?y1))

; four diagonal cases
(<= (cellNearMonster ?monster ?x1 ?y1)
  (relevantMonsterCell ?monster ?x ?y)
   (+ ?x 1 ?x1)
   (+ ?y 1 ?y1))

(<= (cellNearMonster ?monster ?x1 ?y1)
  (relevantMonsterCell ?monster ?x ?y)
   (+ ?x 1 ?x1)
   (- ?y 1 ?y1))

(<= (cellNearMonster ?monster ?x1 ?y1)
  (relevantMonsterCell ?monster ?x ?y)
   (- ?x 1 ?x1)
   (- ?y 1 ?y1))

(<= (cellNearMonster ?monster ?x1 ?y1)
  (relevantMonsterCell ?monster ?x ?y)
   (- ?x 1 ?x1)
   (+ ?y 1 ?y1))


;;; End of file

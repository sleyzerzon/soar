;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The GDL required ROLE relation - specifies players

(role explorer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Additional object definitions
;;;  Type Heirarchy: general -> specific

(mummyType mummy1) (horizontalMummyType mummy1)
(exitType exit)

(itemType crossbow)     (losType crossbow)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Spatial axioms

;;; An 8x8 set of 2 dimensional coordinates
(2d 0 0) (2d 1 0) (2d 2 0) (2d 3 0) (2d 4 0) (2d 5 0) (2d 6 0) (2d 7 0)
(2d 0 1) (2d 1 1) (2d 2 1) (2d 3 1) (2d 4 1) (2d 5 1) (2d 6 1) (2d 7 1)
(2d 0 2) (2d 1 2) (2d 2 2) (2d 3 2) (2d 4 2) (2d 5 2) (2d 6 2) (2d 7 2)
(2d 0 3) (2d 1 3) (2d 2 3) (2d 3 3) (2d 4 3) (2d 5 3) (2d 6 3) (2d 7 3)
(2d 0 4) (2d 1 4) (2d 2 4) (2d 3 4) (2d 4 4) (2d 5 4) (2d 6 4) (2d 7 4)
(2d 0 5) (2d 1 5) (2d 2 5) (2d 3 5) (2d 4 5) (2d 5 5) (2d 6 5) (2d 7 5)
(2d 0 6) (2d 1 6) (2d 2 6) (2d 3 6) (2d 4 6) (2d 5 6) (2d 6 6) (2d 7 6)
(2d 0 7) (2d 1 7) (2d 2 7) (2d 3 7) (2d 4 7) (2d 5 7) (2d 6 7) (2d 7 7)

;;; The four cardinal directions
(direction north)
(direction south)
(direction east)
(direction west)

;;; Direction-based relationships between coordinates
;;;  Read: ?n cells ?dir of ?x1 ?y1 is ?x2 ?y2
(<= (nCell ?n north ?x ?y1 ?x ?y2)
    (int ?n)
    (int ?x)
    (minus ?n ?y1 ?y2))
(<= (nCell ?n south ?x ?y1 ?x ?y2)
    (int ?n)
    (int ?x)
    (plus ?n ?y1 ?y2))
(<= (nCell ?n east ?x1 ?y ?x2 ?y)
    (int ?n)
    (int ?y)
    (plus ?n ?x1 ?x2))
(<= (nCell ?n west ?x1 ?y ?x2 ?y)
    (int ?n)
    (int ?y)
    (minus ?n ?x1 ?x2))

;;; More direction-based relationships between coordinates
;;;  Read: ?x1 ?y1 is ?dir of ?x2 ?y2
(<= (cardinalRelation north ?x1 ?y1 ?x2 ?y2)
    (int ?x1)
    (int ?x2)
    (lessThan ?y1 ?y2))
(<= (cardinalRelation south ?x1 ?y1 ?x2 ?y2)
    (int ?x1)
    (int ?x2)
    (greaterThan ?y1 ?y2))
(<= (cardinalRelation east ?x1 ?y1 ?x2 ?y2)
    (int ?y1)
    (int ?y2)
    (greaterThan ?x1 ?x2))
(<= (cardinalRelation west ?x1 ?y1 ?x2 ?y2)
    (int ?y1)
    (int ?y2)
    (lessThan ?x1 ?x2))
 
;;; A recursive set of axioms for determining line-of-sight
;;;  Read: There is a straight, unblocked path ?dir from ?x1 ?y1 to ?x2 ?y2

;; Base Case: 
(<= (lineOfSight ?dir ?x ?y ?x ?y)
    (int ?x)
    (int ?y)
    (direction ?dir))
;; Recursive Case: 
(<= (lineOfSight ?dir ?x1 ?y1 ?x2 ?y2)
    (direction ?dir)
    (not (true (blocked ?dir ?x1 ?y1)))
    (nCell 1 ?dir ?x1 ?y1 ?xNext ?yNext)
    (lineOfSight ?dir ?xNext ?yNext ?x2 ?y2))

;;; A recursive set of axioms for determining area-of-effect
;;;  Read: ?x2 ?y2 is within ?n steps along the cardinal directions of ?x1 ?y1

;; Base Case: 
(<= (areaOfEffect ?n ?x ?y ?x ?y)
    (int ?n)
    (int ?x)
    (int ?y))
;; Recursive Case: 
(<= (areaOfEffect ?n ?x1 ?y1 ?x2 ?y2)
    (int ?n)
    (direction ?dir)
    (nCell 1 ?dir ?x1 ?y1 ?xNext ?yNext)
    (minus 1 ?n ?nextN)
    (areaOfEffect ?nextN ?xNext ?yNext ?x2 ?y2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Action-derived axioms

;;; (move ?direction) will move the explorer one cell in that direction
;;;  All other actions will leave the explorer in the same location
(<= (nextExplorerLocation ?x2 ?y2)
    (true (location explorer ?x1 ?y1))
    (does explorer (move ?dir))
    (nCell 1 ?dir ?x1 ?y1 ?x2 ?y2))
(<= (nextExplorerLocation ?x ?y)
    (true (location explorer ?x ?y))
    (not (does explorer (move north)))
    (not (does explorer (move south)))
    (not (does explorer (move east)))
    (not (does explorer (move west))))

;;; Mummies will move two steps toward the explorer at every time-step unless
;;;  their health has been reduced to 0
(<= (nextMummyLocation ?mummy ?xMumNew ?yMumNew)
    (mummyType ?mummy)
    (horizontalMummyType ?mummy)
    (not (true (health ?mummy 0)))
    (nextExplorerLocation ?xExp ?yExp)
    (true (location ?mummy ?xMum ?yMum))
    (horizontalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMumInt ?yMumInt)
    (horizontalMummyStep ?xMumInt ?yMumInt ?xExp ?yExp ?xMumNew ?yMumNew))
(<= (nextMummyLocation ?mummy ?xMumNew ?yMumNew)
    (mummyType ?mummy)
    (verticalMummyType ?mummy)
    (not (true (health ?mummy 0)))
    (nextExplorerLocation ?xExp ?yExp)
    (true (location ?mummy ?xMum ?yMum))
    (verticalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMumInt ?yMumInt)
    (verticalMummyStep ?xMumInt ?yMumInt ?xExp ?yExp ?xMumNew ?yMumNew))
(<= (nextMummyLocation ?mummy ?x ?y)
    (mummyType ?mummy)
    (true (health ?mummy 0))
    (true (location ?mummy ?x ?y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Object-interaction axioms

;;; atExit is true if the explorer is at the same location as the exit
(<= atExit 
    (true (location explorer ?x ?y))
    (true (location exit ?x ?y)))

;;; attackedByMummy is true if the explorer and a mummy will be at
;;;  the same location at the end of the current timestep.
(<= attackedByMummy
    (mummyType ?mummy)
    (nextExplorerLocation ?x ?y)
    (nextMummylocation ?mummy ?x ?y))

;;; killed is true if the explorer's health has dropped to zero
(<= killed 
    (true (health explorer 0)))

;;; pickedUp is true of an item if the explorer will be standing on top of it
;;;  at the end of the current time-step
(<= (pickedUp ?item)
    (itemType ?item)
    (nextExplorerLocation ?x ?y)
    (true (location ?item ?x ?y)))

;;; canSeeMummy is true if the explorer will have a clear look at a mummy at
;;;  the end of the current time-step
(<= (canSeeMummy ?mummy ?dir)
    (mummyType ?mummy)
    (direction ?dir)
    (nextExplorerLocation ?xExp ?yExp)	
    (nextMummyLocation ?mummy ?xMum ?yMum)
    (lineOfSight ?dir ?xExp ?yExp ?xMum ?yMum))

;;; canBombMummy is true if throwing an explosive ?dist cells ?dir will catch
;;;  a mummy in its area of effect at the end of the current time-step
(<= (canBombMummy ?mummy ?dir ?distance)
    (mummyType ?mummy)
    (direction ?dir)
    (int ?distance)
    (nextExplorerLocation ?xExp ?yExp)
    (nextMummyLocation ?mummy ?xMum ?yMum)
    (nCell ?distance ?dir ?xExp ?yExp ?xTarget ?yTarget)
    (areaOfEffect 2 ?xTarget ?yTarget ?xMum ?yMum))

;;; mummyAttacked is true of a mummy if the explorer shoots or lobs a grenade
;;;  toward the location that that mummy will be at at the end of the current
;;;  time-step
(<= (mummyAttacked ?mummy)
    (does explorer (shoot ?dir))
    (canSeeMummy ?mummy ?dir))
(<= (mummyAttacked ?mummy)
    (does explorer (lob ?dir ?distance))
    (canBombMummy ?mummy ?dir ?distance))

;;; wouldMoveEastWest is true of a mummy who is east/west of the explorer
;;;  and would not be blocked if it took one step in that direction
(<= (wouldMoveEastWest ?dir ?xMum ?yMum ?xExp ?yExp)
    (cardinalRelation ?dir ?xExp ?yExp ?xMum ?yMum)
    (direction ?dir)
    (distinct ?dir north)
    (distinct ?dir south)
    (not (true (blocked ?dir ?xMum ?yMum))))
;;; wouldMoveNorthSouth is true of a mummy that is north/south of the
;;;  explorer and would not be blocked if it took one step in that direction
(<= (wouldMoveNorthSouth ?dir ?xMum ?yMum ?xExp ?yExp)
    (cardinalRelation ?dir ?xExp ?yExp ?xMum ?yMum)
    (direction ?dir)
    (distinct ?dir east)
    (distinct ?dir west)
    (not (true (blocked ?dir ?xMum ?yMum))))

;;; A horizontalMummyStep prefers moving east/west to moving north/south
(<= (horizontalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMumNew ?yMumNew)
    (wouldMoveEastWest ?dir ?xMum ?yMum ?xExp ?yExp)
    (nCell 1 ?dir ?xMum ?yMum ?xMumNew ?yMumNew))
(<= (horizontalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMumNew ?yMumNew)
    (not (wouldMoveEastWest east ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveEastWest west ?xMum ?yMum ?xExp ?yExp))   
    (wouldMoveNorthSouth ?dir ?xMum ?yMum ?xExp ?yExp)
    (nCell 1 ?dir ?xMum ?yMum ?xMumNew ?yMumNew))
(<= (horizontalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMum ?yMum)
    (2d ?xMum ?yMum) 
    (2d ?xExp ?yExp)
    (not (wouldMoveEastWest east ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveEastWest west ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveNorthSouth north ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveNorthSouth south ?xMum ?yMum ?xExp ?yExp)))

;;; A verticalMummyStep prefers moving north/south to moving east/west
(<= (verticalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMumNew ?yMumNew)
    (wouldMoveNorthSouth ?dir ?xMum ?yMum ?xExp ?yExp)
    (nCell 1 ?dir ?xMum ?yMum ?xMumNew ?yMumNew))
(<= (verticalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMumNew ?yMumNew)
    (not (wouldMoveNorthSouth north ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveNorthSouth south ?xMum ?yMum ?xExp ?yExp))
    (wouldMoveEastWest ?dir ?xMum ?yMum ?xExp ?yExp)
    (nCell 1 ?dir ?xMum ?yMum ?xMumNew ?yMumNew))
(<= (verticalMummyStep ?xMum ?yMum ?xExp ?yExp ?xMum ?yMum)
    (2d ?xMum ?yMum)
    (2d ?xExp ?yExp)
    (not (wouldMoveEastWest east ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveEastWest west ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveNorthSouth north ?xMum ?yMum ?xExp ?yExp))
    (not (wouldMoveNorthSouth south ?xMum ?yMum ?xExp ?yExp)))

;;; healType items are used up by performing the 'heal' action
;;; losType items are used up by performing the 'shoot' action
;;; aoeType items are used up by performing the 'lob' action
(<= (used ?item)
    (healType ?item)
    (does explorer heal))
(<= (used ?item)
    (losType ?item)
    (does explorer (shoot ?dir)))
(<= (used ?item)
    (aoeType ?item)
    (does explorer (lob ?dir ?distance)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The GDL required INIT relation - specifies the initial state of fluents

;;; Object locations
(init (location explorer 1 6))
(init (location mummy1 4 7))
(init (location exit 0 7))
(init (location crossbow 0 3))

;;; Character health
(init (health explorer 1))
(init (health mummy1 1))

;;; Unless otherwise specified adjacent spatial coordinates are assumed 
;;;  accessible from one another.  
(init (blocked south 3 0))
(init (blocked north 3 1))
(init (blocked south 6 1))
(init (blocked north 6 2))
(init (blocked south 2 2))
(init (blocked north 2 3))
(init (blocked south 3 2))
(init (blocked north 3 3))
(init (blocked south 4 2))
(init (blocked north 4 3))
(init (blocked south 1 3))
(init (blocked north 1 4))
(init (blocked south 2 4))
(init (blocked north 2 5))
(init (blocked south 3 4))
(init (blocked north 3 5))
(init (blocked south 6 3))
(init (blocked north 6 4))
(init (blocked south 7 3))
(init (blocked north 7 4))
(init (blocked south 1 6))
(init (blocked north 1 7))
(init (blocked south 5 6))
(init (blocked north 5 7))
(init (blocked south 0 4))
(init (blocked north 0 5))

(init (blocked east 4 0))
(init (blocked west 5 0))
(init (blocked east 0 1))
(init (blocked west 1 1))
(init (blocked east 6 1))
(init (blocked west 7 1))
(init (blocked east 0 3))
(init (blocked west 1 3))
(init (blocked east 6 3))
(init (blocked west 7 3))
(init (blocked east 5 2))
(init (blocked west 6 2))
(init (blocked east 0 5))
(init (blocked west 1 5))
(init (blocked east 4 5))
(init (blocked west 5 5))
(init (blocked east 6 5))
(init (blocked west 7 5))
(init (blocked east 5 6))
(init (blocked west 6 6))
(init (blocked east 1 4))
(init (blocked west 2 4))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The GDL required LEGAL relation - specifies legal moves for players

;;; It is always legal for the explorer to do nothing
(legal explorer noop)

;;; The explorer may move anywhere on the map along the cardinal 
;;;  directions so long as there are no walls in his way
(<= (legal explorer (move ?dir))
    (direction ?dir)
    (true (location explorer ?xOld ?yOld))
    (not (true (blocked ?dir ?xOld ?yOld)))
    (nCell 1 ?dir ?xOld ?yOld ?xNew ?yNew)
    (2d ?xNew ?yNew))

;;; The explorer may heal himself if he is holding a medKit
(<= (legal explorer heal)
    (true (holding ?item))
    (healType ?item))

;;; The explorer may shoot if he is holding a crossbow
(<= (legal explorer (shoot ?dir))
    (direction ?dir)
    (true (holding ?item))
    (losType ?item))

;;; The explorer may lob up to 2 cells away if he is holding a grenade and 
;;;  ?distance steps toward ?dir do not lead off of the map
(<= (legal explorer (lob ?dir ?distance))
    (true (holding ?item))
    (aoeType ?item)
    (direction ?dir)
    (int ?distance)
    (lessThan ?distance 3)
    (true (location explorer ?x1 ?y1))
    (nCell ?distance ?dir ?x1 ?y1 ?x2 ?y2)
    (2d ?x2 ?y2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The GDL required NEXT relation - specifies the dynamics of fluents

;;; Updates to explorer location are based on the nextExplorerLocation rule
(<= (next (location explorer ?x ?y))
    (nextExplorerLocation ?x ?y))

;;; Updates to mummy locations are based on the nextMummyLocation rule
(<= (next (location ?mummy ?x ?y))
    (nextMummyLocation ?mummy ?x ?y))

;;; If the explorer is attacked, his health is decreased by 1.  If the explorer
;;;  uses a medKit, his health is increased by 1. 
(<= (next (health explorer ?hpNew))
    (true (health explorer ?hpOld))
    attackedByMummy
    (not (does explorer heal))
    (minus 1 ?hpOld ?hpNew))
(<= (next (health explorer ?hpNew))
    (true (health explorer ?hpOld))
    (does explorer heal)
    (not attackedByMummy)
    (plus 1 ?hpOld ?hpNew))
(<= (next (health explorer ?hp))
    (true (health explorer ?hp))
    (not attackedByMummy)
    (not (does explorer heal)))
(<= (next (health explorer ?hp))
    (true (health explorer ?hp))
    attackedByMummy
    (does explorer heal))

;;; If a mummy is attacked, its health is decreased by 1.
;;; Otherwise, its health remains unchanged
(<= (next (health ?mummy ?hpNew))
    (mummyType ?mummy)
    (true (health ?mummy ?hpOld))
    (mummyAttacked ?mummy)
    (minus 1 ?hpOld ?hpNew))
(<= (next (health ?mummy ?hp))
    (mummyType ?mummy)
    (true (health ?mummy ?hp))
    (not (mummyAttacked ?mummy)))

;;; The exit and walls do not move
(<= (next (location exit ?x ?y))
    (true (location exit ?x ?y)))
(<= (next (blocked ?dir ?x ?y))
    (true (blocked ?dir ?x ?y)))

;;; Items remain on the ground until they are picked up
(<= (next (location ?item ?x ?y))
    (itemType ?item)
    (true (location ?item ?x ?y))
    (not (pickedUp ?item)))

;;; Items remain in the explorer's inventory from when they are picked up
;;;  until they are used to perform an action
(<= (next (holding ?item))
    (itemType ?item)
    (pickedUp ?item))
(<= (next (holding ?item))
    (true (holding ?item))
    (not (used ?item)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The GDL required TERMINAL relation - specifies the conditions under which
;;;  the game has ended

;;; The game is over if time runs out
(<= terminal
    (true (step ?t))
    (maxTime ?t))

;;; The game is over if the explorer is able to reach the exit
(<= terminal
    atExit)

;;; The game is over if the explorer is killed
(<= terminal
    killed)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The GDL required GOAL relation - specifies player rewards

;;; The explorer receives 0 points if he is killed
(<= (goal explorer 0)
    killed)

;;; The explorer receives 50 points if time runs out and he has neither been
;;;  killed nor reached the exit
(<= (goal explorer 50)
    (true (step ?t))
    (maxTime ?t)
    (not atExit)
    (not killed))

;;; The explorer receives 100 points if he reaches the exit without being 
;;;  killed
(<= (goal explorer 100)
    atExit
    (not killed))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Basic axioms of mathematics (defined over the range [0,7])

;;; The integers between 0 and 7
(int 0)
(int 1)
(int 2)
(int 3)
(int 4)
(int 5)
(int 6)
(int 7)

;;; The plus relationship defined on the integers between 0 and 7
(plus 0 0 0) (plus 1 0 1) (plus 2 0 2) (plus 3 0 3) (plus 4 0 4) (plus 5 0 5) (plus 6 0 6) (plus 7 0 7) 
(plus 0 1 1) (plus 1 1 2) (plus 2 1 3) (plus 3 1 4) (plus 4 1 5) (plus 5 1 6) (plus 6 1 7)
(plus 0 2 2) (plus 1 2 3) (plus 2 2 4) (plus 3 2 5) (plus 4 2 6) (plus 5 2 7)
(plus 0 3 3) (plus 1 3 4) (plus 2 3 5) (plus 3 3 6) (plus 4 3 7)
(plus 0 4 4) (plus 1 4 5) (plus 2 4 6) (plus 3 4 7)
(plus 0 5 5) (plus 1 5 6) (plus 2 5 7)
(plus 0 6 6) (plus 1 6 7)
(plus 0 7 7) 

;;; The minus relationship defined on the integers between 0 and 7
(minus 0 7 7) (minus 1 7 6) (minus 2 7 5) (minus 3 7 4) (minus 4 7 3) (minus 5 7 2) (minus 6 7 1) (minus 7 7 0) 
(minus 0 6 6) (minus 1 6 5) (minus 2 6 4) (minus 3 6 3) (minus 4 6 2) (minus 5 6 1) (minus 6 6 0)
(minus 0 5 5) (minus 1 5 4) (minus 2 5 3) (minus 3 5 2) (minus 4 5 1) (minus 5 5 0)
(minus 0 4 4) (minus 1 4 3) (minus 2 4 2) (minus 3 4 1) (minus 4 4 0)
(minus 0 3 3) (minus 1 3 2) (minus 2 3 1) (minus 3 3 0)
(minus 0 2 2) (minus 1 2 1) (minus 2 2 0)
(minus 0 1 1) (minus 1 1 0)
(minus 0 0 0) 

;;; The less-than relationship on the integers between 0 and 7
(lessThan 0 7) (lessThan 0 6) (lessThan 0 5) (lessThan 0 4) (lessThan 0 3) (lessThan 0 2) (lessThan 0 1)
(lessThan 1 7) (lessThan 1 6) (lessThan 1 5) (lessThan 1 4) (lessThan 1 3) (lessThan 1 2) 
(lessThan 2 7) (lessThan 2 6) (lessThan 2 5) (lessThan 2 4) (lessThan 2 3) 
(lessThan 3 7) (lessThan 3 6) (lessThan 3 5) (lessThan 3 4) 
(lessThan 4 7) (lessThan 4 6) (lessThan 4 5) 
(lessThan 5 7) (lessThan 5 6) 
(lessThan 6 7) 

;;; The greater-than relationship on the integers between 0 and 7
(greaterThan 7 0) (greaterThan 6 0) (greaterThan 5 0) (greaterThan 4 0) (greaterThan 3 0) (greaterThan 2 0) (greaterThan 1 0)
(greaterThan 7 1) (greaterThan 6 1) (greaterThan 5 1) (greaterThan 4 1) (greaterThan 3 1) (greaterThan 2 1) 
(greaterThan 7 2) (greaterThan 6 2) (greaterThan 5 2) (greaterThan 4 2) (greaterThan 3 2) 
(greaterThan 7 3) (greaterThan 6 3) (greaterThan 5 3) (greaterThan 4 3) 
(greaterThan 7 4) (greaterThan 6 4) (greaterThan 5 4) 
(greaterThan 7 5) (greaterThan 6 5) 
(greaterThan 7 6) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Step counter axioms

;;; The successor relationship defined on the time-steps between 1 and 50
(succ 1 2)
(succ 2 3)
(succ 3 4)
(succ 4 5)
(succ 5 6)
(succ 6 7)
(succ 7 8)
(succ 8 9)
(succ 9 10)
(succ 10 11)
(succ 11 12)
(succ 12 13)
(succ 13 14)
(succ 14 15)
(succ 15 16)
(succ 16 17)
(succ 17 18)
(succ 18 19)
(succ 19 20)
(succ 20 21)
(succ 21 22)
(succ 22 23)
(succ 23 24)
(succ 24 25)
(succ 25 26)
(succ 26 27)
(succ 27 28)
(succ 28 29)
(succ 29 30)
(succ 30 31)
(succ 31 32)
(succ 32 33)
(succ 33 34)
(succ 34 35)
(succ 35 36)
(succ 36 37)
(succ 37 38)
(succ 38 39)
(succ 39 40)
(succ 40 41)
(succ 41 42)
(succ 42 43)
(succ 43 44)
(succ 44 45)
(succ 45 46)
(succ 46 47)
(succ 47 48)
(succ 48 49)
(succ 49 50)

;;; The maximum defined time-step, t = 50
(maxTime 50)

;;; Time begins at t = 1
(init (step 1))

;;; Time advances in one second increments
(<= (next (step ?next))
	(true (step ?current))
	(succ ?current ?next))
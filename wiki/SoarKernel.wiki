#summary Soar Kernel notes

= List of Terms =

(jzxu)

Here's a list of terms and abbreviations used in the source code of the Soar
kernel whose meanings might not be obvious.

----
*slot*

From John Laird: 

 We used to select more than just the operator (state, problem space, and goal)
 all together this was the context. Slots were for things that can be selected,
 so there was a slot for each of those. Now there is just a slot for the
 operator, although some of that language might have bled over to selection of
 values for non-operator attributes. In general they are an out of date
 terminology.

Slots are contained by identifiers, and hold all the preferences associated
with the identifier, including acceptable wme preferences. Each identifier can
have multiple slots, which can be accessed via the `prev` and `next` fields
in the slot structure. Operator preferences are held in `context` slots,
which are identified by the isa_context_slot flag.

----
*tc*

transitive closure

----
*match goal*

The lowest goal (biggest number after the "S") that an instantiation of the LHS
of a production matches on. Part of the instantiation structure.

----
*potential* (backtracing) 

condition whose id is instantiated on a symbol linked from both the current
goal and a higher goal, and is tested for in the production's LHS using a path
from the current goal. 

For example, if the following wmes are in working memory

{{{
(S1 ^foo F1)
(S2 ^bar F1)
(F1 ^baz B1)
(S2 ^superstate S1)
}}}

and this production was backtraced through

{{{
sp {example
   (<s> ^bar <b>)
   (<b> ^baz <z>)
-->
   ...}
}}}

then `(<b> ^baz <z>)` would be a potential condition.

----
*potential* (life)

abstract invented concept that actually has no real meaning

----
*tm*

temporary memory. I believe that any preference that is currently valid in Soar
(either they are o-supported or the instantiation that generated them still
matches) is in temporary memory. Once a preference is no longer valid, it is
taken out of temporary memory (which involves setting the `in_tm` flag to
false, and taking them off the `preferences` array and `all_preferences`
lists on the slot they're on).

----
*clone* (preference)

a copy of a preference that is the result of a subgoal. While the inst pointer
of the original preference points to the instantiation of the rule that fired
in the subgoal to create the result, the inst pointer of the clone points to
the newly created chunk or justification. Therefore, the preference and its
clone exist on different match goals, and hence different match goal levels.

----
*instantiation*

a particular match of a production in working memory, and the preferences
generated

----
*DEBUG_MEMORY*

if this flag is defined, the contents of freed memory locations in the memory
pools are memset to 0xBB

----
= Old Soar Kernel Code Guide =

No, really, this page is under development. --Karen 12:25, 13 Feb 2007 (EST)

=="But where can I start?"==

In a nutshell:

The Soar Kernel is a very object-oriented, structured set of code.  If you
don't understand the basic Soar execution cycle and its phases, the source code
won't help you.  You should start by reading the introductory material in the
Soar Tutorials that are bundled with the releases (in the Documents directory).

Then read the first four chapters of the Soar Manual,   "Introduction" thru
"Learning"

== Basic code execution ==

== Data Structures ==

All of the structures are well-commented in the header files.  In earlier
versions of Soar (up thru 8.3.5), the single header file "soarkernel.h" defined
all the common structures used throughout the code.  I still find it the
easiest place to search for information eventhough it's a very large file as
code goes.  In 8.6.* and later, the header file was separated by function into
many smaller files which can be found in "Core/SoarKernel/include"

The agent_struct defined in agent.h includes all the system parameters,
counters, variables, and pointers to all the other structures used by an agent
(wmes, productions, hash tables, memory_pools, formats, etc etc).  It's a BIG
structure, tough to read, and includes a lot of detailed comments.  But if it
isn't defined or allocated here, the agent doesn't know about it.

Chances are you will never modify any structures in the rete, lexer, hash
tables, or backtracing facilities, but you should know that they exist.  If you
do start to muck with these structures, you better know what you are doing.
Changes here can greatly impact performance and even whether or not Soar will
run properly.  Several structures require their members to be defined in
specific order and are commented appropriately.

Structures that you should familiarize yourself with are symbols (a typedef'd
union!!), wmes, productions, instantiations, preferences, and (eventually)
memory pools.

  * `symbol_struct` is in symtab.h, _everything_ in soar boils down to some kind of symbol. See [[Development/Symbol]] for details.
  * `wme_struct` is in wmem.h, defines the working memory elements of an agent
  * `production_struct` is in production.h, these are the productions as loaded into Soar and stored in the rete.
  * `instantiations` are in instantiation.h, these store the bindings of productions as they are matched in the rete.  Instantiations whose conditions all match are fired during specific phases -- meaning their actions are executed:  preferences are asserted to create wmes, and/or RHS actions are executed.
  * `preference_struct` is defined in gdatastructs.h store a pointer to the instantiation that created them, and when the instantiation no longer matches, the preference is retracted.

== I want to add a new link! ==

Existing links include input/output and reward links.  Instructions on how to
make your own are here: [[Development/Links]]

= Things to add =

(I can tell that Bob found this page...)

A lot of topics are in the Soar FAQ

  * Basic structure of how critical code works (e.g. decision procedure is a big switch statement, how printing/XML generation works)
  * Locations of critical code (e.g. decision procedure, preference procedure, scheduler)
  * Union basics (most people don't know what unions are)
    * see Kernigan and Ritchie
    * Unions are a data structure that can have multiple data-dependent ways of storing and accessing  information, much like (but better than) overloading methods in C++.
  * Explain how `sysparams` work (e.g. how they are set/used, how to add a new one)
    * sysparams are just an array of agent parameters that store settings for runtime switches.  Most of the sysparams are either True/False, or can take on some enum value.  Setting a sysparam is easy -->> see init_soar.c for initializing and setting values.  Search the code for "set_sysparams" to see examples.
    * To add a sysparam, see gsysparams.h (although that file MUST be renamed or folded into another header when gSKI removed).  The code depends on looping over HIGHEST_SYSPARAM, so make sure it's always equal to the last one in the set of definitions.
    * When is it a sysparam, and when is it part of the agent struct?   Depends what you are using it for, and whether it needs to be exposed for the user interface.  If its a user-controlled setting, it should definitely be a sysparam.
  * What is a `slot`

From John: "We used to select more than just the operator (state, problem
space, and goal) and all together this was the context. Slots were for things
that can be selected, so there was a slot for each of those. Now there is just
a slot for the operator and although some of that language might have bled over
to selection of values for non-operator attributes. In general they are an out
of date terminology."

  * Basics of how wme changes are done in parallel (i.e. explain do_buffered_wm_and_ownership_changes)
  * Difference between wme and input_wme (and any other wmes there might be)
  * Where/how to add new links (e.g. ep-mem link, RL link, etc)
  * Explain `memory pool basics`

  * Basics of bit manipulations that are used (unless this is rete-only, in which case don't bother)
    * I think the rete is the only place bit manipulations occur.  Bit manipulations are extremely fast.  If you can guarantee your raw data structure, you can shift registers instead of calling complex instructions to go very fast.  Compilers hide this from you, but don't always know when they can optimize.  
  * Explain transitive closure and tc_num
  * What all the Soar kernel STL-like data structures are (e.g. lists, hash tables, growable strings, others?) and how to use them.
  * Ref counting (link to [[Development/Memory Leaks|Tracking down memory leaks]])


= Old Kernel TODO/BUGBUG audit =

== TODOs ==

{{{
agent.cpp:405:     TODO: Not clear why callbacks need to take the agent pointer essentially twice.

init_soar.cpp:1650:    // TODO: Make sure that this ifdef is neccessary for the timeing code

rhsfun.cpp:647:   /* TODO: We need a serious reference counting audit of the kernel But I think
}}}

== BUGBUGs ==

{{{
agent.h:59:/* RBD BUGBUG more comments here, or should this stuff be here at all? */
   some #define's for enums -- might want to fix this...

backtrace.h:46: /* RBD BUGBUG more comments here */ 
   changed to "NOTE"

chunk.cpp:57:   "next_result" field of the preference structures.  (BUGBUG: to save space 
   Old comment to use a cons to store result.  Changed "BUGBUG" to "NOTE"

chunk.h:23:/* RBD BUGBUG more comments here */ 
   regarding #defs for CHUNK_COND_TABLE sizes.  could add comments, or move def's

decide.cpp:791:  BUGBUG There is a problem here:  since the require/acceptable priority <br>
decide.cpp:1765:   potentially break some code, but it avoids the BUGBUG condition
   First comment anticipates the case where a WME has multiple prefs where REQUIRE is
   lower in the goalstack than an ACCEPTABLE, the stack gets popped, but the pref is
   referencing the defunct REQUIRE instead of the ACCEPTABLE.  The second comment refers
   to a code change in fake instantiations, changing the pref from REQUIRE to ACCEPTABLE,
   so as not to create the potential bug situation.   This is a tricky part of the code,
   so I left the BUGBUGs as is.

decide.cpp:3514:       BUGBUGBUG 
   This occurs in probabilistically_select routine, which was implemented for 
   NUMERIC_INDIFFERENCE mode.  Refers to need for error checking.

explain.cpp:272:  /* BUGBUG *** shouldn't have user interface stuff in kernel!! */ 
   yeah, right.  This is noting a place where info is printed to the user.  changed to bug noted:

explain.h:77:/* BUGBUG ms changes only really need tok (the tok from the p-node) 
   The ms_change_struct has pointers to both 'tok' and 'wme' and the comment says
   don't need both, but would have to change firer code.  We can live with as is.

lexer.cpp:52: *  BUGBUG There are still problems with Soar not being very friendly 
   Not a specific bug, just a comment that more support for users could be coded;  
   eg: balanced parens, bugs in productions, etc.  Maybe the clients can help...

lexer.cpp:369:/* --- BUGBUG: these routines are here because the ANSI routine strtod() isn't <br>
lexer.cpp:376:  /* BUGBUG without ANSI's strtod(), there's no way to check for floating
   These are some compiler-def'd checks for string support for strtod and strtoul

lexer.cpp:760:      /* BUGBUG if reading from top level, don't want to signal EOF */  <br>
lexer.cpp:789:      /* BUGBUG if reading from top level, don't want to signal EOF */ 
  in lex_vbar and lex_quote, this is a comment that we might incorrectly signal an EOF
  when we shouldn't.  This is a VERY old comment and doesn't seem to have been a problem.

lexer.cpp:1167:  BUGBUG: if the input line contains any tabs, the pointer comes out in 
  this is in print_location_of_most_recent_lexeme, which aids in debugging productions
  that can't be processed due to some error.  Not a critical bug...

osupport.cpp:256:   BUGBUG the code does a check of whether the lhs tests the match state via 
  pertains to longtime code for runtime o-support calculations

osupport.cpp:350:	   BUGBUG this check only looks at positive conditions.  we
  not an actual known bug, just anticipating that possibly ignoring negations could
  yield in this calculation, although it is assumed that any such production would get
  i-support

osupport.cpp:573:	   BUGBUG: this is not fully general; it does not rule out assiging
  SBH (Scott Huffman comment?) in section where calculating runtime o-support for
  operators, operator acceptable prefs are explicitly ruled out, but BUGBUG notes that
  it is not done in fully general way.  An example is provided.
  -- This is old code, so leave until future explorations of o-support

osupport.cpp:674:    /* BUGBUG With Doug's scheme, o_support_tc no longer needs to be a 
  a global agent variable o_support_tc could possibly be declared only locally.

osupport.cpp:777:   BUGBUG should follow ^object links up the goal stack if possible
  in find_known_goals.  routine finds variables that are certain to be bound to goals, 
  but doesn't follow any ^objects up the goal stack.  old code.

prefmem.cpp:15: *  BUGBUG  need some comments here
  changed to NOTE:    Problem is no header or file comments included...

prefmem.cpp:110:  /* BUGBUG check to make sure the pref doesn't have
  in make_preference, the comment specifies that should check value or referent
  to make sure doesn't have .isa_goal or .isa_impasse.  hmmm, ok thus far...

prefmem.cpp:335:  pref->slot = NIL;      /* BUGBUG use pref->slot in place of pref->in_tm? *?
  in remove_preference_from_tm.  need to investigate before changing.  not a problem?
  removed bugbug, left comment

print.cpp:173:    /* BUGBUG doesn't handle tabs correctly */ 
  in print_string, only if #ifdef __SC__, mishandles /t when setting printer_output_column

print.cpp:514:      /* BUGBUG if in context where id's could occur, should check possible id_flag
  in symbol_to_string when converting SYM_CONSTANT_SYMBOL_TYPE.  old issue, not sure if problem

print.h:200:extern void print_list_of_conditions(agent* thisAgent, condition *cond); /* BUGBUG comments */ 
  note to programmer to add comments.  deleted it.

production.h:50:      OPERAND_which_assert_list: (BUGBUG need info from REW or RCHONG) 
  variable in a struct which has no associated comments.  removed BUGBUG, left note.

recmem.cpp:198:   (BUGBUG I'm not sure this is really needed.)
  instantiate_rhs_value might have an extraneous parameter in arg list.  removed BUGBUG
  but left comment

recmem.h:47:/* RBD BUGBUG more comments here */
  somehow, I don't think Bob Doorenbos intends to add more comments at this point. removed.

reorder.cpp:16: *  BUGBUG comments here
  in head of file, no comments or description.  removed BUGBUG, left note.

reorder.cpp:850:      /* BUGBUG I'm not sure whether this can ever happen. */
  in reorder_simplified_conditions (code I've NEVER had occasion to look at!) this is
  a test to see if some LHS conditions are not connected, which may not be possible.  old code.

reorder.cpp:1059:    /* BUGBUG most people aren't going to understand this error message */
  in reorder_lhs.  I've never heard of people even SEEING this error message.  old code. left alone

reorder.h:8:   BUGBUG comments here
  in head of file, no comments or description.  removed BUGBUG, left note.

rete.cpp:3509:   BUGBUG should we check for duplicate justifications?
  pertains to add_production_to_rete.  valid comment, left alone.
 
rete.cpp:4104:/* BUGBUG clean this procedure up somehow? */
  pertains to rete_node_to_conditions, which is a lot if nested if-then stmts.
  old code.  left alone.  (LOTS of other code could be cleaned up first...)

rete.cpp:5601:  BUGBUG i haven't tested this with a production that has more than
  found in p_node_left_addition.  Comment left from RChong code for Operand, but not
  sure if still applies to Operand 2 (Soar 8), but I'll bet it does.  Left alone for now.
  Might ask Bob Wray to review it.  Or Ron.  applies when determining whether a match is IE or PE

rete.cpp:5675:			BUGBUG this check only looks at positive conditions.  we
  same section of code, determining support for a match.  here, we're looking at prods
  that aren't operator proposals to see how to classify them

rete.cpp:5851:/* BUGBUG shouldn't need to pass in both tok and w -- should have the
  in p_node_left_removal, could possibly pass one less arg.  left alone.

rhsfun_math.cpp:16: *  BUGBUG more comments here.  Nothing in soarkernel.h either.
  in head of file, no comments or description.  removed BUGBUG, left note.
}}}


#summary Environment integration proposal from May 2005, needs formatting

Event-Driven Environments Proposal
May 2005
1.	Introduction

The model for what a “run” should do is not very clear at the moment.  In particular when should the environment also run, when should the environment update, what different ways do we want to be able to interrupt a run and then how do we restart etc.

This document is an attempt to write down the capabilities we’d like to see from the system and then derive the correct commands and events to implement those behaviors.

2.	Capabilities

There are 3 basic classes of environments:
a)	No environment
All processing is internal.  Soar runs inside the debugger.
b)	Synchronous environment
Environment updates after all agents have executed a certain amount of processing:
i)	“Run 1 model” : After each decision (output-phase)
ii)	“Run-til-output model” : After each agent has generated output (or a max decision count has been reached).
iii)	Others might be appropriate here, e.g. after <n> decisions or after <t> seconds.
c)	Asynchronous environment
Environment updates independently of Soar’s execution cycle.  When the environment changes new input is sent to the agents.  When an agent generates output it produces a change in the environment.

Ways we’d like to be able to run Soar:
a)	Press a start button in the environment
b)	Press a step button in the environment
Step all agents.
c)	Start all agents and the environment running indefinitely in the debugger
d)	Run for some specific amount of time (decisions, phases etc.) in the debugger
a.	All agents and the environment updating
b.	One agent running and the environment not updating
e)	Run environment without running the agents (move the environment up to a specific point and then start the agents).

Ways we’d like to be able to interrupt and restart Soar:
a)	Stop all agents and the environment (synch or asynch environment)
a.	Want the ability to stop at end of any phase during execution cycle (stop-before capability).
b.	Ability to restart all agents and the environment from either a debugger or the environment.
b)	Stop all agents, environment keeps running (requires asynch environment perhaps synch too)
a.	Ability to restart all agents 
c)	Stop one agent without stopping the environment.
a.	Agent can only be restarted by stopping all other agents first. [Perhaps can restart one]
b.	Different agents may be stopped at the end of different phases so a restart must first synch them all up to the same phase before the run continues.

Want to be able to do init-soar and reinitialize an agent.  SML should provide automatic support for this.
3.	Implementation

Currently we have environments that interleave execution and calls to update the environment like this:

while (!stopped)
{
Run-Stage() ;		// Run Soar for a bit
Update-Stage() ;	// Check for output from agents ; update-world ; send new input
}

where Run-Stage is either “run 1 decision” or “run til output”.  This model assumes:
a)	The environment is always “in control” of the run.
b)	The Run-Stage runs to the expected completion point

I’m going to propose that we should change this model and decouple how Soar is run from when the environment should update.  This extends the idea of an “update-world” event.

The designer of the environment would select when the environment should update and register for an appropriate event.  Current candidates would be:
a)	after-all-output-phases
b)	after-all-agents-generate-output-or-reach-n-decisions
c)	each agent’s after-output-phase
d)	each agent’s after-generate-output
This list could be extended over time (e.g. after-every-nth-output-phase or after-n-seconds).

Synchronous environments would tend to use (a) or (b).  Asynchronous environments would tend to use (a) or (d) as the time to check for output from agents (they update and send input independently of this).  [Anyone could use (c) but it’s more overhead].

The events should include information about how Soar was run.  Obvious candidates would be “—self” and “—updateworld”.  This would give the environment the information necessary to decide whether to update or not depending on user settings or the design of that environment.  For instance “run –self” might often be a signal that the environment should not update while “run –self –updateworld” would be used to signal that the environment should really update after all.

We might also want an environment to support agents from multiple architectures (e.g. Soar and Act-R).  In order to do that we’d have to build a layer on top of those architectures which would know how to run both systems and how to generate these or equivalent events.

Once these events had been registered Soar could be run in any fashion and from either the environment or the debugger (or any other client) and the environment should behave correctly if we generate these events at the correct times.  [Need to make sure that they are all well defined].

This removes the concept of having multiple schedulers and instead has multiple events that an environment selects among.  If nobody’s listening the event isn’t generated so there should be no overhead from having several of these.  (This approach avoids the problem of how does the debugger know which scheduler to use when the user types “run”).

The key thing is that the environment’s run loop now looks like:
while (!stopped)
{
    Run-Stage() ; 	// Run Soar for a bit
}

together with an Update-Stage method like this:

Handle-update-event(event)
{
    check-for-output() ;
    update-world() ;
    generate-new-input() ;
}

Other implications:
The “start-system” command goes away because you simply type “run” in the debugger.  The environment is no longer always the one “in control” of the run.

4.	Evaluation

Ways we’d like to be able to run Soar:
a)	Press a start button in the environment
Could either issue a “run” and then later a “stop-soar” or could use a loop with a while (!stopped) flag and issue “run 1” calls.  If using the latter we need to be careful that the debugger can tell when the run really completes so it can update its auto-update windows.

NO: Realized that looping with “run 1” calls conflicts with the ability to stop one agent (ways to stop (c) below).  The next “run 1” would start all agents again, so we should prefer the “run” command and then issue a “stop-soar” in response to the user pressing “stop”.

b)	Press a step button in the environment
Either just issues a “run 1” (which may or may not update the world) or would issue “run” and then call “stop” when the next update-world event comes in (for that environment).  If the run command returns before the next update-world event then the user interrupted Soar in some manner so step is complete.

c)	Start all agents and the environment running indefinitely in the debugger
User types “run”.  This now triggers events which update the environment.  The environment is never executing its “Run-Stage”.  [Potentially could get different performance depending on where the run is issued—differences should be small].

d)	Run for some specific amount of time (decisions, phases etc.) in the debugger
a.	All agents and the environment updating
User types any “run” command and if the appropriate update-world event occurs during the run, the environment updates.
b.	One agent running and the environment not updating.
Run –self would still trigger these events (assuming the conditions were met—e.g. all agents reach output phase) but we would pass the flags used to run Soar (e.g. –self) so that the environment could decide whether to update or not when the event came in.

Ways we’d like to be able to interrupt and restart Soar:
a)	Stop all agents and the environment (synch or asynch environment)
a.	Want the ability to stop at end of any phase during execution cycle (stop-before capability).
Event based logic supports this well as discussed in stop-before proposal.

b.	Ability to restart all agents and the environment from either a debugger or the environment.
Restarts are fine as events are generated when crossing appropriate boundaries.  No need for environment/debugger to be “in synch” with each other.

b)	Stop all agents, environment keeps running
May need additional parameters for “stop-soar” command and have those be returned with the “stop-notification” event so we can tell if user is requesting environment to stop.  Of course, some won’t support that at all.

Main capability is that the environment should offer the option to update the world without running Soar.  (It just calls to the update-world method in the same manner as if Soar had triggered the event it’s interested in).  We would only support running it in this manner from controls in the environment itself, not from the debugger or Soar.
a.	Ability to restart all agents 

c)	Stop one agent without stopping the environment.
“stop-soar –self” stops the one agent.  Need to make sure the environment is not in a loop issuing “run <n>” commands.
a.	Agent can only be restarted by stopping all other agents first.
b.	Different agents may be stopped at the end of different phases so a restart must first synch them all up to the same phase before the run continues.
	The “run 0” command could be used to synch everyone up to the same phase (the current “stop-phase”).
	“run 1” (or higher) would make everyone synch up and then start to run.

How would this work with Unreal Tournament which has a tick() method to update the agents?  We would view everything outside of the “tick()” method as the update world part of the logic and so when Soar fired the event needed to update the world we’d return from tick() and when UT next called tick() we’d return control to Soar by returning from the event.  [This might need some careful coding].  In other words the event handler would become the long part of Soar’s operation with Soar actually running for only a small part of the time.  This is possible because event firing is always synchronous—i.e. Soar waits until the handler returns before continuing to execute and in this case the wait would be a long time.

Some possible pseudo-code for this:

// Thread-safe variable
bool synchNow = false ;

// Executes in UT's main thread
tick()
{
   synchNow = true ;
   while (agentExists() && synchNow)
     sleep() ;
}

// Executes in Soar's event thread
handleUpdateEvent()
{
   // We expect to be sleeping here 95% of the time
   // so UT is get the CPU
   while (!synchNow)
     sleep() ;

   // Or we might send this immediately world changes to
   // get less synchronous behavior
   sendInputToAgent() ;
   collectOutputFromAgent() ;
   synchNow = false ;
}
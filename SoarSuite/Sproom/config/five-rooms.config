##########################################################
# Top-level mode switch
# mixed-mode is sim except real hardware listens to commands and laser data is a min merge
mixed-mode = false;

##########################################################
# lcm-spy, set enabled true to enable
lcm-spy {
	enabled = false;
	
	# args = { yada, yada };
}

##########################################################
command {
	productions = "../../book-robot/clean-house-new.soar";
	spawnDebugger = false;

	# limitLinVelMax
	# limitLinVelMin
	# limitAngVelMax
	# limitAngVelMin
	# geomLength
	# geomWidth
	# geomHeight
	# geomWheelbase
	# lengthUnits
	# speedUnits
	# angleUnits
	# angleResolution
	# poseTranslation
	# headingGains
	# angularGains
	# linearGains
	# rangeCount
	# fieldOfView
	# visibleSeconds
	# manipulationDistance
	# gamepadZeroThreshold
	# lidarCacheTimeSeconds
}

##########################################################
# mixed-mode only
splinter {
	# tickMeters
	# baselineMeters
	# maxThrottleAccelleration
	# updateHz
	# orcHostname
	# ports
	# invert
	# captureOdometry
}

##########################################################
# This is all generated from the image file.
metadata {

	# Areas, rectagles with optional door tag
	areas = [ left, top, right, a3, a4, bottom, a6, a7, a8, bottomleft ];

	left {		# pos 2,2 size 18,59
		pos = [ -1.35, -1.5 ]; size = [ 2.7, 8.85 ];
	}
	top{		# pos 24,2 size 56,34
		pos = [ 1.95, 2.25 ]; size = [ 8.4, 5.1 ];
	}
	right {		# pos 82,2 size 16,76
		pos = [ 10.65, -4.05 ]; size = [ 2.4, 11.4 ];
	}
	a3 {		# top to right, pos 80,11 size 2,11
		door = true;
		pos = [ 10.35, 4.35 ]; size = [ 0.3, 1.65 ];
	}
	a4 {		# left to top, pos 20,12 size 4,13
		door = true;
		pos = [ 1.35, 3.9 ]; size = [ 0.6, 1.95 ];
	}
	bottom {	# pos 24,42 size 54,36
		pos = [ 1.95, -4.05 ]; size = [ 8.1, 5.4 ];
	}
	a6 {		# left to bottom, pos 20,45 size 4,10
		door = true;
		pos = [ 1.35, -0.6 ]; size = [ 0.6, 1.5 ];
	}
	a7 {		# bottom to right, pos 78,49 size 4,12
		door = true;
		pos = [ 10.05, -1.5 ]; size = [ 0.6, 1.8 ];
	}
	a8 {		# left to bottom left, pos 7,61 size 7,4
		door = true;
		pos = [ -0.6, -2.1 ]; size = [ 1.05, 0.6 ];
	}
	bottomleft {	# pos 2,65 size 18,13
		pos = [ -1.35, -4.05 ]; size = [ 2.7, 1.95 ];
	}
	
	# Gateways, points connecting two areas. 
	#	to: the connected areas
	#	dir: what wall the gateway is on in the corresponding area in "to"
	# See g0 for example
	gateways = [ g0, g1, g2, g3, g4, g5, g6, g7, g8, g9 ];

	g0 {	# pos 20,18
		to = [ left, a4 ];	# when in "left",
		dir = [ east, west];	# gateway is on "east" wall
		pos = [ 1.35, 4.95 ];
	}
	g1 {	# pos 23,18
		to = [ a4, top];
		dir = [ east, west];
		pos = [ 1.8, 4.95 ];
	}
	g2 {	# pos 80,16
		to = [ top, a3 ];
		dir = [ east, west];
		pos = [ 10.35, 5.25 ];
	}
	g3 {	# pos 81,16
		to = [ a3, right ];
		dir = [ east, west];
		pos = [ 10.5, 5.25 ];
	}
	g4 {	# pos 20,49
		to = [ left, a6 ];
		dir = [ east, west];
		pos = [ 1.35, 0.3 ];
	}
	g5 {	# pos 23,49
		to = [ a6, bottom ];
		dir = [ east, west];
		pos = [ 1.8, 0.3 ];
	}
	g6 {	# pos 78,54
		to = [ bottom, a7 ];
		dir = [ east, west];
		pos = [ 10.05, -0.45 ];
	}
	g7 {	# pos 81,54
		to = [ a7, right ];
		dir = [ east, west];
		pos = [ 10.5, -0.45 ];
	}
	g8 {	# pos 10,61
		to = [ left, a8 ];
		dir = [ south, north];
		pos = [ -0.15, -1.5 ];
	}
	g9 {	# pos 10,64
		to = [ a8, bottomleft ];
		dir = [ south, north];
		pos = [ -0.15, -1.95 ];
	}
	
	# Movable objects
	objects = [  ];

	block0 {
		type = block;
		pos = [ 12.0, 6.4 ];
		size = [ 0.2, 0.2 ];
	}
	block1 {
		type = block;
		pos = [ 5.1, -0.9 ];
		size = [ 0.2, 0.2 ];
	}
}

##########################################################
viewer {
	viewobjects = [ lidars, robot, remotelog, mapimage, waypoints, areas, obstacles ];

	robot {
		class = "april.viewer.ViewRobot";

		avatar {
			path = "config/meshmodels/cy.rwx";
			scale = 7;

			position = [ 0, 0, 0 ];
			rollpitchyaw_degrees = [ 90, 0, 90 ];
		}
	}

	remotelog {
		class = "april.viewer.RemoteLogEventHandler";
	}

	lidars {
		class = "april.viewer.ViewLaser";
	}

	lcmgl {
		class = "april.viewer.ViewLCMGL";
	}

	mapimage {
		class = "april.viewer.ViewMapImage";
		obstacles {
			image_path = "five-rooms.png";
			image_origin = [ 11,51 ];
			meters_per_pixel = 0.15;
		}
	}

	waypoints {
		class = "april.viewer.ViewWaypoints";
	}

	areas {
		class = "april.viewer.ViewAreaDescriptions";
	}

	obstacles {
		class = "april.viewer.ViewObstaclesReadOnly";
	}    
}

##########################################################
# Simulator has two required sections: obstacles and simobjects. All
# other parameters are "discovered" through the simobjects reflection
# mechanism.
simulator {
	obstacles {
		image_path = "five-rooms.png";
		image_origin = [ 11,51 ];
		meters_per_pixel = 0.15;
	}

	# Generic simulation instantiation: add a configuration block to
	# the list of "sims", then define the parameters in the
	# corresponding block. The block must have an entry named "class",
	# which specifies the java class that will be created and passed
	# the remainder of the arguments.
	simobjects = [ simsplinter, SIM_LIDAR_FRONT ];

	simsplinter {
		class = "april.sim.SimSplinter";
	}

	# Use an anonymous enclosure so we can inherit laser properties
	# amongst all lidars.  Individual lidars should be named according
	# to the LCM channel they publish on, and so that the extrinsics
	# can be found in the global scope.
	{
		class = "april.sim.SimLaser";

		degree0 = -90;
		degree_step = 1;
		nranges = 180;
		range_noise_m = 0.01;
		theta_noise_degrees = 0.25;
		max_range_m = 30;
		hz = 7;

		SIM_LIDAR_FRONT {
		    # no additional parameters to specify!
		}
	}
}

##########################################################
# the robot's coordinate frame has the vehicle at the origin, looking
# down the X axis, with +Y = left and +Z = up.
SIM_LIDAR_FRONT {
	position = [ 0, 0, 0.5 ];
	rollpitchyaw_degrees = [ 0, 0, 0 ];
	color = [1, 0, 0];
}

SICK_LIDAR_FRONT {
	position = [ 0, 0, 0.5 ];
	rollpitchyaw_degrees = [ 0, 0, 0 ];
	color = [0, 1, 0];
}

# This must be here for the viewer
LIDAR_LOWRES {
	position = [ 0, 0, 0.5 ];
	rollpitchyaw_degrees = [ 0, 0, 0 ];
	color = [0, 0, 1];
}


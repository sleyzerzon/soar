\chapter{Reinforcement Learning}
\label{RL}
\index{reinforcement learning}
\index{preference!numeric-indifferent}
\index{rl}

The reinforcement learning (RL) mechanism in Soar tunes operator selection knowledge to maximize a given reward function.
The reinforcement learning (RL) mechanism in Soar tunes the values of numeric indifferent preferences for operators to represent how beneficial the operator is to execute.
More precisely, the numeric indifferent preference values are adjusted to approximate the total discounted future reward the agent should expect from executing an operator, given a fixed policy of future decisions.

The main components of Soar's RL mechanism are (\ref{RL-rules}) representation of operator selection knowledge; (\ref{RL-reward}) reward representation; and (\ref{RL-algo}) the update algorithm. 
The detailed behavior of the RL mechanism is determined by numerous parameters that can be controlled and configured via the \soarb{rl} command. Please refer to the documentation for that command in section \ref{rl} on page \pageref{rl}.

We assume that the reader is familiar with basic reinforcement learning concepts and notation. If not, we recommend first reading \emph{Reinforcement Learning: An Introduction} (1998) by Richard S. Sutton and Andrew G. Barto.

\section{RL Rules}
\label{RL-rules}

Soar's RL mechanism learns Q-values for state-operator\footnote{In this context, the term ``state'' refers to the state of the task or environment, not a state identifier.} pairs.
Q-values are stored as numeric indifferent preferences asserted by specially formulated productions called \emph{RL rules}.
RL rules are identified by syntax.
A production is a RL rule if and only if its left hand side tests for a proposed operator, its right hand side asserts a single numeric indifferent preference, and it is not a template rule (see \ref{RL-templates}).
These constraints ease the technical requirements of identifying/updating RL rules and makes it easy for the agent programmer to add/maintain RL capabilities within an agent.

The following is an RL rule:

\begin{verbatim}
sp {example*rl*rule
   (state <s> ^name task-name
	          ^operator <o> +)
   (<o> ^name move
	    ^direction left)
-->
   (<s> ^operator <o> = 1.5)
}
\end{verbatim}

Note that the LHS of the rule can test for anything as long as it contains a test for a proposed operator.
The RHS is constrained to exactly one action: asserting a numeric indifferent preference for the proposed operator.

The following are not RL rules:

\begin{verbatim}
sp {multiple*preferences
   (state <s> ^operator <o> +)
-->
   (<s> ^operator <o> = 5, >)
}
\end{verbatim}  \vspace{12pt}

\begin{verbatim}
sp {variable*binding
    (state <s> ^operator <o> +
               ^value <v>)
-->
    (<s> ^operator <o> = <v>)
}
\end{verbatim}

The first rule proposes multiple preferences for the proposed operator and thus does not comply with the rule format.
The second rule does not comply because it does not provide a \emph{constant} for the numeric indifferent preference value.

In the typical RL use case, the agent should learn to choose the optimal operator in each possible state of the environment.
The most straightforward way to achieve this is to give the agent a set of RL rules, each matching exactly one possible state-operator pair.
This approach is equivalent to a table-based RL algorithm, where the Q-value of each state-operator pair corresponds to the numeric indifferent preference asserted by exactly one RL rule.

In the more general case, multiple RL rules can match a single state-operator pair, and a single RL rule can match multiple state-operator pairs.
Assuming that \soarb{numeric-indifferent-mode} is set to \soarb{sum}, all numeric indifferent preferences for an operator are summed when calculating the operator's selection probability.
In this context, RL rules can be interpreted more generally as binary features in a linear approximator of each state-operator pair's Q-value, and their numeric indifferent preference values their weights.
In other words,
$$Q(s, a) = w_1 \phi_2 (s, a) + w_2 \phi_2 (s, a) + \ldots + w_n \phi_n (s, a)$$
where all RL rules in production memory are numbered $1 \dots n$, $Q(s, a)$ is the Q-value of the state-operator pair $(s, a)$, $w_i$ is the numeric indifferent preference value of RL rule $i$, $\phi_i (s, a) = 0$ if RL rule $i$ does not match $(s, a)$, and $\phi_i (s, a) = 1$ if it does.
This interpretation allows RL rules to simulate a number of popular function approximation schemes used in RL such as tile coding and sparse coarse coding.

\section{Reward Representation}
\label{RL-reward}

Operator selection knowledge for an operator at a particular state is affected only by reward at that state.

RL updates are driven by reward signals.
In Soar, these reward signals are fed to the RL mechanism through a working memory link called the \soarb{reward-link}.
Each state in Soar's goal stack is automatically populated with a \soarb{reward-link} structure upon creation.
Soar will check this structure for a numeric reward signal for the last operator executed in the associated state at the beginning of every decision phase.
Reward is also counted when the agent is halted or a substate is retracted.
% What happens when an agent with multiple states is halted? Do the rewards in the substates get counted?

In order to be recognized, the reward signal must follow this pattern:

\begin{verbatim}
(<r1> ^reward <r2>)
(<r2> ^value [val])
\end{verbatim}

where \verb=<r1>= is the \soarb{reward-link} identifier, \verb=<r2>= is some intermediate identifier, and \verb=[val]= is any constant numeric value.
Any structure that does not match this pattern are ignored.
If there are multiple matching WMEs, their values are summed into a single reward signal.

As an example, consider the following state:

\begin{verbatim}
(S1 ^reward-link R1)
  (R1 ^reward R2)
    (R2 ^value 1.0)
    (R2 ^source environment)
  (R1 ^reward R3)
    (R3 ^value -0.2)
    (R3 ^source intrinsic)
\end{verbatim}  

In this state, there are two reward signals with values 1.0 and -0.2.
They will be summed together for a total reward of 0.8 and this will be the value given to the RL update algorithm.
The \verb=(R2 ^source environment)= and \verb=(R3 ^source intrinsic)= WMEs are not counted as rewards or special in any way, but were added by the agent to keep track of where the rewards came from.

Note that the \soarb{reward-link} is not part of the \soarb{io} structure and is not modified directly by the environment.
Reward information from the environment should be copied, via rules, from the \soarb{input-link} to the \soarb{reward-link}.
Also note that when counting rewards, Soar simply scans the \soarb{reward-link} and sums the values of all valid reward WMEs.
The WMEs are not modified and no bookkeeping is done to keep track of previously seen WMEs.
This means that reward WMEs that exist for multiple decision cycles such as o-supported WMEs will be counted multiple times.

\section{Updating RL Rule Values}
\label{RL-algo}

Soar's RL mechanism is integrated naturally with the decision cycle and performs online updates of RL rules.
Whenever an operator supported by RL rules is selected, the values of those RL rules are updated.
The update can be on-policy (Sarsa) or off-policy (Q-Learning), as controlled by the \soarb{learning-policy} parameter of the \soarb{rl} command.
For Sarsa, the update is
$$ \delta_t = \alpha \left[ r_{t+1} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t) \right] $$
where 
\begin{itemize}
\item $Q(s_t, a_t)$ is the Q-value of the state and chosen operator in decision cycle $t$.
\item $Q(s_{t+1}, a_{t+1})$ is the Q-value of the state and chosen operator in the next decision cycle.
\item $r_{t+1}$ is the total reward counted in the next decision cycle.
\item $\alpha$ and $\gamma$ are the settings of the \soarb{learning-rate} and \soarb{discount-rate} parameters of the \soarb{rl} command, respectively.
\end{itemize}

For Q-Learning, the update is
$$ \delta_t = \alpha \left[ r_{t+1} + \gamma \underset{a \in A_{t+1}}{\max} Q(s_{t+1}, a) - Q(s_t, a_t) \right] $$
where $A_{t+1}$ is the set of operators proposed in the next decision cycle.

Finally, $\delta_t$ is divided by the number of RL rules comprising the Q-value for the operator and the numeric indifferent values for each RL rule is updated by that amount.

An example walkthrough of a Sarsa update follows.

\begin{enumerate}

\item In decision cycle $t$, an operator \soarb{O1} is proposed, and RL rules \soarb{rl-1} and \soarb{rl-2} assert the following numeric indifferent preferences for it:
\begin{verbatim}
   rl-1: (S1 ^operator O1 = 2.3)
   rl-2: (S1 ^operator O1 =  -1)
\end{verbatim}  
	The Q-value for \soarb{O1} is $Q(s_t, \soarb{O1}) = 2.3 - 1 = 1.3$.
	 
\item \soarb{O1} is selected and executed, so $Q(s_t, a_t) = Q(s_t, \soarb{O1}) = 1.3$.

\item In decision cycle $t+1$, a total reward of 1.0 is counted on the \soarb{reward-link}, an operator \soarb{O2} is proposed, and another RL rule \soarb{rl-3} asserts the following numeric indifferent preference for it:
\begin{verbatim}
	rl-3: (S1 ^operator O2 = 0.5)
\end{verbatim}
	So $Q(s_{t+1}, \soarb{O2}) = 0.5$.

\item \soarb{O2} is selected, so $Q(s_{t+1}, a_{t+1}) = Q(s_{t+1}, \soarb{O2}) = 0.5$
	Therefore, 
	$$\delta_t = \alpha \left[r_{t+1} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t) \right] = 0.3 \times [ 1.0 + 0.9 \times 0.5 - 1.3 ] = 0.045$$
	Since \soarb{rl-1} and \soarb{rl-2} both contributed to the Q-value of \soarb{O1}, $\delta_t$ is evenly divided amongst them, resulting in updated values of
\begin{verbatim}
   rl-1: (<s> ^operator <o> = 2.3225)
   rl-2: (<s> ^operator <o> = -0.9775)
\end{verbatim}

\end{enumerate}

\subsection{Gaps in Rule Coverage}
\label{RL-gaps}

Call an operator with numeric indifferent preferences an RL operator.
The previous description had assumed that RL operators were selected in both decision cycles $t$ and $t+1$.
If the operator selected in $t+1$ is not an RL operator, then $Q(s_{t+1}, a_{t+1})$ would not be defined, and an update for the RL operator selected at time $t$ will be undefined.
% This is true for Sarsa, but what about Q-Learning?
We will call a sequence of one or more decision cycles in which RL operators are not selected between two decision cycles in which RL operators are selected a \emph{gap}.
Conceptually, it is desirable to use the temporal difference information from the RL operator after the gap to update the Q-value of the RL operator before the gap.
There are just no intermediate storage locations for these updates.
Requiring that RL rules support operators at every decision can be difficult for agent programmers, particularly when operators are required that do not represent steps in a task, but instead perform generic maintenance functions, such as cleaning processed output-link structures.

To address this issue, Soar's RL mechanism supports automatic propagation of updates over gaps.
For a gap of length $n$, the Sarsa update is
$$\delta_t = \alpha \left[ \sum_{i=t}^{t+n}{\gamma^{i-t} r_i} + \gamma^{n+1} Q(s_{t+n+1}, a_{t+n+1}) - Q(s_t, a_t) \right]$$
and the Q-Learning update is
$$\delta_t = \alpha \left[ \sum_{i=t}^{t+n}{\gamma^{i-t} r_i} + \gamma^{n+1} \underset{a \in A_{t+n+1}}{\max} Q(s_{t+n+1}, a) - Q(s_t, a_t) \right]$$

Note that rewards will still be counted during the gap, but they are discounted based on the number of decisions removed they are from the initial RL operator.

Gap propagation can be disabled by setting the \soarb{temporal-extension} parameter of the \soarb{rl} command to \soarb{off}.
When gap propagation is disabled, the RL rules supporting an operator that is followed by a gap are simply not updated.
The \soarb{rl} setting of the \soarb{watch} command (see Section \ref{watch} on page \pageref{watch}) is useful in identifying gaps.

\subsection{Eligibility Traces}
\label{RL-et}
The RL mechanism supports eligibility traces, which can improve the speed of learning by updating RL rules across multiple sequential steps.
The \soarb{eligibility-trace-decay-rate} and \soarb{eligibility-trace-tolerance} parameters control this mechanism.
By setting \soarb{eligibility-trace-decay-rate} to \soarb{0} (default), eligibility traces are in effect disabled.
When eligibility traces are enabled, the particular algorithm used is dependent upon the learning policy.
For Sarsa, the eligibility trace implementation is \emph{Sarsa($\lambda$)}. 
For Q-Learning, is \soarb{q-learning}, the eligibility trace implementation is \emph{Watkin's Q($\lambda$)}.

\subsection{Hierarchical Learning}
\label{RL-hrl}

Hierarchical reinforcement learning (HRL) is reinforcement learning done over a hierarchically decomposed task structure. Learning can be applied both to improving the implementation of a subtask and to the selection among subtasks. Compared to flat RL, HRL can demonstrate faster learning on a single task and can learn policies that are easier to transfer to related tasks. As applied to Soar, HRL relates to how the RL mechanism behaves during subgoal processing.

\subsubsection{Operator No-Change Impasses}
Consider the operator trace in Figure \ref{fig:rl-optrace} where operator \soarb{O1} is selected and impassed at state \soarb{S1}, with operators \soarb{O11}, \soarb{O12}, and \soarb{O13} being selected and applied at substate \soarb{S2}:

\begin{figure}
\insertfigure{Figures/rl-optrace}{1.5in}
\insertcaption{Example Soar subgoal operator trace.}
\label{fig:rl-optrace}
\end{figure}

The reinforcement learning algorithm will treat the operator selection at \soarb{S1} and \soarb{S2} as two separate RL problems (\soarb{S1} and \soarb{S2} have independent reward-link structures):

\begin{list}{S1}
\item Rewards at \soarb{S1} while \soarb{O1} is impassed are attributed to \soarb{O1}. By default, these rewards and the next-state prediction are discounted by the number of decision cycles that \soarb{O1} has been impassed.  So if rewards \soarb{r1}, \soarb{r2}, and \soarb{r3} are the rewards received at \soarb{S1} while \soarb{O1} is impassed, the target estimate for \soarb{Q(S1, O1)} is

$$r1 + \gamma(r2) + \gamma^2(r3) + \gamma^3[  Q(S1, O2)  ]$$

This model maintains the definition of the Q-function as representing the expected discounted sum of future reward received after selecting an operator.

Setting the \soarb{hrl-discount} parameter to \soarb{off} will change this behavior, such that the number of cycles \soarb{O1} has been impassed will be ignored.  Thus the target estimate for \soarb{Q(S1, O1)} would be

$$r1 + r2 + r3 + \gamma[  Q(S1, O2)  ]$$

\end{list}

\begin{list}{S2}
\item After applying \soarb{O13}, immediately before the state \soarb{S2} is removed, the architecture checks for reward \soarb{r} at \soarb{S2}. The target estimate for \soarb{Q(S2, O13)} is just \soarb{r}.

\end{list}

\subsubsection{Other Soar Impasses}
For impasses other than operator no-change, the behavior of RL at top-state \soarb{S1} and substate \soarb{S2} is as follows:

\begin{list}{S1}
\item During these impasses, there is no operator installed at \soarb{S1}.  If \soarb{O1} is the last operator selected before the impasse, \soarb{r} the reward received in the decision cycle immediately following \soarb{O1}, and \soarb{O2} the first operator selected after the impasse, then \soarb{O1} is updated with the target \soarb{r} + $\gamma$[\soarb{Q(S1, O2)}]. In other words, RL acts as if the impasse hadn't occurred.
\end{list}

\begin{list}{S2}
\item RL acts exactly as it does for an operator no-change: the substate is treated as an episodic task.

\end{list}

\section{Automatic Generation of RL Rules}

The number of RL rules required for an agent to accurately approximate operator Q-values is usually infeasibly large to write by hand, even for small domains.
Therefore, several methods exist to automate this.

\subsection{The gp Command}
The \soar{gp} command can be used to generate productions based on simple patterns.
This is useful if the states and operators of the environment can be distinguished by a fixed number of dimensions with finite domains.
An example is a grid world where the states are described by integer row/column coordinates, and the available operators are to move north, south, east, or west.
In this case, a single \soar{gp} command will generate all necessary RL rules:
	
\begin{verbatim}
gp {gen*rl*rules
   (state <s> ^name gridworld
              ^operator <o> +
              ^row [ 1 2 3 4 ]
              ^col [ 1 2 3 4 ])
   (<o> ^name move
        ^direction [ north south east west ])
-->
   (<s> ^operator <o> = 0.0)
}
\end{verbatim}
	
For more information see the documentation for this command on page \pageref{gp}.

\subsection{Rule Templates}
\label{RL-templates}

Rule templates allow Soar to dynamically generate new RL rules based on a predefined pattern as the agent encounters novel states.
This is useful when either the domains of environment dimensions are not known ahead of time, or when the enumerable state space of the environment is too large to capture in its entirety using \soar{gp}, but the agent will only encounter a small fraction of that space during its execution.
For example, consider the grid world example with 1000 rows and columns.
Attempting to generate RL rules for each grid cell and action a priori will result in $1000 \times 1000 \times 4 = 4 \times 10^6$ productions.
However, if most of those cells are unreachable due to walls, then the agent will never fire or update most of those productions.
Templates give the programmer the convenience of the \soar{gp} command without filling production memory with unnecessary rules.

Rule templates have variables that are filled in to generate RL rules as the agent encounters novel combinations of variable values.
A rule template is valid if and only if it is marked with the \soarb{:template} flag and, in all other respects, adheres to the format of an RL rule.
However, whereas an RL rule may only use constants as the numeric indifference preference value, a rule template may use a variable.
Consider the following rule template:

\begin{verbatim}
sp {sample*rule*template
    :template
    (state <s> ^operator <o> +
               ^value <v>)
-->
    (<s> ^operator <o> = <v>)
}
\end{verbatim}

During agent execution, this rule template will match working memory and fire like any other rule.
However, the rule firing will not create the numeric indifferent preference on the RHS.
Instead, a new production is created by substituting all variables in the rule template that matched against constant values with the values themselves.
Suppose that the LHS of the rule template matched against the state

\begin{verbatim}
(S1 ^value 3.2)
(S1 ^operator O1 +)
\end{verbatim}

Then the following production will be added to production memory:

\begin{verbatim}
sp {rl*sample*rule*template*1
    (state <s> ^operator <o> +
               ^value 3.2)
-->
    (<s> ^operator <o> = 3.2)
}
\end{verbatim}

The variable \soar{<v>} is replaced by \soar{3.2} on both the LHS and the RHS, but \soar{<s>} and \soar{<o>} are not replaced because they matches against identifiers (\soar{S1} and \soar{O1}).
As with other RL rules, the value of \soar{3.2} on the RHS of this rule may be updated later by reinforcement learning, whereas the value of \soar{3.2} on the LHS will remain unchanged.
If \soar{<v>} had matched against a non-numeric constant, it will be replaced by that constant on the LHS, but the RHS numeric indifference preference value will be set to zero to make the new rule valid.

The new production's name adheres to the following pattern:
\soarb{rl*template-name*id}, where \soarb{template-name} is the name of the originating rule template and \soarb{id} is the smallest positive integer such that the new production's name is unique.

If an identical production already exists in production memory, then the newly generate production is discarded.
It should be noted that the current process of identifying unique template match instances can become quite expensive in long agent runs.
Therefore, it is recommended to generate all necessary RL rules using the \soar{gp} command or via custom scripting when possible.

\subsection{Chunking}
Since RL rules are regular productions, they can be learned by chunking just like any other production.
This method is more general than using the \soar{gp} command or rule templates, and is useful if the environment state consists of arbitrarily complex relational structures that cannot be enumerated.

sp {apply*waypoints
   (state <s> ^operator <op>)
   (<op> ^name initialize-simple-robot)
-->
   (<s> ^waypoints <w>)
   (<w> ^waypoint <w1> <w2> <w3> <w4> <w5> <w6>)
   (<w1> ^x 0 ^y 0 ^id 1 ^next <w2> <w6>)
   (<w2> ^x 2 ^y 1 ^id 2 ^next <w1> <w3> <w6>)
   (<w3> ^x 4 ^y 1 ^id 3 ^next <w2> <w4> <w5>)
   (<w4> ^x 5 ^y 0 ^id 4 ^next <w3> <w5>)
   (<w5> ^x 4 ^y -1 ^id 5 ^next <w3> <w4> <w6>)
   (<w6> ^x 2 ^y -1 ^id 6 ^next <w1> <w2> <w5>)
}

# this will automatically retract as soon as there is a corresponding waypoint on the input-link
#sp {elaborate*output-link*add-waypoints-for-map
#   (state <s> ^io <io>
#              ^waypoints.waypoint <w>)
#   (<io> ^input-link <il>
#         ^output-link <ol>)
#   (<w> ^id <id> ^x <x> ^y <y>)
#  -{(<il> ^self.waypoints.waypoint <wi>)
#    (<wi> ^id <id>)}
#-->
#   (<ol> ^add-waypoint <aw>)
#   (<aw> ^id <id> ^x <x> ^y <y>)
#}

# if we're close enough to a waypoint, then mark that we are "at" the waypoint
sp {elaborate*waypoints*at-waypoint
   (state <s> ^io.input-link.self.waypoints.waypoint <wi>
              ^waypoints <ws>
              ^parameters.waypoint-tolerance <wpt>
             -^name selection)
   (<wi> ^distance < <wpt>
         ^id <id>)
   (<ws> ^waypoint <w>)
   (<w> ^id <id>)
-->
   (<ws> ^current-waypoint <w>)
}

sp {monitor*waypoints*at-waypoint
   (state <s> ^superstate nil
              ^waypoints.current-waypoint <a>)
   (<a> ^x <x> ^y <y>)
-->
   (write (crlf) |Current-waypoint: (| <x> |,| <y> |)|)
}

sp {monitor*waypoints*at-waypoint*top
   (state <s> ^superstate nil
              ^waypoints.current-waypoint <a>)
   (<a> ^x <x> ^y <y>)
-->
   (exec player-print |Current-waypoint: (| <x> |,| <y> |)|)
}

sp {monitor*multiple-ats
   (state <s> ^waypoints <ws>)
   (<ws> ^current-waypoint <a1> {<a2> <> <a1>})
   (<a1> ^next)
   (<a2> ^next)
-->
   (write (crlf) |Multiple ats in waypoints: | <a1> | | <a2>)
   (exec print |Multiple ats in waypoints: | <a1> | | <a2>)
   (interrupt)
}

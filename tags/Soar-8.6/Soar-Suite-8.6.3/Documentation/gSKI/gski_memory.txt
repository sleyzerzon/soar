gSKI Memory Management Rules

* Debugging Memory Leaks *

   The debug build of gSKI has some built-in checks to detect unreleased
   gSKI objects. When a gSKI program exits, a filed called gSKI_Unreleased.txt
   will be written to the current directory. This file contains a list of
   unreleased objects. For each object, its address and type are given.
   Additionally, an allocation sequence number is assigned for each object
   which assists in debugging. 
   
   Given the sequence number, a particular allocation can be debugged by
   entering the value in line 77 of gSKI_ReleaseImpl.cpp and then setting
   a debug breakpoint within the if statement. For example:

      if(allocCount == 31)
      {
         int x = 0; // set breakpoint here
      }

   The breakpoint will be fired when object number 31 is allocated. By
   looking at a stack backtrace at this point you can determine exactly
   where in your code the object is being allocated and correct the leak.

* General *

   Don't forget to destroy the kernel and release the kernel factory
   when your program exits:

      pFactory->DestroyKernel(pKernel);
      pFactor->Release();
      return 0;

   
* Iterators *

   All iterator objects must be released. In addition, any objects returned
   by the GetVal() method of the iterator must be released by the client
   code. For example:

   for(it = ...; it->IsValid(); it->Next())
   {
      Foo* pFoo = it->GetVal();

      // Do something with pFoo

      pFoo->Release(); // Release
   }
   it->Release(); // Release the iterator

   The iterator will take care of releasing any objects in the sequence
   not accessed by the client code.

* WMEs *

   WMEs added with AddWmeXXX must be released. It is not sufficient to simply 
   call RemoveWme. This goes for the WMEs returned by ReplaceXXXWme as well.
   A typical invocation should look like this:

      gSKI::IWme* pOldWme = m_pWme;
      m_pWme = pMemory->ReplaceIntWme(m_pWme, 123);
      pOldWme->Release();
      

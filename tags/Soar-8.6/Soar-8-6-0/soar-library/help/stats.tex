\subsection{\soarb{stats}}
\label{stats}
\index{stats}
Print information on Soar's runtime statistics. 
 Priority: 1; Status: Incomplete\\ 
Memory pool and rete stats not implemented with structured output.--Jonathan 16:04, 8 Mar 2005 (EST) \\ 
stats -r (raw output) looks like trash output.--Jonathan 16:01, 8 Mar 2005 (EST) 
\subsubsection*{Synopsis}
\paragraph*{Structured Output}
\begin{verbatim}
stats
\end{verbatim}
\paragraph*{Raw Output}
\begin{verbatim}
stats [-s|-m|-r]
\end{verbatim}
\subsubsection*{Options}
\begin{tabular}{|l|l|}
\hline 
 -m, --memory  & report usage for Soar's memory pools  \\
 \hline 
 -r, --rete  & report statistics about the rete structure  \\
 \hline 
 -s, --system  & report the system (agent) statistics. This is the default if no args are specified.  \\
 \hline 
\end{tabular}
\subsubsection*{Description}
This command prints Soar internal statistics. The argument indicates the component of interest.

With the \textbf{--system} flag, the \textbf{stats} command lists a summary of run statistics, including the following: 
\begin{quote}
\begin{description}
\item[Version] --- The Soar version number, hostname, and date of the run.
\item[Number of productions] --- The total number of productions loaded in the
        system, including all chunks built during problem solving and all
        default productions.
\item[Timing Information] --- Might be quite detailed depending on the
flags set at compile time.  
\item[Decision Cycles] ---  The total number of decision cycles in the
	run and the average time-per-decision-cycle in milliseconds.
	\index{decision!cycles}
\item[Elaboration cycles] --- The total number of elaboration
	cycles that were executed during the run, the everage number of 
elaboration cycles per decision cycle,  and the average 
time-per-elaboration-cycle in milliseconds.  This is not the total number of
production firings, as productions can fire in parallel.
	\index{elaboration!cycles}
\item[Production Firings] --- The total number of productions that were fired. 
\item[Working Memory Changes] --- This is the total number of changes to
	working memory. This includes all additions and deletions from working memory.  Also prints the average match time.
\item[Working Memory Size] --- This gives the current, mean and maximum number 
	of working memory elements.
	\index{working memory!size}
\end{description}
\end{quote}
The optional \textbf{stats} argument \textbf{--memory} provides information about memory usage and Soar's memory pools, which are used to allocate space for the various data structures used in Soar.

The optional \textbf{stats} argument \textbf{--rete} provides information about node usage in the Rete net, the large data structure used for efficient matching in Soar.

\subsubsection*{See Also}
\hyperref[timers]{timers} 

\subsubsection*{A Note on Timers}
The current implementation of Soar uses a number of timers to provide time-based statistics for use in the stats command calculations. These timers are:
\begin{verbatim}
 total CPU time
 total kernel time
 phase kernel time (per phase)
 phase callbacks time (per phase)
 input function time
 output function time
\end{verbatim}
Total CPU time is calculated from the time a decision cycle (or number of decision cycles) is initiated until stopped. Kernel time is the time spent in core Soar functions. 
In this case, kernel time is defined as the all functions other than the execution of callbacks and the input and output functions. The total kernel timer is only stopped for these functions.
The phase timers (for the kernel and callbacks) track the execution time for individual phases of the decision cycle (i.e., input phase, preference phase, working memory phase, output phase, 
and decision phase). Because there is overhead associated with turning these timers on and off, the actual kernel time will always be greater than the derived kernel time (i.e., the sum of all the phase
kernel timers). Similarly, the total CPU time will always be greater than the derived total (the sum of the other timers) because the overhead of turning these timers on and off is included in the total 
CPU time. In general, the times reported by the single timers should always be greater than than the corresponding derived time. Additionally, as execution time increases, the difference between these 
two values will also increase. For those concerned about the performance cost of the timers, all the run time timing calculations can be compiled out of the code by defining NO\_TIMING\_STUFF (in soarkernel.h)
before compilation. 

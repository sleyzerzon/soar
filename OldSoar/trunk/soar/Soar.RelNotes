

              Summary of changes between Soar 8.4.5 and Soar 8.5.
                            Scott Wallace
                            August, 2003


The change from Soar8.4.5 to Soar8.5 introduces some new features, and
bug fixes. Below is a brief summary of the salient changes (all
modifications have been verified with the soar-8.5-test-suite which is
released independently from this source code).


====================
Operator No Changes:
====================

	In Soar 8.4.5, Operator No Changes we're identified agressively by
the architecture. This meant that they could be created before the end
of the decision cycle.  In some situations, this led to odd behavior,
notably within some of the tutorial lessions.  As a result, this
behavior has now become a compile-time option and is no longer
included in the deafult-builds.  If you desire Soar with aggressive no
changes, simply add the AGRESSIVE_ONC flag to soarBuildOptions.h and
recompile.


====================
MatchTime Interrupt:
====================

	Soar 8.5 now supports interrupting execution at production match-time
in addition to interrupts when a production fires.  This new
capability makes it possible to examine Soar's state before the
production fires, and even makes it possible to excise the production
that matches before its effects are realized.  To use the matchtime 
interrupt feature, productions must add the ':interrupt' directive as 
in the following example production:

	sp { interrupt*on*application
			 :interrupt
			 (state <s> ^operator.name stop)
       -->
       (write (crlf) |I've already Halted|)}

Note that supporting this feature adds a small amount of computational
overhead to the match phase.  If you desire a maximally streamlined
version of Soar, recompile /without/ the MATCHTIME_INTERRUPT flag in
soarBuildOptions.h



====================
Reject Preferences:
====================

	Earlier versions of Soar processed all reject preferences after
acceptable preferences.  One of the unintuitive side effects of this
is that when a user wants to change the value of a wme, they typically
need to test that its current value is not equal to the new value.  As
a first attempt to alleviate this artifact, by default Soar 8.5
changes the order in which preferences are evaluated by examining
O-Supported Reject preferences first thus (^cheese-type cheddar -
chedder +) will result in the wme (... ^cheese-type cheddar) remaining
in working-memory.  Note that this may have some unanticipated
consequences, and can be turned off be undefining the O_REJECTS_FIRST
flag in soarBuildOptions.h and recompiling.


=========================
Cmdline Interface Parser:
=========================

	Now appropriately parses strings containing the '#' character.


================
Run Till Output:
================

	In Soar 8.3 - 8.4.5, if an output command was issued in the first
decision-cycle, it would not be appropriately detected.  As a result,
if Soar was instructed to run until output, and output occured on the
1st decision cycle, Soar would continue running for 15 decision cycles
before returning control to the user.  This bug was most often noticed
using simple agents in TankSoar, and is now fixed in Soar 8.5.


=================	
O Support Mode 4:
=================
	
	O Support Mode 3 (the deafult mode in Soar 8.3 - 8.4.5) is meant to
give I-Support to elaborations of the operator.  At certain times,
these elaborations were not detected as such, and received O-Support.
Soar 8.5's O Support Mode 4 can overcome these problems by detecting
more operator elaborations.  However, it also makes the following change
from O-Support Mode 3:
	mixed productions (i.e. operator applications + operator elaborations)
now receive i-support instead of o-support.  Running with 'warnings -on'
will print messages when any such productions fire.  You should try
to be careful not to build any such mixed productions when using
o-support mode 4

	
		
	
================================
Numeric Indifference Prefrences:
================================

	Soar 8.5 has better capabilities to support behavioral diversity
than previous versions of Soar.  The difference stems from Soar 8.5
numeric indifferent preferences that allow operators to be assigned
weights along with the '=' preference.  In the event of a tie, the
indifference selection mechanism is invoked.  In previous versions of
Soar, the probability of selecting any of the tied operators was
distributed evenly among the candidates (assuming the
indifferent-selection mode was 'random').  Soar 8.5's numeric
indifferent preferences allow the programmer to skew this distribution
such that certain operators are chosen more or less frequently.
Preferences are specified simply by adding an integer or float value
following an operator's '=' preference. As in the example below:

	sp { example	
	   (state <s> ^superstate nil -^initialized true)
  -->
     (<s> ^operator <o> + = 30)
     (<o> ^name initialize-a)}


 Two algorithms are available via a run-time switch:

	numeric-indifferent-mode -avg
  -----------------------------

	Here, we calculate the 'average' preference value associated with
	a particular operator.  Thus, if preference A for operator X has value 30
	while preference B for operator X has value 60, the average will be 45.

	Once this value has been calculated for all competeing operators, we
  sum their average preferences and select a random number between 0 and
	this sum.  Each operator is associated with a range on this scal equal to 
	its average numeric preference.  Thus, the randomly selected number can
	simply be mapped back to an operator that then becomes for 'selected'
	operator for the current decison.

	In average mode, indifferent preferences without a numeric value are
  given the default value of 50 for selection purposes.  For
  programmers, we expect that this mode of numeric-indifferent
  selection will be most intuitive.  Note however, that this scheme
  doesn't make a lot of sense for preferences are less than zero.  If
  an operator's average value is ever below zero, Soar will print a
  warning indicating this situation.  As an initial recommendation,
	we suggest using values between 0.0 and 100.0 for your operators.


	

	numeric-indifferent-mode -sum
  -----------------------------

	Here, the preferences for each operator are first summed.  Thus, if
  preference A for operator X has value 30 while preference B for
  operator X has value 70.5 the sum will be 100.5.  This sum is
  calculated for all competing operators.  Next, we calculate:

		e ^ (preference_sum / agent_temperature)
	
	where agent_temperature is a compile time constant currently set at 25.0

	We'll call this value the operator's final numeric preference.

	Finally, we sum all the competing operator's final numeric
  preferences and select a random number between 0 and this sum.
	Each operator is associated with a range on this scale equal to the
	size of its final numeric preference.  Thus, the randomly selected number
	can simply be mapped back to an operator that then becomes the 'selected'
  operator for the current decision.  

  In the sum mode, indifferent preferences without a numeric value are
	given the default value 0.0 for the selection purposes.  Note it
	does make sense to use this methodology even if the numeric
	preferences are negative, however, because the numeric preference
	are used in exponientation, their values should be somewhat limited
	so floating-point overflow does not become a problem.

  We expect this sum mode to be more useful for future reinforcement-learning
	methods, and have included it here mainly for experimental purposes.

	

===============
Timer Warnings:
===============
	
	Timer warnings are not displayed unless the following are true:
		- Soar was compiled with the WARN_IF_TIMERS_REPORT_ZERO flag
		- at runtime, the 'warnings' sysparam is set to TRUE 
				(as with the 'warnings -on' command)






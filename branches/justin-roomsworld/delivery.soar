# SOAR COMMANDS

w 0
smem --set mirroring on

multi-attributes area
multi-attributes child
multi-attributes lti
multi-attributes object
multi-attributes retrieved
multi-attributes rehearsed
multi-attributes to-be-retrieved
multi-attributes task
multi-attributes waypoint

sp {interrupt*monitor
   (state <s> ^type state
              ^operator.name {<name> << timing-trigger recurse >>}
   )
-->
   #(write |operator | <name>)
   #(interrupt)
}

# DELIVERY PROBLEM SPACE

sp {propose*init-agent
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name init-agent)
}

sp {apply*init-agent
   (state <s> ^operator.name init-agent)
-->
   (<s> ^name delivery
        ^areas <areas>
        ^flags <flags>
        ^ltis <ltis>
        ^metrics <metrics>
        ^objects <objects>
        ^tasks <tasks>)
   (<flags> ^area <area-flags>
            ^episode <episode-flags>
            ^manual <manual-flags>)
   (<episode-flags> ^timing-trigger 0)
   (<manual-flags> ^tasks-initialized no)
   (<metrics> ^start-time (timestamp)
              ^num-retrievals 0
              ^num-circuits -1
              ^num-initial-retrievals 0
              ^num-tasks-completed 0)
}

sp {delivery*elaborate*parameters
   (state <s> ^name delivery)
-->
   (<s> ^parameters <params>)
   (<params> ^angular-velocity 10
             ^collision-distance 0.9
             ^collision-bearing 45
             ^distance-tolerance 1.0
             ^heading-tolerance 1.5)
}

sp {delivery*elaborate*constants
   (state <s> ^name delivery
              ^parameters <params>)
   (<params> ^distance-tolerance <distance-tol>)
-->
   (<s> ^constants <constants>)
   (<constants> ^gateway-deltas <deltas>
                ^direction-opposites <opposites>
                ^operator-preferences <preferences>)
   (<deltas> ^north <delta-north>
             ^south <delta-south>
             ^east <delta-east>
             ^west <delta-west>)
   (<delta-north> ^x 0.0
                  ^y (+ 0.5 <distance-tol>))
   (<delta-south> ^x 0.0
                  ^y (- -0.5 <distance-tol>))
   (<delta-east> ^x (+ 0.5 <distance-tol>)
                 ^y 0.0)
   (<delta-west> ^x (- -0.5 <distance-tol>)
                 ^y 0.0)
   (<opposites> ^north south
                ^south north
                ^east west
                ^west east)
   (<preferences> ^initialization 10
                  ^metrics 15
                  ^flags 17
                  ^record 20
                  ^retrieve 25
                  ^task 30
                  ^movement 40)
}

sp {delivery*elaborate*load-smem-tasks
   (state <s> ^superstate nil
              ^parameters.tasks-file {<file> <> dummy})
-->
   (cmd |source | <file>)
}

# ELABORATIONS

# default

sp {elaborate*state*topstate
   (state <s> ^superstate nil)
-->
   (<s> ^topstate <s>)
}

sp {elaborate*state*state-name
   (state <s> ^superstate.operator.name <name>)
-->
   (<s> ^name <name>)
}

sp {elaborate*state*inherited*defaults
   (state <s> ^superstate.{<attr> << io topstate >>} <val>)
-->
   (<s> ^<attr> <val>)
}

# domain-specific inherited attributes

sp {elaborate*state*inherited*roomsworld
   (state <s> ^superstate.{<attr> << parameters constants areas flags ltis metrics objects tasks >>} <val>)

-->
   (<s> ^<attr> <val>)
}

# memory

# TODO these rules will not work on LTIs with cyclic references

sp {elaborate*state*ltis-base
   (state <s> ^superstate nil
              ^ltis <ltis>
              ^tasks.task <task>)
-->
   (<ltis> ^lti <lti>)
   (<lti> ^identifier <task>
          ^depth 9999)
}

sp {elaborate*state*ltis-recurse
   (state <s> ^superstate nil
              ^ltis <ltis>)
   (<ltis> ^lti <parent-lti>)
   (<parent-lti> ^identifier <parent-ident>
                 ^depth {<depth> > 0})
   (<parent-ident> ^<attr> {<child> <=> <s>})
-->
   (<parent-lti> ^child <child-lti>)
   (<ltis> ^lti <child-lti>)
   (<child-lti> ^identifier <child>
                ^depth (- <depth> 1))
}

sp {elaborate*state*ltis-status-base*no-identifier-children
   (state <s> ^superstate nil
              ^ltis.lti <lti>)
   (<lti> ^identifier <ident>)
   # there is at least one child
   # and no identifier children
   (<ident> ^<attr>
           -^<ident-attr> {<=> <s>})
-->
   (<lti> ^forgotten no)
}

sp {elaborate*state*ltis-status-base*depth-limit
   (state <s> ^superstate nil
              ^ltis.lti <lti>)
   (<lti> ^identifier <ident>
          ^depth 0)
   # there is at least one child 
   (<ident> ^<attr>)
-->
   (<lti> ^forgotten no)
}

sp {elaborate*state*ltis-status-recurse
   (state <s> ^superstate nil
              ^ltis <ltis>)
   (<ltis> ^lti <parent-lti>)
   # there are identifier children
   (<parent-lti> ^child)
   # and none of them have been forgotten
  -{ (<parent-lti> ^child <child-lti>)
    -(<child-lti> ^forgotten no) }
-->
   (<parent-lti> ^forgotten no)
}

# flags

# FIXME this is a hack to get around a Soar bug

sp {elaborate*state*create-episode-flag-abstraction
   (state <s> ^superstate nil
              ^operator.name <name>
              ^epmem.present-id {> <epmem-id>}
              ^flags.episode <flags>)
   (<flags> ^<flag> {<epmem-id> <=> 0}
           -^<flag> {<> <epmem-id> <=> 0})
-->
   (<flags> ^<flag> yes)
}

sp {elaborate*state*remove-episode-flag-abstraction
   (state <s> ^superstate nil
              ^operator.name <name>
              ^epmem.present-id {< <epmem-id>}
              ^flags.episode <flags>)
   (<flags> ^<flag> {<epmem-id> <=> 0}
            ^<flag> yes)
-->
   (<flags> ^<flag> yes -)
}

# operators

sp {elaborate*operator*retrieve-operators
   (state <s> ^operator <o> +)
   (<o> ^type retrieve)
-->
   (<o> ^actions.estop.estop <estop>)
}

# navigation

sp {elaborate*state*current-area
   (state <s> ^io.input-link.area-description.id <id>
              ^areas.area <area>)
   (<area> ^id <id>
           ^stored yes)
-->
   (<s> ^current-area <area>)
}

sp {elaborate*state*waypoint
   (state <s> ^name <name>
              ^io.input-link.waypoints.waypoint <waypoint>
              ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
   (<waypoint> ^id <name>
               ^x <x>
               ^y <y>)
-->
   (<destination> ^waypoint <waypoint>)
}

sp {elaborate*state*arrived
   (state <s> ^name <name>
              ^parameters.distance-tolerance <distance-tol>
              ^destination.waypoint.distance {<= <distance-tol>})
-->
   (<s> ^arrived yes)
}

# PREFERENCES

sp {elaborate*operator*initialization
   (state <s> ^operator <o> +)
   (<o> ^name << initialize-tasks report-metrics >>)
-->
   (<o> ^type initialization)
}

sp {elaborate*operator*metrics
   (state <s> ^operator <o> +)
   (<o> ^name << count-circuit >>)
-->
   (<o> ^type metrics)
}

sp {elaborate*operator*flags
   (state <s> ^operator <o> +)
   (<o> ^name << remove-area-flags remove-episode-flags >>)
-->
   (<o> ^type flags)
}

sp {elaborate*operator*record
   (state <s> ^operator <o> +)
   (<o> ^name << record-area-wm mark-object-picked-up mark-task-completed >>)
-->
   (<o> ^type record)
}

sp {elaborate*operator*retrieve
   (state <s> ^operator <o> +)
   (<o> ^name << area-trigger timing-trigger >>)
-->
   (<o> ^type retrieve)
}

sp {elaborate*operator*task
   (state <s> ^operator <o> +)
   (<o> ^name << perform-pick-up-task perform-put-down-task >>)
-->
   (<o> ^type task)
}

sp {elaborate*operator*movement
   (state <s> ^operator <o> +)
   (<o> ^name << patrol go-to-adjacent-area go-to-coord >>)
-->
   (<o> ^type movement)
}

sp {delivery*compare*operator-types
   (state <s> ^operator <o1> +
              ^operator <o2> +
              ^constants.operator-preferences <preferences>)
   (<o1> ^type <o1-type>)
   (<o2> ^type <o2-type>)
   (<preferences> ^<o1-type> <rank>
                  ^<o2-type> {> <rank>})
-->
   (<s> ^operator <o1> > <o2>)
}

sp {delivery*compare*pick-up*put-down
   (state <s> ^operator <o1> +
              ^operator <o2> +)
   (<o1> ^name perform-put-down-task)
   (<o2> ^name perform-pick-up-task)
-->
   (<s> ^operator <o1> > <o2>)
}

sp {delivery*compare*perform-pick-up-task*distance
   (state <s> ^operator <o1> +
              ^operator <o2> +)
   (<o1> ^name perform-pick-up-task
         ^object.distance <d1>)
   (<o2> ^name perform-pick-up-task
         ^object.distance {> <d1>})
-->
   (<s> ^operator <o1> > <o2>)
}

sp {delivery*compare*flag-operators
   (state <s> ^operator <o1> +
              ^operator <o2> +)
   (<o1> ^type flags)
   (<o2> ^type flags)
-->
   (<s> ^operator <o1> = <o2>)
}

sp {delivery*compare*retrieve*rehearse
   (state <s> ^operator <o1> +
              ^operator <o2> +)
   (<o1> ^name recursive-retrieve)
   (<o2> ^name recursive-rehearse)
-->
   (<s> ^operator <o1> = <o2>)
}

sp {delivery*compare*task-operators
   (state <s> ^operator <o1> +
              ^operator <o2> +)
   (<o1> ^name {<name> << perform-pick-up-task mark-object-picked-up perform-put-down-task mark-task-completed >>})
   (<o2> ^name <name>)
-->
   (<s> ^operator <o1> = <o2>)
}

# OPERATORS

# initialize-tasks

sp {delivery*propose*initialize-tasks
   (state <s> ^name delivery
              ^flags.manual.tasks-initialized no)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-tasks)
}

sp {initialize-tasks*propose*retrieve-tasks
   (state <s> ^name initialize-tasks
              ^smem <smem>)
   (<smem> ^command <scmd>
          -^result.failure)
-->
   (<s> ^operator <o> +)
   (<o> ^name retrieve-tasks)
}

sp {initialize-tasks*apply*retrieve-tasks*first-query
   (state <s> ^name initialize-tasks
              ^operator.name retrieve-tasks
              ^smem.command <scmd>)
-->
   (<scmd> ^query.type task)
}

sp {initialize-tasks*apply*retrieve-tasks*next-query
   (state <s> ^name initialize-tasks
              ^operator.name retrieve-tasks
              ^smem <smem>
              ^tasks <tasks>
              ^quiescence t)
   (<smem> ^command <scmd>
           ^result <sres>)
   (<sres> ^success
           ^retrieved <task>)
-->
   (<tasks> ^task <task>)
   (<scmd> ^prohibit <task>)
}

sp {initialize-tasks*propose*recursive-retrieve
   (state <s> ^name initialize-tasks
              ^ltis.lti <task-lti>
              ^tasks.task <task>
              ^smem.result.failure)
   (<task-lti> ^identifier <task>
              -^forgotten no)
-->
   (<s> ^operator <o> + =)
   (<o> ^name recursive-retrieve
        ^lti <task>)
}

sp {initialize-tasks*apply*recursive-retrieve*remove-count-flag
   (state <s> ^name initialize-tasks
              ^operator <o>
              ^flags.manual <flags>
              ^metrics <metrics>)
   (<o> ^name recursive-retrieve
        ^lti <task>)
   (<flags> ^num-initial-retrievals-updated {<flag> <> <task>})
-->
   (<flags> ^num-initial-retrievals-updated <flag> -)
}

sp {initialize-tasks*apply*recursive-retrieve*count
   (state <s> ^name initialize-tasks
              ^operator <o>
              ^flags.manual <flags>
              ^metrics <metrics>)
   (<o> ^name recursive-retrieve
        ^lti <task>)
  -(<flags> ^num-initial-retrievals-updated)
   (<metrics> ^num-initial-retrievals <n>)
-->
   (<metrics> ^num-initial-retrievals <n> -
              ^num-initial-retrievals (+ <n> 1))
   (<flags> ^num-initial-retrievals-updated <task>)
}

sp {initialize-tasks*propose*done
   (state <s> ^name initialize-tasks
              ^ltis <ltis>
              ^tasks <tasks>
              ^smem.result.failure)
   -{ (<tasks> ^task <task>)
      (<ltis> ^lti <task-lti>)
      (<task-lti> ^identifier <task>
                 -^forgotten no) }
-->
   (<s> ^operator <o> +)
   (<o> ^name done)
}

sp {initialize-tasks*apply*done
   (state <s> ^name initialize-tasks
              ^operator.name done
              ^flags.manual <flags>
              ^quiescence t)
   (<flags> ^tasks-initialized no)
-->
   (<flags> ^tasks-initialized no -)
}

# triggers

# FIXME this is a hack
sp {delivery*apply*patrol*remove-rehearsed-flags
   (state <s> ^name delivery
              ^operator.name patrol
              ^flags.manual <flags>)
   (<flags> ^lti-rehearsed <lti>)
-->
   (<flags> ^lti-rehearsed <lti> -)
}

# area-trigger

sp {delivery*propose*area-trigger*doors
   (state <s> ^name delivery
              ^parameters <params>
              ^current-area <area>
             -^flags.area.area-trigger <area-id>)
   (<area> ^id <area-id>
           ^type door)
   (<params> ^tasks-held-in smem
             ^method-ecological-doors true)
-->
   (<s> ^operator <o> +)
   (<o> ^name area-trigger)
}

sp {delivery*propose*area-trigger*entry
   (state <s> ^name delivery
              ^parameters <params>
              ^current-area <area>
             -^flags.area.area-trigger <area-id>)
   (<area> ^id <area-id>
           ^type room)
   (<params> ^tasks-held-in smem
             ^method-ecological-entry true)
-->
   (<s> ^operator <o> +)
   (<o> ^name area-trigger)
}

sp {area-trigger*propose*recursive-rehearse
   (state <s> ^name area-trigger
              ^parameters.method-ecological-rehearsal true
             -^flags.manual.lti-rehearsed <task>
              ^ltis.lti <task-lti>
              ^tasks.task <task>)
   (<task-lti> ^identifier <task>
               ^forgotten no)
-->
   (<s> ^operator <o> + =)
   (<o> ^name recursive-rehearse
        ^lti <task>)
}

sp {area-trigger*propose*recursive-retrieve
   (state <s> ^name area-trigger
              ^parameters.method-ecological-retrieval true
              ^ltis.lti <task-lti>
              ^tasks.task <task>)
   (<task-lti> ^identifier <task>
              -^forgotten no)
-->
   (<s> ^operator <o> + =)
   (<o> ^name recursive-retrieve
        ^lti <task>)
}

sp {area-trigger*propose*done
   (state <s> ^name area-trigger)
-->
   (<s> ^operator <o> + <)
   (<o> ^name done)
}

sp {area-trigger*apply*done
   (state <s> ^name area-trigger
              ^operator.name done
              ^io.input-link.area-description.id <area-id>
              ^flags.area <flags>
              ^quiescence t)
-->
   (<flags> ^area-trigger <area-id>)
}

# timing-trigger

sp {delivery*propose*timing-trigger
   (state <s> ^name delivery
              ^parameters <params>
              ^flags.episode.timing-trigger yes)
   (<params> ^tasks-held-in smem
             ^method-ecological-timing true)
-->
   (<s> ^operator <o>)
   (<o> ^name timing-trigger)
}

sp {timing-trigger*propose*recursive-rehearse
   (state <s> ^name timing-trigger
              ^parameters.method-ecological-rehearsal true
             -^flags.manual.lti-rehearsed <task>
              ^ltis.lti <task-lti>
              ^tasks.task <task>)
   (<task-lti> ^identifier <task>
               ^forgotten no)
-->
   (<s> ^operator <o> + =)
   (<o> ^name recursive-rehearse
        ^lti <task>)
}

sp {timing-trigger*propose*recursive-retrieve
   (state <s> ^name timing-trigger
              ^parameters.method-ecological-retrieval true
              ^ltis.lti <task-lti>
              ^tasks.task <task>)
   (<task-lti> ^identifier <task>
              -^forgotten no)
-->
   (<s> ^operator <o> + =)
   (<o> ^name recursive-retrieve
        ^lti <task>)
}

sp {timing-trigger*propose*done
   (state <s> ^name timing-trigger)
-->
   (<s> ^operator <o> + <)
   (<o> ^name done)
}

sp {timing-trigger*apply*done
   (state <s> ^name timing-trigger
              ^operator.name done
              ^parameters.method-ecological-timing-interval <interval>
              ^epmem.present-id <present-id>
              ^flags.episode <flags>
              ^quiescence t)
-->
   (<flags> ^timing-trigger (+ <present-id> <interval>))
}

# recursive-retrieve

sp {recursive-retrieve*elaborate*deeper
   (state <s> ^name recursive-retrieve
              ^to-be-retrieved <to-be-retrieved>
              ^depth <depth>)
   (<to-be-retrieved> ^{<attr> <=> 0}
                     -^<depth>)
-->
   (<s> ^we-need-to-go-deeper (+ <attr> 1))
}

sp {recursive-retrieve*propose*initialize
   (state <s> ^name recursive-retrieve
             -^to-be-retrieved
             -^retrieved
              ^quiescence t)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize)
}

sp {recursive-retrieve*apply*initialize*default-depth
   (state <s> ^name recursive-retrieve
              ^operator.name initialize
             -^superstate.operator.depth)
-->
   (<s> ^depth 9999)
}

sp {recursive-retrieve*apply*initialize*copy-depth
   (state <s> ^name recursive-retrieve
              ^operator.name initialize
              ^superstate.operator.depth <depth>)
-->
   (<s> ^depth <depth>)
}

sp {recursive-retrieve*apply*initialize*copy-path
   (state <s> ^name recursive-retrieve
              ^operator.name initialize
              ^superstate.operator <so>)
   (<so> ^lti <lti>
         ^path <path>)
-->
   (<s> ^mapping.node <node>)
   (<node> ^path <path>
           ^retrieved <lti>)
}

sp {recursive-retrieve*apply*initialize*create-sets
   (state <s> ^name recursive-retrieve
              ^operator.name initialize
              ^superstate.operator.lti <lti>
              ^depth <depth>)
-->
   (<s> ^to-be-retrieved.<depth> <lti>
        ^retrieved <retrieved>)
}

sp {recursive-retrieve*propose*retrieve
   (state <s> ^name recursive-retrieve
              ^depth {<depth> > 0}
              ^to-be-retrieved.<depth> <lti>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name retrieve
        ^lti <lti>)
}

sp {recursive-retrieve*apply*retrieve*retrieve
   (state <s> ^name recursive-retrieve
              ^operator <o>
              ^smem.command <scmd>
             -^retrieved.lti <lti>)
   (<o> ^name retrieve
        ^lti <lti>)
-->
   (<scmd> ^retrieve <lti>)
}

sp {recursive-retrieve*apply*retrieve*copy-children*no-path
   (state <s> ^name recursive-retrieve
              ^operator <o>
              ^smem.result.retrieved <lti>
              ^depth <depth>
              ^to-be-retrieved <to-be-retrieved>
             -^retrieved.lti <val>
             -^mapping)
   (<o> ^name retrieve
        ^lti <lti>)
   (<lti> ^<attr> {<val> <=> <s>})
-->
   (<to-be-retrieved> ^(- <depth> 1) <val>)
}

sp {recursive-retrieve*apply*retrieve*copy-children*path
   (state <s> ^name recursive-retrieve
              ^operator <o>
              ^smem.result.retrieved <lti>
              ^depth <depth>
              ^to-be-retrieved <to-be-retrieved>
              ^retrieved <retrieved>
              ^mapping <mapping>)
   (<o> ^name retrieve
        ^lti <lti>)
   (<lti> ^<attr> {<val> <=> <s>})
   (<retrieved> -^lti <val>)
   (<mapping> ^node <node>)
   (<node> ^path.<attr> <ident>
           ^retrieved <lti>)
-->
   (<to-be-retrieved> ^(- <depth> 1) <val>)
   (<mapping> ^node <new-node>)
   (<new-node> ^path <ident>
               ^retrieved <val>)
}

sp {recursive-retrieve*apply*retrieve*remove-command
   (state <s> ^name recursive-retrieve
              ^operator <o>
              ^smem <smem>
              ^depth <depth>
              ^to-be-retrieved <to-be-retrieved>
              ^retrieved <retrieved>)
   (<o> ^name retrieve
        ^lti <lti>)
   (<smem> ^command <scmd>
           ^result.<< success failure bad-cmd >>)
   (<scmd> ^retrieve <lti>)
   (<to-be-retrieved> ^<depth> <lti>)
-->
   (<scmd> ^retrieve <lti> -)
   (<to-be-retrieved> ^<depth> <lti> -)
   (<retrieved> ^lti <lti>)
}

sp {recursive-retrieve*propose*go-deeper
   (state <s> ^name recursive-retrieve
              ^retrieved
              ^we-need-to-go-deeper <depth>
              ^depth <depth>)
-->
   (<s> ^operator <o> +)
   (<o> ^name go-deeper)
}

sp {recursive-retrieve*apply*go-deeper
   (state <s> ^name recursive-retrieve
              ^operator.name go-deeper
              ^depth <depth>)
-->
   (<s> ^depth <depth> -
        ^depth (- <depth> 1))
}

# recursive-rehearse

sp {recursive-rehearse*propose*initialize
   (state <s> ^name recursive-rehearse
             -^rehearsals-remaining
             -^rehearsed)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize
        ^actions.estop.estop <stop>)
}

sp {recurisve-rehearse*apply*initialize
   (state <s> ^name recursive-rehearse
              ^parameters.method-ecological-rehearsal-amount <amount>
              ^operator.name initialize
              ^superstate.operator.lti <lti>)
-->
   (<s> ^rehearsals-remaining <amount>
        ^rehearsed.lti <lti>)
}

sp {recurisve-rehearse*propose*recurse
   (state <s> ^name recursive-rehearse
              ^rehearsed <rehearsed>)
   (<rehearsed> ^lti <lti>
               -^lti <val>)
   (<lti> ^<attr> {<val> <=> <s>})
-->
   (<s> ^operator <o> + =)
   (<o> ^name recurse
        ^lti <val>)
}

sp {recursive-rehearse*apply*recurse
   (state <s> ^name recursive-rehearse
              ^operator <o>
              ^rehearsed <rehearsed>)
   (<o> ^name recurse
        ^lti <val>)
-->
   (<rehearsed> ^lti <val>)
}
 
sp {recursive-rehearse*propose*complete-rehearsal
   (state <s> ^name recursive-rehearse)
-->
   (<s> ^operator <o> + <)
   (<o> ^name complete-rehearsal)
}

sp {recursive-rehearse*apply*complete-rehearsal*again
   (state <s> ^name recursive-rehearse
              ^operator.name complete-rehearsal
              ^superstate.operator.lti <lti>
              ^rehearsals-remaining {<n> > 0}
              ^rehearsed <rehearsed>)
-->
   (<s> ^rehearsals-remaining <n> -
        ^rehearsals-remaining (- <n> 1)
        ^rehearsed <rehearsed> -
        ^rehearsed.lti <lti>)
}

sp {recursive-rehearse*apply*complete-rehearsal*done
   (state <s> ^name recursive-rehearse
              ^operator.name complete-rehearsal
              ^superstate.operator.lti <lti>
              ^rehearsals-remaining 0
              ^flags.manual <flags>
              ^quiescence t)
-->
   (<flags> ^lti-rehearsed <lti>)
}

# perform-pick-up-task

sp {delivery*propose*perform-pick-up-task
   (state <s> ^name delivery
              ^io.input-link.objects.object <obj>
              ^ltis.lti <obj-lti>
              ^tasks.task <task>)
   (<task> ^object <desc>)
   # check that the task does not already have an object
  -(<desc> ^id)
   # check that the object has not been forgotten
   (<obj-lti> ^identifier <desc>
              ^forgotten no)
   # check that the object is right for the task
  -{ (<desc> ^<attr> <val>)
    -(<obj> ^<attr> <val>) }
-->
   (<s> ^operator <o> +)
   (<o> ^name perform-pick-up-task
        ^task <task>
        ^object <obj>)
}

sp {perform-pick-up-task*propose*pick-up-object
   (state <s> ^name perform-pick-up-task
              ^superstate.operator <so>)
   (<so> ^task <task>
         ^object <obj>)
-->
   (<s> ^operator <o> +)
   (<o> ^name pick-up-object
        ^object <obj>)
}

# mark-object-picked-up

sp {delivery*propose*mark-object-picked-up
   (state <s> ^name delivery
              ^ltis.lti <obj-lti>
              ^tasks <tasks>
              ^io.input-link.self.carry.object <obj>)
   (<obj> ^id <id>)
   (<tasks> ^task <task>)
   (<task> ^object <desc>)
   # check that the task does not already have an object
  -(<desc> ^id)
   # check that the object does not already have a task
  -(<tasks> ^task.object.id <id>)
   # check that the object has not been forgotten
   (<obj-lti> ^identifier <desc>
              ^forgotten no)
   # check that the object is right for the task
  -{ (<desc> ^{<attr> <> forgotten} <val>)
    -(<obj> ^<attr> <val>) }
-->
   (<s> ^operator <o> +)
   (<o> ^name mark-object-picked-up
        ^task <task>
        ^object <obj>)
}

sp {delivery*apply*mark-object-picked-up
   (state <s> ^name delivery
              ^operator <o>)
   (<o> ^name mark-object-picked-up
        ^task.object <desc>
        ^object.id <id>)
-->
   (<desc> ^id <id>)
}

sp {delivery*apply*mark-object-picked-up*store-smem
   (state <s> ^name delivery
              ^operator <o>
              ^parameters.tasks-held-in smem
              ^smem.command <scmd>)
   (<o> ^name mark-object-picked-up
        ^task.object <desc>)
-->
   (<scmd> ^store <desc>)
}

# perform-put-down-task

sp {delivery*propose*perform-put-down-task
   (state <s> ^name delivery
              ^io.input-link.self.carry.object <obj>
              ^current-area <area>
              ^ltis.lti <dest-lti>
              ^tasks.task <task>)
   (<task> ^object.id <id>
           ^destination <dest>)
   (<obj> ^id <id>)
   # check that the destination has not been forgotten
   (<dest-lti> ^identifier <dest>
              ^forgotten no)
   # check that we are in the right location
  -{ (<dest> ^{<attr> <> forgotten} <val>)
    -(<area> ^<attr> <val>) }
-->
   (<s> ^operator <o> +)
   (<o> ^name perform-put-down-task
        ^task <task>
        ^object <obj>)
}

sp {perform-put-down-task*propose*put-down-object
   (state <s> ^name perform-put-down-task
              ^superstate.operator.object <obj>)
-->
   (<s> ^operator <o> +)
   (<o> ^name put-down-object
        ^object <obj>)
}

# mark-task-completed

sp {delivery*propose*mark-task-completed
   (state <s> ^name delivery
              ^tasks.task <task>
              ^io.input-link.objects.object <obj>
              ^current-area <area>
              ^ltis.lti <task-lti>)
   (<task> ^object <desc>
           ^destination <dest>)
   # check that the task was completed
   (<desc> ^id)
   # check that the task has not been forgotten
   (<task-lti> ^identifier <task>
               ^forgotten no)
   # check that the object is right for the task
  -{ (<desc> ^<attr> <val>)
    -(<obj> ^<attr> <val>) }
   # check that we are in the right location
  -{ (<dest> ^<attr> <val>)
    -(<area> ^<attr> <val>) }
-->
   (<s> ^operator <o> +)
   (<o> ^name mark-task-completed
        ^task <task>)
}

sp {delivery*apply*mark-task-completed
   (state <s> ^name delivery
              ^operator <o>
              ^tasks <tasks>
              ^metrics <metrics>)
   (<o> ^name mark-task-completed
        ^task <task>)
   (<tasks> ^task <task>)
   (<metrics> ^num-tasks-completed <n>)
-->
   (<tasks> ^task <task> -)
   (<metrics> ^num-tasks-completed <n> -
              ^num-tasks-completed (+ <n> 1))
}

# record-area-wm

sp {delivery*propose*record-area-wm
   (state <s> ^name delivery
             -^current-area
              ^parameters.areas-held-in wm)
-->
   (<s> ^operator <o> +)
   (<o> ^name record-area-wm)
}

sp {record-area-wm*propose*create-neighbor-area
   (state <s> ^name record-area-wm
              ^io.input-link.area-description <description>
             -^areas.area.id <to>
              ^quiescence t)
   (<description> ^id <id>
                  ^gateway.to {<to> <> <id>})
-->
   (<s> ^operator <o> + =)
   (<o> ^name create-neighbor-area
        ^area-id <to>)
}

sp {record-area-wm*apply*create-neighbor-area
   (state <s> ^name record-area-wm
              ^operator <o>
              ^areas <areas>)
   (<o> ^name create-neighbor-area
        ^area-id <id>)
-->
   (<areas> ^area.id <id>)
}

sp {record-area-wm*propose*copy-curent-area
   (state <s> ^name record-area-wm
              ^io.input-link.area-description <description>
              ^areas <areas>
              ^quiescence t)
   (<description> ^id <id>)
  -{ (<description> ^gateway.to {<to> <> <id>})
    -(<areas> ^area.id <to>) }
-->
   (<s> ^operator <o> +)
   (<o> ^name copy-current-area)
}

sp {record-area-wm*apply*copy-current-area*create-area
   (state <s> ^name record-area-wm
              ^operator.name copy-current-area
              ^io.input-link.area-description.id <id>
              ^areas <areas>)
  -(<areas> ^area.id <id>)
-->
   (<areas> ^area <area>)
   (<area> ^id <id>)
}

sp {record-area-wm*apply*copy-current-area*link-area
   (state <s> ^name record-area-wm
              ^operator.name copy-current-area
              ^areas.area <area>
              ^io.input-link.area-description <description>)
   (<area> ^id <id>)
   (<description> ^id <id>
                  ^type <type>
                  ^wall <north-wall>
                  ^wall <south-wall>
                  ^wall <east-wall>
                  ^wall <west-wall>)
   (<north-wall> ^direction north
                 ^y <north-y>)
   (<south-wall> ^direction south
                 ^y <south-y>)
   (<east-wall> ^direction east
                ^x <east-x>)
   (<west-wall> ^direction west
                ^x <west-x>)
-->
   (<s> ^area <area>)
   (<area> ^type <type>
           ^class area
           ^center-x (/ (+ <east-x> <west-x>) 2)
           ^center-y (/ (+ <north-y> <south-y>) 2)
           ^width (- <east-x> <west-x>)
           ^height (- <north-y> <south-y>))
}

sp {record-area-wm*apply*copy-current-area*gateway
   (state <s> ^name record-area-wm
              ^operator.name copy-current-area
              ^io.input-link.area-description.gateway <cgateway>
              ^areas.area <to-area>
              ^area <area>
              ^constants.direction-opposites.<direction> <opposite>)
   (<area> ^id <id>)
   (<to-area> ^id <to>)
   (<cgateway> ^to {<to> <> <id>}
               ^direction <direction>
               ^x <x>
               ^y <y>)
   # there is not already a gateway in that location
   -{ (<area> ^<direction> <exist>)
      (<exist> ^x <x>
               ^y <y>) }
-->
   (<area> ^<direction> <gateway>)
   (<to-area> ^<opposite> <gateway>)
   (<gateway> ^class coord
              ^type gateway
              ^to <area>
              ^to <to-area>
              ^x <x>
              ^y <y>)
}

sp {record-area-wm*apply*copy-current-area*done
   (state <s> ^name record-area-wm
              ^operator.name copy-current-area
              ^io.input-link.area-description <description>
              ^area <area>)
   (<area> ^id <id>)
  -{ (<description> ^gateway <gateway>)
     (<gateway> ^to {<to> <> <id>}
                ^direction <direction>)
    -(<area> ^<direction>.to.id <to>) }
-->
   (<area> ^stored yes)
}

# pick-up-object

sp {pick-up-object*elaborate*destination
   (state <s> ^name pick-up-object
              ^superstate.operator.object <obj>)
   (<obj> ^x <x>
          ^y <y>)
-->
   (<s> ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
}

sp {pick-up-object*propose*go-to-object
   (state <s> ^name pick-up-object
              ^destination.waypoint <waypoint>
             -^arrived)
   (<waypoint> ^x <x>
               ^y <y>)
-->
   (<s> ^operator <o> +)
   (<o> ^name go-to-coord
        ^x <x>
        ^y <y>)
}

sp {pick-up-object*propose*get-object
   (state <s> ^name pick-up-object
              ^superstate.operator.object.id <id>
              ^arrived)
-->
   (<s> ^operator <o> +)
   (<o> ^name get-object
        ^actions <actions>)
   (<actions> ^estop.estop <estop>
              ^get-object.id <id>)
}

# put-down-object

sp {put-down-object*elaborate*destination
   (state <s> ^name put-down-object
              ^parameters.distance-tolerance <distance-tol>
              ^current-area <area>)
   (<area> ^center-x <x>
           ^center-y <y>
           ^width <width>
           ^height <height>)
-->
   (<s> ^destination <destination>)
   (<destination> ^x (+ (- <x> (/ <width> 2)) <distance-tol>)
                  ^y (+ (- <y> (/ <height> 2)) <distance-tol>))
}

sp {put-down-object*propose*go-to-storage-coord
   (state <s> ^name put-down-object
              ^destination.waypoint <waypoint>
             -^arrived)
   (<waypoint> ^x <x>
               ^y <y>)
-->
   (<s> ^operator <o> +)
   (<o> ^name go-to-coord
        ^x <x>
        ^y <y>)
}

sp {put-down-object*propose*drop-object
   (state <s> ^name put-down-object
              ^superstate.operator.object.id <id>
              ^arrived)
-->
   (<s> ^operator <o> +)
   (<o> ^name drop-object
        ^actions <actions>)
   (<actions> ^estop.estop <estop>
              ^drop-object.id <id>)
}

# patrol

sp {delivery*propose*patrol
   (state <s> ^name delivery)
-->
   (<s> ^operator <o> +)
   (<o> ^name patrol
        ^area <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a10> <a11> <a12>)
   (<a01> ^next <a02>
          ^id 0)
   (<a02> ^next <a03>
          ^id 5)
   (<a03> ^next <a04>
          ^id 10)
   (<a04> ^next <a05>
          ^id 15)
   (<a05> ^next <a06>
          ^id 20)
   (<a06> ^next <a07>
          ^id 25)
   (<a07> ^next <a08>
          ^id 30)
   (<a08> ^next <a09>
          ^id 35)
   (<a09> ^next <a10>
          ^id 40)
   (<a10> ^next <a11>
          ^id 45)
   (<a11> ^next <a12>
          ^id 50)
   (<a12> ^next <a01>
          ^id 55)
} 

sp {patrol*propose*go-to-adjacent-area
   (state <s> ^name patrol
              ^superstate.operator.area <area>
              ^current-area.id <id>)
   (<area> ^id <id>
           ^next <next-area>)
   (<next-area> ^id <next-id>)
-->
   (<s> ^operator <o> +)
   (<o> ^name go-to-adjacent-area
        ^area-id <next-id>)
}

# go-to-adjacent-area

sp {go-to-adjacent-area*elaborate*destination
   # TODO this can cause multiple destinations to be specified
   # if there are two gateways to the same room
   (state <s> ^name go-to-adjacent-area
              ^superstate.operator.area-id <next-id>
              ^current-area.<< north south east west >> <gateway>)
   (<gateway> ^to.id <next-id>
              ^x <x>
              ^y <y>)
-->
   (<s> ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
}

sp {go-to-adjacent-area*propose*go-to-gateway
   (state <s> ^name go-to-adjacent-area
              ^destination.waypoint <waypoint>
             -^arrived)
   (<waypoint> ^x <x>
               ^y <y>)
-->
   (<s> ^operator <o> +)
   (<o> ^name go-to-coord
        ^x <x>
        ^y <y>)
}

sp {go-to-adjacent-area*propose*enter-area
   (state <s> ^name go-to-adjacent-area
              ^superstate.operator.area-id <next-id>
              ^arrived yes
              ^current-area.{<direction> << north south east west >>}.to.id <next-id>
              ^destination.waypoint <waypoint>
              ^constants.gateway-deltas.<direction> <deltas>)
   (<waypoint> ^x <x>
               ^y <y>)
   (<deltas> ^x <delta-x>
             ^y <delta-y>)
-->
   (<s> ^operator <o> +)
   (<o> ^name go-to-coord
        ^x (+ <x> <delta-x>)
        ^y (+ <y> <delta-y>))
}

# go-to-coord

sp {go-to-coord*elaborate*destination
   (state <s> ^name go-to-coord
              ^superstate.operator <so>)
   (<so> ^x <x>
         ^y <y>)
-->
   (<s> ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
}

sp {go-to-coord*elaborate*obstacle
   (state <s> ^name go-to-coord
              ^parameters.collision-distance <collision>
              ^io.input-link.objects.object <object>)
   (<object> ^distance {< <collision>})
-->
   (<s> ^obstacle <object>)
}

sp {go-to-coord*propose*turn-to-waypoint
   (state <s> ^name go-to-coord
              ^parameters.heading-tolerance <heading-tol>
             -^obstacle
              ^destination.waypoint <waypoint>)
   (<waypoint> ^yaw <yaw>
               ^abs-relative-bearing {> <heading-tol>})
-->
   (<s> ^operator <o> +)
   (<o> ^name turn-to-waypoint
        ^actions.set-heading.yaw <yaw>)
}

sp {go-to-coord*propose*drive-to-waypoint
   (state <s> ^name go-to-coord
              ^parameters <params>
             -^obstacle
              ^destination.waypoint <waypoint>)
   (<params> ^distance-tolerance <distance-tol>
             ^linear-velocity <velocity>
             ^heading-tolerance <heading-tol>)
   (<waypoint> ^abs-relative-bearing {<= <heading-tol>}
               ^distance {<remaining> > <distance-tol>})
-->
   (<s> ^operator <o> +)
   (<o> ^name drive-to-waypoint
        ^actions.set-linear-velocity.linear-velocity <velocity>)
}

sp {go-to-coord*propose*avoid-obstacle
   (state <s> ^name go-to-coord
              ^obstacle <object>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name avoid-obstacle
        ^obstacle <object>
        ^actions.estop.estop <estop>)
}

# avoid-obstacle
    
# TODO
# this needs to be modified to handle multiple obstacles simultaneously
# this does not work for obstacles of different sizes

sp {avoid-obstacle*elaborate*destination
   (state <s> ^name avoid-obstacle
              ^superstate.operator.obstacle <obj>)
   (<obj> ^x <x>
          ^y <y>)
-->
   (<s> ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
}

sp {avoid-obstacle*propose*turn-until-clear*turn-left
   (state <s> ^name avoid-obstacle
              ^parameters <params>
              ^io.input-link <il>
              ^destination.waypoint <waypoint>)
   (<params> ^angular-velocity <velocity>
             ^collision-bearing <collision-bearing>
             ^distance-tolerance <distance-tol>)
   (<il> ^lidar.range <lidar>
         ^self.pose.yaw <yaw>)
   (<lidar> ^id 0
            ^distance {<= <distance-tol> })
   (<waypoint> ^abs-relative-bearing {< <collision-bearing>}
               ^relative-bearing {<relative-bearing> <= 0})
-->
   (<s> ^operator <o> + =)
   (<o> ^name turn-until-clear
        ^actions.set-heading.yaw (+ (+ <yaw> <relative-bearing>) <collision-bearing>))
}

sp {avoid-obstacle*propose*turn-until-clear*turn-right
   (state <s> ^name avoid-obstacle
              ^parameters <params>
              ^io.input-link <il>
              ^destination.waypoint <waypoint>)
   (<params> ^angular-velocity <velocity>
             ^collision-bearing <collision-bearing>
             ^distance-tolerance <distance-tol>)
   (<il> ^lidar.range <lidar>
         ^self.pose.yaw <yaw>)
   (<waypoint> ^abs-relative-bearing {< <collision-bearing>}
               ^relative-bearing {<relative-bearing> > 0})
   (<lidar> ^id 0
            ^distance {<= <distance-tol> })
-->
   (<s> ^operator <o> + =)
   (<o> ^name turn-until-clear
        ^actions.set-heading.yaw (- (+ <yaw> <relative-bearing>) <collision-bearing>))
}

sp {avoid-obstacle*propose*move-until-clear
   (state <s> ^name avoid-obstacle
              ^parameters <params>
              ^io.input-link.lidar.range <lidar>)
   (<params> ^distance-tolerance <distance-tol>
             ^linear-velocity <velocity>)
   (<lidar> ^id 0
            ^distance {> <distance-tol> })
-->
   (<s> ^operator <o> +)
   (<o> ^name drive-until-clear
        ^actions.set-linear-velocity.linear-velocity <velocity>)
}

sp {avoid-obstacle*propose*back-up
   (state <s> ^name avoid-obstacle
              ^parameters.linear-velocity <velocity>)
-->
   (<s> ^operator <o> + <)
   (<o> ^name back-up
        ^actions.set-linear-velocity.linear-velocity (- 0 <velocity>))
}

# metrics/num-retrievals

sp {recursive-retrieve*apply*initialize*increment-num-retrievals
   (state <s> ^name recursive-retrieve
              ^operator.name initialize
              ^superstate.operator.lti <task>
              ^tasks.task <task>
              ^metrics <metrics>
              ^flags.manual <flags>)
   (<metrics> ^num-retrievals <n>)
  -(<flags> ^num-retrievals-updated)
-->
   (<metrics> ^num-retrievals <n> -
              ^num-retrievals (+ <n> 1))
   (<flags> ^num-retrievals-updated <task>)
}

sp {recursive-retrieve*apply*initialize*remove-num-retrievals-flag
   (state <s> ^name recursive-retrieve
              ^operator.name initialize
              ^superstate.operator.lti <task>
              ^flags.manual <flags>)
   (<flags> ^num-retrievals-updated {<flag> <> <task>})
-->
   (<flags> ^num-retrievals-updated <flag> -)
}

# metrics/num-circuits

sp {delivery*propose*count-circuit
   (state <s> ^name delivery
              ^io.input-link.area-description.id 25
             -^flags.area.circuit-counted)
-->
   (<s> ^operator <o> +)
   (<o> ^name count-circuit)
}

sp {delivery*apply*count-circuit
   (state <s> ^name delivery
              ^operator.name count-circuit
              ^io.input-link.area-description.id <area-id>
              ^flags.area <flags>
              ^metrics <metrics>)
   (<metrics> ^num-circuits <n>)
-->
   (<metrics> ^num-circuits <n> -
              ^num-circuits (+ <n> 1))
   (<flags> ^circuit-counted <area-id>)
}

# report-metrics

sp {delivery*propose*report-metrics*all-tasks-completed
   (state <s> ^name delivery
             -^tasks.task
              ^metrics.num-retrievals > 0
              ^parameters.experiment-name {<> dummy})
-->
   (<s> ^operator <o> +)
   (<o> ^name report-metrics)
}

sp {delivery*propose*report-metrics*patrol-limit
   (state <s> ^name delivery
              ^parameters <params>
              ^metrics.num-circuits <max>)
   (<params> ^experiment-name {<> dummy}
             ^max-patrol-circuits <max>)
-->
   (<s> ^operator <o> +)
   (<o> ^name report-metrics)
}

sp {apply*report-metrics
   (state <s> ^operator.name report-metrics
              ^metrics <metrics>
              ^parameters <parameters>)
   (<parameters> ^experiment-name <experiment>
                 ^trial-num <trial>
                 ^rand-seed <seed>
                 ^num-blocks <num-blocks>
                 ^num-tasks <num-tasks>
                 ^log-file {<logfile> <> dummy}
                 ^decay-rate <decay>
                 ^linear-velocity <velo>
                 ^max-patrol-circuits <max-circuits>
                 ^method-ecological-doors <doors> 
                 ^method-ecological-entry <entry>
                 ^method-ecological-objects <objects>
                 ^method-ecological-timing <timing>
                 ^method-ecological-timing-interval <interval>
                 ^method-ecological-rehearsal <rehearsal>
                 ^method-ecological-rehearsal-amount <amount>
                 ^method-ecological-retrieval <retrieval>)
   (<metrics> ^start-time <start-time>
              ^num-initial-retrievals <num-initial-retrievals>
              ^num-retrievals <num-retrievals>
              ^num-circuits <num-circuits>
              ^num-tasks-completed <num-completed-tasks>)
-->
   (cmd |clog | <logfile>)
   (cmd echo -- |BEGIN OUTPUT|)
   (cmd echo -- |start time: | <start-time>)
   (cmd echo -- |end time: | (timestamp))
   (cmd echo -- |experiment: | <experiment>)
   (cmd echo -- |trial: | <trial>)
   (cmd echo -- |random seed: | <seed>)
   (cmd echo -- |num blocks: | <num-blocks>)
   (cmd echo -- |num tasks: | <num-tasks>)
   (cmd echo -- |max circuits: | <max-circuits>)
   (cmd echo -- |decay rate: | <decay>)
   (cmd echo -- |linear velocity: | <velo>)
   (cmd echo -- |doors ecological method: | <doors>)
   (cmd echo -- |entry ecological method: | <entry>)
   (cmd echo -- |objects ecological method: | <objects>)
   (cmd echo -- |timing ecological method: | <timing>)
   (cmd echo -- |timing ecological method interval: | <interval>)
   (cmd echo -- |rehearsal ecological method: | <rehearsal>)
   (cmd echo -- |rehearsal ecological method amount: | <amount>)
   (cmd echo -- |retrieval ecological method: | <retrieval>)
   (cmd echo -- |num circuits: | <num-circuits>)
   (cmd echo -- |num initial retrievals: | <num-initial-retrievals>)
   (cmd echo -- |num retrievals: | <num-retrievals>)
   (cmd echo -- |num completed tasks: | <num-completed-tasks>)
   (cmd echo -- |BEGIN COMMANDS|)
   (cmd smem --stats)
   (cmd smem --timer)
   (cmd epmem)
   (cmd epmem --stats)
   (cmd epmem --timer)
   (cmd wma)
   (cmd stats)
   (cmd stats -M)
   (cmd echo |END OUTPUT|)
   (cmd |clog -c|)
   (halt)
}

# remove-flags

sp {delivery*propose*remove-area-flags
   (state <s> ^name delivery
              ^io.input-link.area-description.id <area-id>
              ^flags.area <flags>)
   (<flags> ^<flag> {<> <area-id>})
-->
   (<s> ^operator <o> +)
   (<o> ^name remove-area-flags)
}

sp {delivery*apply*remove-area-flags
   (state <s> ^operator.name remove-area-flags
              ^io.input-link.area-description.id <area-id>
              ^flags.area <flags>)
   (<flags> ^<flag> {<val> <> <area-id>})
-->
   (<flags> ^<flag> <val> -)
}

sp {delivery*propose*remove-episode-flags
   (state <s> ^name delivery
              ^flags.episode <flags>)
   (<flags> ^<flag> {<smaller> <=> 0}
            ^<flag> {> <smaller> <=> 0})
-->
   (<s> ^operator <o> +)
   (<o> ^name remove-episode-flags)
}

sp {delivery*apply*remove-episode-flags
   (state <s> ^operator.name remove-episode-flags
              ^flags.episode <flags>)
   (<flags> ^<flag> {<smaller> <=> 0}
            ^<flag> {<larger> > <smaller> <=> 0})
-->
   (<flags> ^<flag> <smaller> -)
}

# waypoints

sp {propose*add-waypoint
   (state <s> ^name <name>
             -^io.input-link.waypoints.waypoint.id <name>
              ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
-->
   (<s> ^operator <o> + >)
   (<o> ^name add-waypoint
        ^actions.add-waypoint <add-waypoint>)
   (<add-waypoint> ^id <name>
                   ^x <x>
                   ^y <y>)
}

sp {propose*remove-waypoint
   (state <s> ^name <name>
              ^io.input-link.waypoints.waypoint <waypoint>
              ^destination <destination>)
   (<destination> ^x <x>
                  ^y <y>)
   (<waypoint> ^id <name>)
  -(<waypoint> ^x <x>
               ^y <y>)
-->
   (<s> ^operator <o> + >)
   (<o> ^name remove-waypoint
        ^actions.remove-waypoint.id <name>)
}

# output commands

sp {apply*operator*create-output
   (state <s> ^operator.actions.<attr> <val>
              ^io.output-link <ol>
              ^quiescence t)
-->
   (<ol> ^<attr> <val>)
}

sp {apply*operator*remove-output
   (state <s> ^superstate nil
              ^operator <o>
              ^io.output-link <ol>)
   (<ol> ^<attr> <val>)
   (<val> ^status << interrupted complete error >>)
-->
   (<ol> ^<attr> <val> -)
}

# smem stores

sp {apply*operator*remove-store-command
   :o-support
   (state <s> ^smem <smem>)
   (<smem> ^command <scmd>
           ^result.success <store>)
   (<scmd> ^store <store>)
-->
   (<scmd> ^store <store> -)
}

# wait

sp {propose*wait
   (state <s> ^attribute state
              ^choices none
             -^operator.name wait)
-->
   (<s> ^operator <o> +)
   (<o> ^name wait)
}

\section{The SORTS Visual System}

During an elaborate RTS game, the amount of information available to the player is massive. Even with a "fog of war" limiting what areas of the map the player has access to, a player can see hundreds (or even thousands) of units, each with its own position, motion, and other attributes. While in general, giving a player more information is a benefit, having no filter on the raw game state would be a hinderance to the player, not only computationally (transferring too many bytes from the middleware to Soar), but also cognitively. Unfiltered information makes abstraction difficult, and makes distinctions involving locality less apparent (for example, seeing that an enemy is within ones base).

A human RTS player has many levels of filtering available, both in the game's GUI interface and the specialized processing of the human visual system. For example, to stage an attack, a player can restrict the GUI's view window to his own base, and see that a group of marines is available. Perhaps one marine needs to be sent as a scout, in that case, the human player can choose to see the marine group as a set of individuals, and choose the best individual to send out. Once the individual has reached its target, the player can again observe (and select) the remaining marines as a group, and send them to attack with one mouse click. This is in contrast to the more complicated unfiltered case, where the player would see the entire map at once, search for marines, reason about whether each individual is close to the base, and perform a separate action to send each to attack.

\subsection{Object Grouping}

The ability of humans to see sets of similar objects as wholes has been well-studied by psychologists. This phenomenon is called Gestalt grouping (\cite{hill99modeling}, \cite{Kubovy1998}). The principles of Gestalt grouping specify that if objects are close together, have common features such as shape, color, and motion, they can be seen as a group. There is some top-down control of this, the observer can choose to see the individuals or the group. We use this concept to give our system the ability to percieve groups of units that are relevant to playing the game. Specifically, we group units by type, owner, and proximity. By default, groups are formed based on all three- groups are formed of units of the same type and owner which are close together. The agent can change the meaning of "close together" by issuing a grouping-radius command to the middleware. Groups are formed by the rule that if a unit of a given class is within the grouping radius of another of the same class, they are in the same group. Note that adjusting this grouping radius to 0 will result in only one unit per group.

The agent also is able to choose to group the objects by owner alone. This is accomplished by issuing an enable-owner-grouping command to the middleware. Grouping by owner allows the agent to view the game at a higher level of abstraction, to see, for example, the locations of the different players' bases and forces.

Actions in the game, such as $attack$ or $move$, are assigned to groups. In the middleware, the execution of each unit is controlled by a separate FSM, so the behavior of the group will not necessarily be uniform. Members of a group can take different paths to a target, and so may become spatially separate as the action is executed. To simplify reasoning in the agent, all groups are automatically set to be "sticky" once an action is assigned to them. In a sticky group, no new members can join, and members are only removed if they are killed. This way, the agent can easily see the results of an action (by checking the status of the group at a later time), and does not get confused when objects executing different actions come close together- all members of a group must be executing the same command. This is analgous to assigning a group a "hotkey" in the user interface of a commercial RTS- the player can quickly get information on a previously-selected group, regardless of what happened to the group since it was last selected. The group will remain sticky until a $free$ command is issued to it, even if all units finish executing the action.


\subsection{Visual Attention}

Even with grouping of objects, the amount of information visible can still be too much. Events in a game such as this tend to occur in restricted spatial areas, and it is worthwhile to present lots of information about a small area, while presenting less information about the rest of the world. 

The human visual system provides some inspiration for a way to do this. A "zoom lens" metaphor is often used to describe human visual attention (\cite{zoomlens}, \cite{hill99modeling}, \cite{anderson})-- some small area of the field of vision is attended to, providing detailed information, while surrounding areas present less and less information. But this area of attention can shift in a guided manner- a human can easily jump to a red object in a sea of black, for example. Feature Integration Theory (FIT) is a common model for describing this kind of "pop-out" effect (\cite{fit}, \cite{anderson}). The basic concept of FIT is that objects not attended to are not present as objects in the visual system, only as features of objects (like colors or shapes). In the red object in a field of black example, the information that something red exists (and its general area) is present whenever the object is in the visual field, but no more information about that object is known until attention selects it. Attention can be directly moved to the red object with no search, but if there were many red objects, any particular one must be found by searching all the red objects, focusing attention on each individually.

These concepts are simple to map onto our system. We simply select a certain number of groups\footnote{Selecting a set number of groups, as opposed to a small region or a number of individuals, not only makes good sense for a video game but is supported by psychological studies \cite{Scholl2001}.} (adjustable by issuing $num-objects$ commands) that are close to a certain point on the map, and provide all information on those groups. Then, for all groups not selected, general information is presented in the form of feature maps. A map for a given feature (enemy units, for example) consists of a list of sectors and associated unit counts. There are 9 sectors, dividing the field of view into a grid. The sectors are numbered with the upper-left as sector0 and the lower right as sector8. For each group that has a given feature, the feature count for the sector the group is centered in is incremented by the number of individuals in the group. Groups that are in attention are not shown in the feature maps.

Using the feature maps, the agent can quickly shift its attentional focus. The commands $look-at-feature$ and $move-to-feature$, which take parameters of a feature name and sector number, cause the focus to jump to the center of one of the groups that shows the chosen feature in the chosen sector. This scheme, in addition to supporting very fast searches, also causes the size of the input link to be constantly bounded, preventing any problems caused by huge amounts of data overwhelming the system.

Beyond grouping and the zoom-lens area of attention, it is possible to restrict the input even further. Capability similar to shrinking a GUI window size (or dealing with a computer screen that can only show so much) is also available- completely cutting out some spatial areas from being percieved. Given our constant-bounded input size, this is no longer needed from a standpoint of avoiding too much data, but can serve to restrict the kind of data available. Specifically, since the feature maps have a set number of sectors, restricting the field of vision serves to increase their resolution. A situation where this is useful is the identification of an enemy unit in an unusual place. If the entire map is always in the field of view, a small area of it being attended to at once, the data in the feature maps will be very low resolution. If the enemy is in many places, it is likely at least one enemy unit will be somewhere in each sector. If one of those sectors also contains a region the agent is trying to control, there is no way of quickly knowing if an enemy is inside or outside the region without attending to it. However, if the agent restricts its field of view to the region in question, an enemy present in the feature map must be an invader, and can quickly be taken care of. An agent that tends to restrict its field of view to its own base while doing tasks there will be able to quickly notice any invaders- they will pop out of its feature maps, regardless of whatever task the agent is attending to.

.. explain commands ..

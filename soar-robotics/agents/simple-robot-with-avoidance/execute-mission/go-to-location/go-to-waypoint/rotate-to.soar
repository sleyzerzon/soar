sp {go-to-waypoint*propose*rotate-to
   (state <s> ^name go-to-waypoint
             -^superoperator.move-now true
              ^parameters.rotation-tolerance <rt>
              ^waypoint <w>)
  -(<w> ^abs-relative-bearing <= <rt>) #using negation to prevent rematching as bearing changes
-->
   (<s> ^operator <op> +)
   (<op> ^name rotate-to)
}

# TODO: should test for rotation velocity == 0 to prevent creating a new command every cycle as yaw changes
sp {apply*rotate-to
   (state <s> ^operator <op>
              ^waypoint.yaw <yaw>
              ^io.output-link <ol>
              ^parameters <p>)
   (<p> ^rotation-tolerance <rt>
        ^throttle <thr>)
   (<op> ^name rotate-to)
-->
   (<ol> ^rotate-to <r>)
   (<r> ^yaw <yaw>
        ^throttle <thr>
         ^tolerance <rt>)
   (write (crlf) |Rotating to | <yaw>)
   (exec player-print |Rotating to | <yaw>)
}

# TODO: possibly wait for rotation velocity to be 0 so robot is fully turned, not just within angle
#sp {go-to-waypoint*elaborate*state*desired-yaw
#   (state <s> ^waypoint.yaw <yaw>
#              ^io.output-link <ol>
#              ^parameters <p>)
#   (<p> ^rotation-tolerance <rt>
#        ^throttle <thr>)
#-->
#   (<ol> ^rotate-to <r>)
#   (<r> ^yaw <yaw>
#        ^throttle <thr>
#         ^tolerance <rt>)
#   (write (crlf) |Rotating to | <yaw>)
#   (exec player-print |Rotating to | <yaw>)
#}

# FIXME: put this on the go-to-location structure on the top-state, then don't need :o-support and it will be re-entrant
sp {go-to-waypoint*elaborate*superoperator*move-now
   :o-support
   (state <s> ^name go-to-waypoint
              ^parameters.rotation-tolerance <rt>
              ^waypoint <w>
              ^superoperator <so>)
  -(<w> ^abs-relative-bearing > <rt>)
-->
   (<so> ^move-now true)
   (write (crlf) |Oriented towards dest|)
}
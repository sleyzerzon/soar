# todo:
# Xonly track current location and destination
#   need current location to get "at" so can do choose-waypoint
#   need destination for go-to-location
#   steps:
#     - when choose-waypoint completes, remove starting waypoint and add destination waypoint
#     - do we need to keep track of what the waypoint is (e.g., by giving it a special name or keeping a flag on the state)
#       or is it implied by whether we are "at" it or not?
#       - don't use special names, because the destination becomes the at, and we'd have to add the same wp with a different name
#     - remove rule that puts all waypoints on il
# use waypoints instead of explicit x,y where possible (e.g., in go-to-location mission step)
# move update-progress, give-up-on-move-to to go-to-waypoint subgoal
# merge move-to structure with go-to-waypoint structure
#   give-up-on-move-to may need changes to support a structure that's always there (add a flag to the structure?)
#   rename structure to make it part of state instead of functional?
# rename move-now to orientation-complete?
# update "how the code works" below


# how the code works
#
# 1) The primary operator is execute-mission. The mission structure is a linked list on the top state.
#    Each item in the list has an operator proposed for it and is implemented as a suboperator of
#    execute mission.  As of this writing, the possible suboperators are start (which delays the agent
#    for a specified number of seconds), go-to-location (which specifies a location that must be in the
#    waypoint map), and scout (which reacts to entities).  The current missions are all of the form:
#       start -> go-to-location -> scout -> go-to-location
#    so the agents delay for 0-n seconds, go someplace, watch out for entities, and then return "home".
#    As of this writing, there are separate files for each agent that load this shared code, and then
#    overwrite the mission structure rule so each agent has a different mission.
#
# 2) go-to-location works like this.  The agent must be within the waypoint-tolerance (set by initialize)
#    of a waypoint specified in the waypoint map (a graph structure in elaborations/waypoints).  The 
#    destination must correspond to a waypoint's location.  The agent will propose going to each waypoint 
#    that is adjacent to the current waypoint.  If there is more than one, the selection space with
#    iterative deepening will take over and determine which one to follow.
#
# 3) go-to-waypoint will first execute the rotate-to operator to get pointed in the right direction 
#    (rotate-to is a floating operator that will kick in wherever there is a desired-yaw). Then go-to-waypoint
#    will create a top-state structure called move-to which keeps track of where the source of the movement, 
#    the destination, the last time progress was being made, and how close the agent was at that time. 
#    Then the move-to output command is created, which triggers the nd algorithm which handles the low-level 
#    movement. Once the agent gets within waypoint-tolerance of the destination, go-to-waypoint has 
#    succeeded.  If this is not the final destination specified by go-to-location, then the agent will 
#    start the process over again to determine the next move.
#
# 4) As the agent is moving towards its next waypoint, the update-progress operator will fire whenever 
#    it gets closer than min-progress-distance to the destination.  This operator will update the closest
#    distance and time on the move-to top-state structure.
#
# 5) If the agent doesn't make enough progress within the allotted time (specified by replan-time) then 
#    the agent will execute the give-up-on-move-to operator. This updates the waypoint map by removing 
#    the links between the nodes, sends a message to the other agents to do the same, and then returns 
#    the source of the go-to-waypoint (this is not timed).  When the agent reaches the source, the top-state 
#    move-to structure is removed (which completes the give-up-on-move-to operator).  The agent will
#    then replan from the source location using the updated map.
#
# 6) Messages are broadcast as linked lists.  All agents will get the message, including the one that 
#    sent it. The process-message operator fires for all messages in the top-state, which will blow 
#    away the state stack. Thus, when an agent gives up, it will update its map, send the message, process 
#    the message (it will ignore its own messages) re-create the stack stack and finish the giving up 
#    by executing the move-to command to get back to the source.
#
# 7) The scout operator orients the agent to the yaw specified by the waypoint (north is 0 degrees, 
#    east is 90) and waits for an entity to appear or for the scout time to expire.
#
# 8) Entity tracking is primarily handled on the top-state by the maintain-entity-X family of operators
#    (so most entity processing will blow away the stack).  A permanent record is created for each entity 
#    when it is first seen.  The record contains information like which area the entity is in (the space
#    is partitioned into areas), the last time a message was sent, and the last time the entity was 
#    seen (if no longer visible).  It also contains a data pointer which either points to the input-link 
#    (if the entity is currently visible) or to a persistent structure containing the most recent information 
#    about the entity.  This is designed so the same structure can be used whether the entity is visible 
#    or not (e.g., for hiding).
#
# 9) When the agent sees an entity, it will create these structures on the top-state, and then it will
#    send a message to the other agents if it is unfriendly.  As long as it can still see the entity, 
#    it will continue sending entity update messages in the interval specified by message-update-time.
#
# 10) When the agent gets a message about an entity, it creates/updates the top-state structure as necessary.
#     The process-message operator handles this by triggering the same operators the agent would use
#     if it actually saw the entity (the maintain-entity-X family of operators).
#
# 11) When the agent loses sight of the entity, it sends a final update message and creates a persistent
#     copy of the last known information about the entity.
#
# 12) Some waypoints have "hide" waypoints associated with certain areas.  If the agent's current information 
#     about an unfriendly entity puts it in an area specified by one of the hiding waypoints attached
#     to the waypoint it is currently at (and it is scouting), then the agent will go to the hiding 
#     location via the hide operator.  This involves rotating to face it, moving to it, and then rotating
#     to the yaw associated with that waypoint.  When the agent is hiding, it will put a flag on the
#     top state to prevent the desired-yaw of the scout operator from interfering with the rotation to
#     face the hiding spot.
#
# 13) If the agent gets information that the entity is in an area associated with a different hiding 
#     spot it will move to the new hiding spot.
#
# 14) If the agent gets infromation that the entity is in an area not associated with its hiding spots,
#     then it will return to the original location via the unhide operator (which also removes the hide
#     flag from the top state).


# things I don't like about the code

# Life would be easier if messages could be sent as structures instead of linked-lists.  Linked-lists
#  make sense for communication with humans, but not with other agents.

# I have to put structures on the top-state for the GDS, which is fine, but then code associated with 
#  those structures has to go in a file associated with the top-state (or else Visual Soar's datamap 
#  complains).  This forces code that belongs together to be split across different locations, which 
#  can make it hard to follow.
# Note: this is really an issue with Visual Soar, not Soar
# Example: elaborations/give-up-on-move-to has rules that are only relevant to
#  execute-mission/go-to-location/give-up-on-move-to
# Example: elaborations/process-unfriendly-entity has rules that are only relevant to
#  execute-mission/scout/process-unfriendly-entity
# Unworkable solution: It might seem that a good approach is to create a link to the top-state structure 
#  in the subgoal, and then elaborate it there. The problem with this approach is that it generates 
#  results which will almost certainly be o-supported instead of i-supported (which is what we want). 
#  The only way to avoid this is to elaborate the structure onto every substate (thus avoiding testing 
#  anything to do with operators, like the state name), but then this creates clutter for unrelated 
#  states.  It's also delicate in the sense that it can easily be broken if someone modifies it without 
#  understanding what's going on.

# Similar to the above, messages are processed on the top-state, even if they are relevant to what's 
#  going on in a substate.
# Example: agent is "scouting" (execute-mission/scout) and gets a message about an entity. The scout
#  subgoal already has rules for processing an entity that could be generalized to handle entities in 
#  messages as opposed to those in input, but separate rules are needed for processing the message instead

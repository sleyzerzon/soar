;;;; -*-Lisp-*-
;;;; **************************************************************************
;;;; * Build Game Description                                                 *
;;;; * Transfer Learning in Integrated Cognitive Systems Project              *
;;;; *                                                                        *
;;;; * David J. Stracuzzi                                                     *
;;;; * Arizona State University                                               *
;;;; * Completed: June 20, 2007                                               *
;;;; * Revised:   June 20, 2007                                               *
;;;; **************************************************************************
;;;;
;;;; Basic Assumptions and Rules:
;;;; 1)  Environment is two dimensional, with origin in lower left corner.
;;;; 2)  All primitive objects are rectangular or square. 
;;;; 3)  The weight and strength (ability to support weight) of a primitive
;;;;     depends on its size and material.
;;;; 4)  Primitive objects (except ground) may be rotated.
;;;; 5)  Compound objects are formed from sets of connected objects.
;;;; 6)  Compounds form strict heirarchies. Objects (primitive or compound) 
;;;;     that are not already a members of another compound may be added to,
;;;;     or used to start, a new compound.
;;;; 7)  Compounds may only be connected to form new compounds if some 
;;;;     primitive object in one touches some primitive object in the other.
;;;; 8)  Compounds are permanent (cannot be broken).
;;;; 9)  Compounds and primitives weighing more than WMAX cannot be moved.
;;;; 10) Any primitive object (including members of compounds) not directly 
;;;;     supported by another object will cause collapse.
;;;; 11) Any primitive object bearing weight > strength causes collapse.
;;;; 12) The weight of a primitive and the objects it supports is distributed
;;;;     evenly among the primitives that support it.
;;;; 13) Only objects already in compounds may be braced (joint of two 
;;;;     objects) or reinforced (single object).
;;;; 14) Braces and reinforcements increase object weight additively, and
;;;;     increase object strength multiplicitively.
;;;;
;;;; Actions:
;;;;   (add-to-compound ?compound ?object) - add ?object to existing ?compound
;;;;   (brace ?object1 ?object2 ?brace) - brace the joint between primitives
;;;;                                      ?object1 and ?object2 with ?brace
;;;;   (make-new-compound ?object) - make a new compound with ?object
;;;;   (nudge ?object ?side) - nudge ?object toward ?side, moving it one unit
;;;;   (place-adjacent ?object1 ?object2 ?side) - place ?object2 adjacent to 
;;;;                                              (touching) ?object1's ?side
;;;;   (reinforce ?object ?reinforcement) - reinforce primitive ?object with 
;;;;                                        ?reinforcement
;;;;   (rotate ?object) - rotate primitive ?object 90 degrees ccw
;;;;
;;;; Persistants:
;;;;   (braced ?object1 ?object2 ?brace-type)
;;;;   (current-identifier ?id)
;;;;   (member ?compound ?object)
;;;;   (object ?object ?type)
;;;;   (object-location ?object ?x ?y)
;;;;   (object-size ?object ?width ?height ?weight)
;;;;   (reinforced ?object ?reinforcement-type)

;;; ---------------------------------------------------------------------------
;;; FACTS: Domain facts. These remain fixed across all game instances.

(role agent)

(next-identifier id1 id2)
(next-identifier id2 id3)
(next-identifier id3 id4)
(next-identifier id4 id5)
(next-identifier id5 id6)
(next-identifier id6 id7)
(next-identifier id7 id8)
(next-identifier id8 id9)
(next-identifier id9 id10)
(next-identifier id10 id11)
(next-identifier id11 id12)
(next-identifier id12 id13)
(next-identifier id13 id14)
(next-identifier id14 id15)
(next-identifier id15 id16)
(next-identifier id16 id17)
(next-identifier id17 id18)
(next-identifier id18 id19)
(next-identifier id19 id20)

(orientation horizontal)
(orientation vertical)

(side bottom)
(side left)
(side right)
(side top)

;;; ---------------------------------------------------------------------------
;;; PARAMETERS: Relations that define the state. These will not change 
;;;             during the game.

(max-movable-weight 41)
(max-time 50)
(max-x-coordinate 30)
(min-x-coordinate 0)

;;; (brace-type ?material1 ?material2) = ?material1 may be used to brace two
;;; objects of type ?material2
(brace-type steel-plate steel-beam)
(brace-type steel-plate wood-beam)

;;; (material-type ?type ?strength)
(material-type ground 1000)
(material-type concrete 50)
(material-type rebar 2)
(material-type steel-beam 20)
(material-type steel-plate 2)
(material-type wood-beam 10)

;;; (reinforcement-type ?material1 ?material2) = ?material1 may be used to
;;; reinforce an object of type ?material2
(reinforcement-type rebar concrete)

;;; ---------------------------------------------------------------------------
;;; PERSISTANTS: Relations that define the state. These may be added and
;;;              removed during the game.

(init (current-identifier id1))

(init (time 0))

;;; (object ?object-id ?object-type)
(init (object g1 ground))
(init (object g2 ground))
(init (object g3 ground))
(init (object g4 ground))
(init (object g5 ground))
(init (object b1 steel-beam))
(init (object b2 steel-beam))
(init (object b3 steel-beam))
(init (object c1 concrete))
(init (object c2 concrete))
(init (object c3 concrete))
(init (object c4 concrete))
(init (object c5 concrete))
(init (object c6 concrete))
(init (object c7 concrete))
(init (object r1 rebar))
(init (object r2 rebar))
(init (object r3 rebar))
(init (object r4 rebar))

;;; (object-location ?object-id ?x ?y)
(init (object-location g1 0 0))
(init (object-location g2 5 0))
(init (object-location g3 16 0))
(init (object-location g4 18 0))
(init (object-location g5 21 0))
(init (object-location b1 29 10))
(init (object-location b2 28 10))
(init (object-location b3 27 10))
(init (object-location c1 23 12))
(init (object-location c2 14 1))
(init (object-location c3 11 1))
(init (object-location c4 8 1))
(init (object-location c5 26 10))
(init (object-location c6 24 10))
(init (object-location c7 22 10))
(init (object-location r1 21 10))
(init (object-location r2 19 7))
(init (object-location r3 4 1))
(init (object-location r4 4 2))

;;; (object-size ?object-id ?width ?height ?weight)
(init (object-size g1 2 10 100))
(init (object-size g2 14 1 100))
(init (object-size g3 2 4 100))
(init (object-size g4 3 7 100))
(init (object-size g5 9 10 100))
(init (object-size b1 1 8 8))
(init (object-size b2 1 7 7))
(init (object-size b3 1 4 4))
(init (object-size c1 2 2 20))
(init (object-size c2 2 2 20))
(init (object-size c3 2 2 20))
(init (object-size c4 2 2 20))
(init (object-size c5 1 4 20))
(init (object-size c6 2 2 20))
(init (object-size c7 2 2 20))
(init (object-size r1 1 1 2))
(init (object-size r2 1 1 2))
(init (object-size r3 1 1 2))
(init (object-size r4 1 1 2))


;;; ---------------------------------------------------------------------------
;;; ENTAILMENTS: Relations that must be logically derived from persistants.

;;; Action predicates: these are true if ?agent performed the given action
;;; in the current time step (i.e. (does agent ...) is true)
(<= (action-add-to-compound ?agent ?compound)
    (does ?agent (add-to-compound ?compound ?object)))

(<= (action-brace ?agent ?brace)
    (does ?agent (brace ?object1 ?object2 ?brace)))

(<= (action-brace-object ?agent ?object)
    (does ?agent (brace ?object ?object2 ?brace)))

(<= (action-brace-object ?agent ?object)
    (does ?agent (brace ?object1 ?object ?brace)))

(<= (action-make-new-compound ?agent)
    (does ?agent (make-new-compound ?object)))

(<= (action-nudge ?agent ?object)
    (does ?agent (nudge ?object ?side)))

(<= (action-place-adjacent ?agent ?object2)
    (does ?agent (place-adjacent ?object1 ?object2 ?side)))

(<= (action-reinforce ?agent ?reinforcement)
    (does ?agent (reinforce ?object ?reinforcement)))

(<= (action-reinforce-object ?agent ?object)
    (does ?agent (reinforce ?object ?reinforcement)))

(<= (action-rotate ?agent ?object)
    (does ?agent (rotate ?object)))

;;; Compute whether two objects are adjacent (touching) on ?object1's ?side.
;;; Cases:
;;; 1) ?object1 and ?object2 are both compound. Must find at least one member
;;;    primitive from each that is touching the other.
;;; 2) ?object1 is primitve, ?object2 is compound. Find one member primitive
;;;    of ?object2 that is touching ?object1.
;;; 3) ?object1 is compound, ?object2 is primitive. Similar to 2).
;;; 4) ?object1 and ?object2 both primitive, ?object2 below ?object1.
;;; 5) ?object1 and ?object2 both primitive, ?object2 left of ?object1.
;;; 6) ?object1 and ?object2 both primitive, ?object2 right of ?object1.
;;; 7) ?object1 and ?object2 both primitive, ?object2 on top of ?object1.
(<= (adjacent ?object1 ?object2 ?side)
    (is-recursive-member-of-compound ?object1 ?primitive1)
    (primitive-object ?primitive1)
    (adjacent ?primitive1 ?object2 ?side))

(<= (adjacent ?primitive1 ?object2 ?side)
    (primitive-object ?primitive1)
    (is-recursive-member-of-compound ?object2 ?primitive2)
    (primitive-object ?primitive2)
    (adjacent ?primitive1 ?primitive2 ?side))

(<= (adjacent ?object1 ?primitive2 ?side)
    (primitive-object ?primitive2)
    (is-recursive-member-of-compound ?object1 ?primitive1)
    (primitive-object ?primitive1)
    (adjacent ?primitive1 ?primitive2 ?side))

(<= (adjacent ?primtive1 ?primitive2 bottom)
    (primitive-object ?primtive1)
    (primitive-object ?primtive2)
    (object-coordinates ?primitive1 ?x11 ?shared ?x12 ?y12)
    (object-coordinates ?primitive2 ?x21 ?y21 ?x22 ?shared)
    (>= ?x11 ?x21)
    (> ?x22 ?x11))

(<= (adjacent ?primtive1 ?primitive2 left)
    (primitive-object ?primtive1)
    (primitive-object ?primtive2)
    (object-coordinates ?primitive1 ?shared ?y11 ?x12 ?y12)
    (object-coordinates ?primitive2 ?x21 ?y21 ?shared ?y22)
    (>= ?y11 ?y21)
    (> ?y22 ?y11))

(<= (adjacent ?primtive1 ?primitive2 right)
    (primitive-object ?primtive1)
    (primitive-object ?primtive2)
    (object-coordinates ?primitive1 ?x11 ?y11 ?shared ?y12)
    (object-coordinates ?primitive2 ?shared ?y21 ?x22 ?y22)
    (>= ?y11 ?y21)
    (> ?y22 ?y11))

(<= (adjacent ?primtive1 ?primitive2 top)
    (primitive-object ?primtive1)
    (primitive-object ?primtive2)
    (object-coordinates ?primitive1 ?x11 ?y11 ?x12 ?shared)
    (object-coordinates ?primitive2 ?x21 ?shared ?x22 ?y22)
    (>= ?x11 ?x21)
    (> ?x22 ?x11))

;;; Determine the number of objects adjacent to primitive ?object's ?side.
(<= (adjacent-primitive-count ?object ?side ?number)
    (leftmost-adjacent-primitive ?object ?leftmost ?side)
    (adjacent-primitive-count-recursive ?object ?leftmost ?side ?number))

;;; Determine the number of primitive objects adjacent to ?object's ?side
;;;  that are located right of ?left (including ?left).
(<= (adjacent-primitive-count-recursive ?object ?left ?side ?number)
    (leftmost-adjacent-primitive-to-right ?object ?left ?next ?side)
    (adjacent-primitive-count-recursive ?object ?next ?side ?n)
    (+ ?n 1 ?number))

(<= (adjacent-primitive-count-recursive ?object ?left ?side 1)
    (primitive-object ?object)
    (primitive-object ?left)
    (primitive-object ?next)
    (side ?side)
    (not (leftmost-adjacent-primitive-to-right ?object ?left ?next ?side)))

;;; Compute whether two objects are adjacent on any side.
(<= (adjacent-on-any-side ?object1 ?object2)
    (true (object ?object1 ?type1))
    (true (object ?object2 ?type2))
    (side ?side)
    (adjacent ?object1 ?object2 ?side))

;;; Compute whether any object is adjacent to ?object1's ?side
(<= (adjacent-to-any-object ?object1 ?side)
    (true (object ?object1 ?type1))
    (true (object ?object2 ?type2))
    (side ?side)
    (adjacent ?object1 ?object2 ?side))

;;; Compute whether two objects are aligned on one side
;;; (e.g. left sides have the same x-coordinate)
(<= (aligned ?object1 ?object2 bottom)
    (object-coordinates ?object1 ?x11 ?bottom ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?bottom ?x22 ?y22))

(<= (aligned ?object1 ?object2 left)
    (object-coordinates ?object1 ?left ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?left ?y21 ?x22 ?y22))

(<= (aligned ?object1 ?object2 right)
    (object-coordinates ?object1 ?x11 ?y11 ?right ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?right ?y22))

(<= (aligned ?object1 ?object2 top)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?top)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?top))

;;; Determine if any action is available to the agent.
(<= (available-action)
    (true (object ?compound compound))
    (true (object ?object ?type))
    (can-add-to-compound ?compound ?object))

(<= (available-action)
    (true (object ?object1 ?type1))
    (true (object ?object2 ?type2))
    (true (object ?brace ?brace-type))
    (can-brace ?object1 ?object2 ?brace))

(<= (available-action)
    (true (object ?object ?type))
    (can-make-new-compound ?object))

(<= (available-action)
    (true (object ?object1 ?type1))
    (true (object ?object2 ?type2))
    (side ?side)
    (can-move ?object1 ?object2 ?side))

(<= (available-action)
    (true (object ?object ?type))
    (true (object ?reinforcement ?reinforcement-type))
    (can-reinforce ?object ?reinforcement))

(<= (available-action)
    (true (object ?object ?type))
    (can-rotate ?object))

;;; Compute whether ?object1 and ?object2 have been braced (any type).
(<= (braced-joint ?object1 ?object2)
    (true (braced ?object1 ?object2 ?brace-type)))

;;; Determine whether ?object has been braced
(<= (braced-object ?object)
    (true (braced ?object ?object2 ?brace-type)))

(<= (braced-object ?object)
    (true (braced ?object1 ?object ?brace-type)))

;;; Determine if a bridge has been built
(<= bridge
    (true (object ?beam1 steel-beam))
    (true (object ?beam2 steel-beam))
    (true (object ?beam3 steel-beam))
    (true (object-location ?beam1 ?x1 9))
    (true (object-location ?beam2 ?x1 9))
    (true (object-location ?beam3 ?x1 9))
    (object-orientation ?beam1 horizontal)
    (object-orientation ?beam2 horizontal)
    (object-orientation ?beam3 horizontal)
    (clear ?beam1 top)
    (clear ?beam2 top)
    (clear ?beam3 top)
    (distinct ?beam1 ?beam2)
    (distinct ?beam1 ?beam3)
    (distinct ?beam2 ?beam3))

;;; Determine if ?object may be added to ?compound. Legal if:
;;; 1) ?compound is an existing compound
;;; 2) ?compound is not a recursive sub-compound of ?object
;;; 3) ?object is not a member of any other compound
;;; 4) ?object is adjacent to (touching) some primitive member of ?compound
(<= (can-add-to-compound ?compound ?object)
    (true (object ?compound compound))
    (true (object ?object ?type))
    (not (is-member-of-any-compound ?object))
    (not (is-recursive-member-of-compound ?object ?compound))
    (adjacent-on-any-side ?compound ?object))

;;; Determine if the joint between ?object1 and ?object2 may be braced 
;;; with ?brace. Legal if:
;;; 1) ?object1 and ?object2 are in the same compound
;;; 2) ?object1 and ?object2 are primitives of same material
;;; 3) ?brace is an appropriate material for bracing given objects
;;; 4) ?object1 and ?object2 form a joint (L-shape or T-shape)
;;; 5) ?object1 and ?object2 have not already been braced
(<= (can-brace ?object1 ?object2 ?brace)
    (true (object ?brace ?type))
    (same-compound ?compound ?object1 ?object2)
    (same-primitive-material ?material ?object1 ?object2)
    (brace-type ?type ?material)
    (joint ?object1 ?object2)
    (not (braced-joint ?object1 ?object2)))

;;; Determine if a new compound may be made from ?object. Legal if:
;;; 1) ?object is any existing object
;;; 2) ?object is not a member of any existing compound
(<= (can-make-new-compound ?object)
    (true (object ?object ?type))
    (not (is-member-of-any-compound ?object)))

;;; Determine if ?object can be nudged toward ?side. Legal if:
;;; 1) ?object weighs less than WMAX
;;; 2) nothing is stacked on top of ?object
;;; 3) ?object is not in any compound
;;; 4) ?object does not intersect any other object once moved
(<= (can-nudge ?object ?side)
    (movable ?object)
    (not (is-adjacent-to-object ?object top))
    (not (is-member-of-any-compound ?object))
    (coordinates-after-nudge ?object ?side ?x1 ?y1 ?x2 ?y2)
    (not (region-intersected-by-object ?x1 ?y1 ?x2 ?y2))
    (max-x-coordinate ?max-x)
    (min-x-coordinate ?min-x)
    (>= ?x1 ?min-x)
    (>= ?max-x ?x2))

;;; Move ?object2 adjacent to (touching) ?object1's ?side. Legal if:
;;; 1) ?object1 and ?object2 are not in any compound
;;; 2) nothing is stacked on top of ?object2
;;; 3) ?object2 weighs less than WMAX
;;; 4) there is some object available to support ?object2
;;; 5) ?object2 does not intersect any other object once moved
(<= (can-place-adjacent ?object1 ?object2 ?side)
    (true (object ?object1 ?object1-type))
    (true (object ?object2 ?object2-type))
    (not (is-member-of-any-compound ?object1))
    (not (is-member-of-any-compound ?object2))
    (not (is-adjacent-to-object ?object2 top))
    (movable ?object2)
    (coordinates-after-place ?object1 ?object2 ?side ?x1 ?y1 ?x2 ?y2)
    (not (region-intersected-by-object ?x1 ?y1 ?x2 ?y2)))

;;; Reinforce ?object with ?reinforcement. Legal if:
;;; 1) ?object is in a compound
;;; 2) ?reinforcement can be used on ?object
;;; 3) ?object has not already beed reinforced
(<= (can-reinforce ?object ?reinforcement)
    (true (object ?object ?object-type))
    (true (object ?reinforcement ?reinforcement-type))
    (true (member ?compound ?object))
    (reinforcement-type ?reinforcement-type ?object-type)
    (not (reinforced-object ?object)))

;;; Determine if an object may be rotated. True if:
;;; 1) ?object is primitive
;;; 2) ?object is not of type "ground"
;;; 3) ?object is not a member of any compound
;;; 4) ?object does not intersect any primitive after rotation
(<= (can-rotate ?object)
    (true (object ?object ?type))
    (true (object-location ?object ?x1 ?y1))
    (true (object-size ?object ?width ?height ?weight))
    (material-type ?type ?strength)
    (distinct ?type ground)
    (+ ?x1 ?height ?x2)
    (+ ?y1 ?width ?y2)
    (not (is-member-of-any-compound ?object))
    (not (region-intersected-by-object ?x1 ?y1 ?x2 ?y2)))

;;; Determine if ?object is clear of other objects on ?side 
(<= (clear ?object ?side)
    (true (object ?object ?type))
    (side ?side)
    (not (adjacent-to-any-object ?object ?side)))

;;; Determine if any ?object causes the current structure to collapse. Cases:
;;; 1) ?object is supporting too much weight and is crushed
;;; 2) ?object is not supported by any other object, and falls
(<= collapsed
    (crushed ?object))

(<= collapsed
    (unsupported ?object))

;;; Determine new coordinates for ?compound when ?object is added.
(<= (coordinates-after-add ?compound ?object ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx1 ?ox1 ?test-x1)
    (- ?cx2 ?ox2 ?test-x2)
    (- ?cy1 ?oy1 ?test-y1)
    (- ?cy2 ?oy2 ?test-y2)
    (if-gt0-then-else ?test-x1 ?ox1 ?cx1 ?x1)
    (if-gt0-then-else ?test-x2 ?cx2 ?ox2 ?x2)
    (if-gt0-then-else ?test-y1 ?oy1 ?cy1 ?y1)
    (if-gt0-then-else ?test-y2 ?cy2 ?oy2 ?y2))

;;; Determines new coordinates for ?object when pushed toward ?side. Cases:
;;; 1) ?side = left
;;; 2) ?side = right
(<= (coordinates-after-nudge ?object left ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (- ?ox1 1 ?x1)
    (- ?ox2 1 ?x2))

(<= (coordinates-after-nudge ?object right ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (+ ?ox1 1 ?x1)
    (+ ?ox2 1 ?x2))

;;; Determines potential coordinates for ?object2 on ?object1's ?side. Cases:
;;; 1) ?side = left
;;; 2) ?side = right
;;; 3) ?side = top
(<= (coordinates-after-place ?object1 ?object2 left ?x1 ?y1 ?x2 ?y2)
    (true (object-location ?object1 ?x2 ?oy1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (support ?object1 ?object2 ?support left)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (- ?x2 ?width2 ?x1)
    (+ ?y1 ?height2 ?y2))

(<= (coordinates-after-place ?object1 ?object2 right ?x1 ?y1 ?x2 ?y2)
    (primitive-object ?support)
    (support ?object1 ?object2 ?support right)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (object-coordinates ?object1 ?ox1 ?oy1 ?x1 ?oy2)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (+ ?x1 ?width2 ?x2)
    (+ ?y1 ?height2 ?y2))

(<= (coordinates-after-place ?object1 ?object2 top ?x21 ?y21 ?x22 ?y22)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y21)
    (/ ?width1 2 ?helf-width1)
    (/ ?width2 2 ?helf-width2)
    (+ ?x11 ?half-width1 ?centerx)
    (- ?centerx ?half-width2 ?x21)
    (+ ?x21 ?width2 ?x22)
    (+ ?y12 ?height2 ?y22))

;;; Determine if ?object is crushed by the objects resting on it.
(<= (crushed ?object)
    (strength ?object ?strength)
    (supported-weight ?object ?weight)
    (> ?weight ?strength))

;;; A simple terinary operator: determine if ?test is greater than 0, 
;;; if so, then ?result (4th arg) takes value of ?then, otherwise ?result
;;; takes value of ?else.  
(<= (if-gt0-then-else ?test ?then ?else ?then)
    (+ ?then 0 ?then)
    (+ ?else 0 ?else)
    (> ?test 0))

(<= (if-gt0-then-else ?test ?then ?else ?else)
    (+ ?then 0 ?then)
    (+ ?else 0 ?else)
    (>= 0 ?test))
    
;;; Determine if ?object is adjacent to any other object on ?side
(<= (is-adjacent-to-object ?object ?side)
    (adjacent ?object ?any ?side))

;;; Determine if ?object is a member of any compound
(<= (is-member-of-any-compound ?object)
    (true (member ?compound ?object)))

;;; Determine if ?object is a member of ?compound.  Strictly speaking, this
;;; should be unnecessary, but GDL requires that any variable used as an 
;;; argument in a recursive predicate must also be used in a non-recursive
;;; predicate, where (true ...) does not satisfy the requirement. This 
;;; rule is used to satisfy that requirement.
(<= (is-member-of-compound ?compound ?object)
    (true (member ?compound ?object)))

;;; Determine if ?object is a nested member of ?compound. Cases:
;;; 1) ?object is a direct member of ?compound
;;; 2) ?object is a nested member of ?compound
(<= (is-recursive-member-of-compound ?compound ?object)
    (true (member ?compound ?object)))

(<= (is-recursive-member-of-compound ?compound ?object)
    (is-member-of-compound ?compound ?intermediate)
    (is-recursive-member-of-compound ?intermediate ?object))

;;; Determine if ?object1 and ?object2 form an L- or T-shaped joint. 
(<= (joint ?object1 ?object2)
    (L-joint ?object1 ?object2))

(<= (joint ?object1 ?object2)
    (L-joint ?object2 ?object1))

(<= (joint ?object1 ?object2)
    (T-joint ?object1 ?object2))

(<= (joint ?object1 ?object2)
    (T-joint ?object2 ?object1))

;;; L-joint case 1:
;;; * ?object1 has same left x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 top)
    (wider ?object2 ?object1))

;;; L-joint case 2:
;;; * ?object1 has same right x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 right)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 top)
    (wider ?object2 ?object1))

;;; L-joint case 3:
;;; * ?object1 has same left x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object2 is on ?object1
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object2 ?object1))

;;; L-joint case 4:
;;; * ?object1 has same right x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object2 is on ?object1
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object2 ?object1))

;;; T-joint case 1:
;;; * ?object1 left x-coordinate is greater than ?object2 left x-coordinate
;;; * ?object1 right x-coordinate is less than ?object2 right x-coordinate
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height)
;;; * ?object2 is on ?object1
(<= (T-joint ?object1 ?object2)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?y22)
    (> ?x11 ?x21)
    (> ?x22 ?x12)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 bottom))

;;; T-joint case 2:
;;; * ?object1 left x-coordinate is greater than ?object2 left x-coordinate
;;; * ?object1 right x-coordinate is less than ?object2 right x-coordinate
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height)
;;; * ?object1 is on ?object2
(<= (T-joint ?object1 ?object2)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?y22)
    (> ?x11 ?x21)
    (> ?x22 ?x12)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 top))

;;; Determine if there exists some primitive object adjacent to 
;;; ?object1's ?side that is further left than ?object2
(<= (left-further-adjacent-primitive ?object1 ?object2 ?side)
    (adjacent ?object1 ?other ?side)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?obj-x ?other-x))

;;; Determine if there exists some primitive object adjacent to 
;;; ?object1's ?side that is left of ?right and right of ?object2
(<= (left-further-adjacent-primitive-to-right ?object1 ?object2 ?right ?side)
    (adjacent ?object1 ?other ?side)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?right ?right-x ?right-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?other-x ?obj2-x)
    (> ?right-x ?other-x))

;;; Determine if ?leftmost is the leftmost primitive adjacent to 
;;; ?object's ?side.
(<= (leftmost-adjacent-primitive ?object ?leftmost ?side)
    (adjacent ?object ?leftmost ?side)
    (primitive-object ?leftmost)
    (not (left-further-adjacent-primitive ?object ?leftmost ?side)))

;;; Determine if ?leftmost is adjacent to ?object1's ?side and is
;;; the leftmost object to the right of ?object2.
(<= (leftmost-adjacent-primitive-to-right ?object1 ?object2 ?leftmost ?side)
    (adjacent ?object1 ?leftmost ?side)
    (primtive-object ?leftmost)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?leftmost ?left-x ?left-y))
    (> ?left-x ?obj2-x)
    (not (left-further-adjacent-primitive-to-right ?object1 ?object2
						   ?leftmost ?side)))

;;; Determine if ?material is a type of brace.
(<= (material-is-brace-type ?material)
    (brace-type ?material ?braceable-material))

;;; Determine if ?material is a type of reinforcement
(<= (material-is-reinforcement-type ?material)
    (reinforcement-type ?material ?reinforceable-material))

;;; Determine if an object is movable (weight < WMAX).
(<= (movable ?object)
    (true (object-size ?object ?width ?height ?weight))
    (max-movable-weight ?max)
    (> ?max ?weight))

;;; True if ?identifier is the name of the new compound formed from ?object
(<= (new-compound ?identifier ?object)
    (true (object ?object ?type))
    (true (current-identifier ?old-id))
    (next-identifier ?old-id ?identifier))

;;; Determine the location of the lower-left and upper-right corners of ?object
(<= (object-coordinates ?object ?x1 ?y1 ?x2 ?y2)
    (true (object-location ?object ?x1 ?y1))
    (true (object-size ?object ?width ?height ?weight))
    (+ ?x1 ?width ?x2)
    (+ ?y1 ?height ?y2))

;;; Compute whether ?object intersects the region (?x11 ?y11 ?x12 ?y12).
;;; Cases:
;;; 1) ?object is primitive
;;; 2) ?object is compound
(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
    (primitive-object ?object)
    (object-coordinates ?object ?x21 ?y21 ?x22 ?y22)
    (> ?x22 ?x11)
    (> ?x12 ?x21)
    (> ?y11 ?y22)
    (> ?y21 ?y12))

(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
    (true (object ?object compound))
    (is-member-of-compound ?object ?member)
    (object-intersects-region ?member ?x11 ?y11 ?x12 ?y12))

;;; Determine the orientation of ?object
(<= (object-orientation ?object horizontal)
    (true (object-size ?object ?width ?height ?weight))
    (> ?width ?height))

(<= (object-orientation ?object vertical)
    (true (object-size ?object ?width ?height ?weight))
    (> ?height ?width))

;;; Deterime whether ?object is a primitive
(<= (primitive-object ?object)
    (true (object ?object ?type))
    (material-type ?type ?strength))

;;; Determine if any ?object intersects the given rectangular region
(<= (region-intersected-by-object ?x11 ?y11 ?x12 ?y12)
    (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12))

;;; Determine if ?object is a primitive that has been reinforced.
(<= (reinforced-object ?object)
    (true (reinforced ?object ?reinforcement)))

;;; Determine if ?object1 and ?object2 are in the same compound
(<= (same-compound ?compound ?object1 ?object2)
    (true (member ?compound ?object1))
    (true (member ?compound ?object2)))

;;; Determine if ?object1 and ?object2 are of same primitive material
(<= (same-primitive-material ?material ?object1 ?object2)
    (true (object ?object1 ?material))
    (true (object ?object2 ?material))
    (distinct ?material compound))

;;; Computes the value of ?strength for primitive ?object. Cases:
;;; 1) ?object is not reinforced or braced
;;; 2) ?object is braced (as object1)
;;; 3) ?object is braced (as object2)
;;; 4) ?object is reinforced 
(<= (strength ?object ?strength)
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (not (braced-object ?object))
    (not (reinforced-object ?object))
    (distinct ?type compound)
    (material-type ?type ?material-strength)
    (* ?width ?material-strength ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (braced ?object ?object2 ?brace-type))
    (distinct ?obj-type compound)
    (material-type ?obj-type ?material-strength)
    (material-type ?brace-type ?brace-strength)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?brace-strength ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (braced ?object1 ?object ?brace-type))
    (distinct ?obj-type compound)
    (material-type ?obj-type ?material-strength)
    (material-type ?brace-type ?brace-strength)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?brace-strength ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (reinforced ?object ?reinforcement-type))
    (distinct ?obj-type compound)
    (material-type ?obj-type ?material-strength)
    (material-type ?reinforcement-type ?reinforcement-strength)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?reinforcement-strength ?strength))

;;; Determine if ?object2 will touch ?object1's ?side when placed on ?support.
;;; Cases:
;;; 1) ?side = left
;;; 2) ?side = right
(<= (support ?object1 ?object2 ?support left)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (- ?x1 ?width2 ?minx)
    (- ?y1 ?height ?miny)
    (> ?x1 ?sx1)
    (> ?sx2 ?minx)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2))

(<= (support ?object1 ?object2 ?support left)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (+ ?x2 ?width2 ?maxx)
    (- ?y1 ?height ?miny)
    (> ?maxx ?sx1)
    (> ?sx2 ?x2)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2))

;;; Calculate the amount of weight supported by ?object
(<= (supported-weight ?object ?weight)
    (leftmost-adjacent-primitive ?object ?leftmost top)
    (supported-weight-recursive ?object ?leftmost ?weight))

;;; Calculate the amount of weight supported by ?object from objects
;;; to the right of ?left (including ?left)
(<= (supported-weight-recursive ?object ?left ?weight)
    (leftmost-adjacent-primitive-to-right ?object ?left ?next top)
    (supported-weight-recursive ?object ?next ?wt)
    (weight-contribution ?left ?left-wt)
    (+ ?wt ?left-wt ?weight))

(<= (supported-weight-recursive ?object ?left ?weight)
    (primitive-object ?object)
    (primitive-object ?left)
    (primitive-object ?next)
    (not (leftmost-adjacent-primitive-to-right ?object ?left ?next top))
    (weight-contribution ?left ?weight))

;;; Determine if ?object1 is taller than ?object2
(<= (taller ?object1 ?object2)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (> ?height1 ?height2))

;;; Determine whether ?object is unsupported (nothing below it). This
;;; ignores objects of type GROUND, which are never supported.
(<= (unsupported ?object)
    (true (object ?object ?type))
    (distinct ?type ground)
    (not (adjacent-to-any-object ?object bottom)))

;;; Calculate the amount of weight that ?object contributes to each 
;;; object below it
(<= (weight-contribution ?object ?weight)
    (weight-of-stack ?object ?stack-wt)
    (adjacent-primitive-count ?object bottom ?number)
    (/ ?stack-wt ?number ?temp)
    (round ?temp ?weight))

;;; Calculate the total weight that ?object exerts collectively 
;;; on the objects below it
(<= (weight-of-stack ?object ?weight)
    (true (object-size ?object ?obj-wid ?obj-ht ?obj-wt))
    (supported-weight ?object ?supported-wt)
    (+ ?obj-wt ?supported-wt ?weight))

;;; Determine if ?object1 is wider than ?object2
(<= (wider ?object1 ?object2)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (> ?width1 ?width2))

;;; ---------------------------------------------------------------------------
;;; LEGAL AXIOMS

;;; Add ?object to ?compound.
(<= (legal agent (add-to-compound ?compound ?object))
    (can-add-to-compound ?compound ?object))

;;; Brace joint between ?object1 and ?object2 with ?brace.
(<= (legal agent (brace ?object1 ?object2 ?brace))
    (can-brace ?object1 ?object2 ?brace))

;;; Make a new compound object with ?object.
(<= (legal agent (make-new-compound ?object))
    (can-make-new-compound ?object))

;;; Move ?object one cell in the specified direnction
(<= (legal agent (nudge ?object ?side))
    (can-nudge ?object ?side))

;;; Move ?object2 adjacent to (touching) ?object1's ?side.
(<= (legal agent (place-adjacent ?object1 ?object2 ?side))
    (can-place-adjacent ?object1 ?object2 ?side))

;;; Reinforce ?object with ?reinforcement.
(<= (legal agent (reinforce ?object ?reinforcement))
    (can-reinforce ?object ?reinforcement))

;;; Rotate a primitive object.
(<= (legal agent (rotate ?object))
    (can-rotate ?object))


;;; ---------------------------------------------------------------------------
;;; NEXT AXIOMS

;;; Add object to existing compound: 
;;; 1) Declare object membership in compound
;;; 2) Update compound location
;;; 3) Update compound size
(<= (next (member ?compound ?object))
    (does agent (add-to-compound ?compound ?object)))

(<= (next (object-location ?compound ?x ?y))
    (does agent (add-to-compound ?compound ?object))
    (coordinates-after-add ?compound ?object ?x ?y ?x2 ?y2))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (add-to-compound ?compound ?object))
    (coordinates-after-add ?compound ?object ?x1 ?y1 ?x2 ?y2)
    (true (object-size ?compound ?old-width ?old-height ?old-weight))
    (true (object-size ?object ?obj-width ?obj-height ?obj-weight))
    (- ?x2 ?x1 ?width)
    (- ?y2 ?y1 ?height)
    (+ ?old-weight ?obj-weight ?weight))

;;; Brace the joint between two objects:
;;; 1) Declare the brace
;;; 2) Update compound size
(<= (next (braced ?object1 ?object2 ?brace))
    (does agent (brace ?object1 ?object2 ?brace)))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace))
    (true (member ?compound ?object1))
    (true (member ?compound ?object2))
    (true (object-size ?compound ?width ?height ?c-weight))
    (true (object-size ?brace ?b-width ?b-height ?b-weight))
    (+ ?c-weight ?b-weight ?weight))

;;; Make a new compound object: 6 steps.
;;; 1) Declare the compound
;;; 2) Declare object membership in compound
;;; 3) Initialize compound location
;;; 4) Initialize compound size
;;; 5) Update current-identifier
(<= (next (object ?identifier compound))
    (does agent (make-new-compound ?object))
    (new-compound ?identifier ?object))

(<= (next (member ?identifier ?object))
    (does agent (make-new-compound ?object))
    (new-compound ?identifier ?object))

(<= (next (object-location ?identifier ?x ?y))
    (does agent (make-new-compound ?object))
    (true (object-location ?object ?x ?y))
    (new-compound ?identifier ?object))

(<= (next (object-size ?identifier ?width ?height ?weight))
    (does agent (make-new-compound ?object))
    (true (object-size ?object ?width ?height ?weight))
    (new-compound ?identifier ?object))

(<= (next (current-identifier ?id))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?old-id))
    (next-identifier ?old-id ?id))

;;; Move an object one cell in a given direction.
;;; 1) If object is primitive, then just update the location
;;; 2) If object is compound, then update all nested members
(<= (next (object-location ?object ?x ?y))
    (does agent (nudge ?object ?side))
    (primitive ?object)
    (coordinates-after-nudge ?object ?side ?x ?y ?x2 ?y2))

(<= (next (object-location ?object ?x ?y))
    (does agent (nudge ?object ?side))
    (true (object ?object compound))
    (is-recursive-member-of-compound ?object ?primitive)
    (coordinates-after-nudge ?primitive ?side ?x ?y ?x2 ?y2))

;;; Move one object adjacent to another on a specified side:
;;; 1) If object is primitive, then just update the location
;;; 2) If object is compound, then update all nested members
(<= (next (object-location ?object2 ?x ?y))
    (does agent (place-adjacent ?object1 ?object2 ?side))
    (primitive ?object1)
    (coordinates-after-place ?object1 ?object2 ?side ?x ?y ?x2 ?y2))

(<= (next (object-location ?member ?x ?y))
    (does agent (place-adjacent ?object1 ?object2 ?side))
    (true (object ?object2 compound))
    (true (object-location ?object2 ?old-x2 ?old-y2))
    (coordinates-after-place ?object1 ?object2 ?side ?new-x2 ?new-y2 ?x22 ?y22)
    (- ?new-x2 ?old-x2 ?dist-x)
    (- ?new-y2 ?old-y2 ?dist-y)
    (is-recursive-member-of-compound ?object2 ?member)
    (true (object-location ?member ?old-x ?old-y))
    (+ ?old-x ?dist-x ?x)
    (+ ?old-y ?dist-y ?y))

;;; Reinforce primitive ?object with ?material: 
;;; 1) Declare reinforcement
;;; 2) Update object size
(<= (next (reinforced ?object ?material))
    (does agent (reinforce ?object ?reinforcement))
    (true (object ?reinforcement ?material)))

(<= (next (object-size ?object ?width ?height ?weight))
    (does agent (reinforce ?object ?reinforcement))
    (true (object-size ?object ?width ?height ?obj-weight))
    (true (object-size ?reinforcement ?r-width ?r-height ?r-weight))
    (+ ?obj-weight ?r-weight ?weight))

;;; Rotate a primitive object (switches width and height)
(<= (next (object-size ?object ?height ?width ?weight))
    (does agent (rotate ?object))
    (true (object-size ?object ?width ?height ?weight)))

;;; Advance time one step
(<= (next (time ?t))
    (true (time ?oldt))
    (+ ?oldt 1 ?t))


;;; ---------------------------------------------------------------------------
;;; FRAME AXIOMS (NEXT)

;;; Carry all brace declarations into next state
(<= (next (braced ?object1 ?object2 ?material))
    (true (braced ?object1 ?object2 ?material)))

;;; Carry current identifier into next state if the agent does not
;;; make a new compound in the current time step
(<= (next (current-identifier ?id))
    (true (current-identifier ?id))
    (not (action-make-new-compound agent)))

;;; Carry all membership declarations into next state
(<= (next (member ?compound ?object))
    (true (member ?compound ?object)))

;;; Most object declarations always get carried into the next state.
;;; However, primitive objects used as braces and reinforcements remain 
;;; only until used, then they "disappear".   Cases:
;;; 1) ?object is not a brace or reinforcement
;;; 2) ?object is a brace, but was not used in agent's action
;;; 3) ?object is a reinforcement, but was not used in agent's action
(<= (next (object ?object ?type))
    (true (object ?object ?type))
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type)))

(<= (next (object ?brace ?brace-type))
    (true (object ?brace ?brace-type))
    (brace-type ?brace-type ?brace-material)
    (not (action-brace agent ?brace)))

(<= (next (object ?reinforcement ?reinforcement-type))
    (true (object ?reinforcement ?reinforcement-type))
    (reinforcement-type ?reinforcement-type ?reinforcement-material)
    (not (action-reinforce agent ?reinforcement)))

;;; Most (object-location ...) declarations get carried into the next state,
;;; but some get modified, and some disappear.  Cases:
;;; 1) ?object is compound, nothing was added, and was not moved
;;; 2) ?object is primitive, is not a brace or reinforcement, and was not moved
;;; 3) ?object is a brace, and was not moved or used
;;; 4) ?object is a reinforcement, and was not moved or used
(<= (next (object-location ?object ?x ?y))
    (true (object ?object compound))
    (true (object-location ?object ?x ?y))
    (not (action-add-to-compound agent ?object))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (material-type ?type ?strength)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (brace-type ?type ?brace-material)
    (not (action-brace agent ?object))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (reinforcement-type ?type ?reinforcement-material)
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object))
    (not (action-reinforce agent ?object)))

;;; Most (object-size ...) declarations get carried into the next state,
;;; but some get modified, and some disappear.  Cases:
;;; 1) ?object is compound, was not rotated, and no new object was added
;;; 2) ?object is primitive, is not a brace or reinforcement, was not rotated
;;; 3) ?object is a brace, and was not used or rotated
;;; 4) ?object is a reinforcement, and was not used or rotated
(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object compound))
    (true (object-size ?object ?width ?height ?weight))
    (not (action-add-to-compound agent ?object))
    (not (action-rotate agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (material ?type)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (action-rotate agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (brace-type ?type ?brace-material)
    (not (action-brace agent ?object))
    (not (action-rotate agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (reinforcement-type ?type ?reinforcement-material)
    (not (action-reinforce agent ?object))
    (not (action-rotate agent ?object)))

;;; Carry all reinforcement declarations into next state
(<= (next (reinforced ?object ?material))
    (true (reinforced ?object ?material)))


;;; ---------------------------------------------------------------------------
;;; GOAL STATES
;;; 1) WIN:  Building meets success conditions
;;; 2) LOSE: Building collapsed
;;; 3) DRAW: No actions available to agent
;;; 4) DRAW: Maximum time-step reached

(<= (goal agent 100)
    bridge)

(<= (goal agent 0)
    collapsed)

(<= (goal agent 50)
    (not (available-action)))

(<= (goal agent 50)
    (true (time ?t))
    (max-time ?t))


;;; ---------------------------------------------------------------------------
;;; TERMINAL STATES
;;; 1) Building meets success conditions
;;; 2) Building collapsed
;;; 3) No actions available to agent
;;; 4) Maximum time-step reached

(<= terminal
    bridge)

(<= terminal
    collapsed)

(<= terminal
    (not (available-action)))

(<= terminal
    (true (time ?t))
    (max-time ?t))


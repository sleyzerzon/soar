;;;; -*-Lisp-*-
;;;; **************************************************************************
;;;; * Build Game: Core Rules                                                 *
;;;; * Transfer Learning in Integrated Cognitive Systems Project              *
;;;; *                                                                        *
;;;; * David J. Stracuzzi                                                     *
;;;; * Arizona State University                                               *
;;;; * Completed: June 20, 2007                                               *
;;;; * Revised:   June 28, 2007                                               *
;;;; **************************************************************************
;;;;
;;;; This file contains the core game description for BUILD.  Rules, facts and 
;;;; persistants for specific game instances appear in other files. Appending
;;;; the file for a game instance to this file will produce a complete, 
;;;; playable game description.
;;;;
;;;; Basic Assumptions and Rules:
;;;; 1)  Environment is two dimensional, with origin in lower left corner.
;;;;
;;;; 2)  All primitive objects are rectangular or square. 
;;;;
;;;; 3)  The weight and strength (ability to support weight) of a primitive
;;;;     depends on its size and material. To assure consistancy, the initial
;;;;     weight of primitives should be set by selecting a "weight factor" for
;;;;     for each material, and then multiplying that factor by the area of
;;;;     the primitive.  Likewise, the strength of a primitive is determined
;;;;     by multiplying the specified "strength factor" by the width of the
;;;;     primitive.
;;;;
;;;; 4)  Braces and reinforcements increase object weight additively, and
;;;;     increase object strength multiplicitively.
;;;;
;;;; 5)  Any primitive object bearing weight > strength causes collapse.
;;;;
;;;; 6)  The weight of a primitive, P1, and the objects supported by P1 is 
;;;;     distributed evenly among the primitives that support P1.
;;;;
;;;; 7)  Compound objects are formed from sets of connected objects.
;;;;
;;;; 8)  Compounds form strict heirarchies. Only objects (primitive or 
;;;;     compound) that are not already a members of another compound may
;;;;     be added to, or used to start, a compound.
;;;;
;;;; 9)  Compounds are permanent (cannot be broken).
;;;;
;;;; 10) Any primitive object (including members of compounds) not directly 
;;;;     supported by another object will cause collapse.
;;;;
;;;; Actions:
;;;; * (add-to-compound ?compound ?object)
;;;;     Effects: 
;;;;     * ?object becomes a member of ?compound
;;;;     * The object-location and object-size of ?compound may change 
;;;;     Requirements:
;;;;     * ?compound already exists
;;;;     * ?compound is not a member of ?object's compound hierarchy
;;;;     * ?object is not a member of any other compound
;;;;     * Some member of ?object (or ?object itself if primitive) is
;;;;       touching some member of ?compound 
;;;;
;;;; * (brace ?object1 ?object2 ?brace)
;;;;     Effects: 
;;;;     * The joint between ?object1 and ?object2 is braced by ?brace
;;;;     * The object-size (weight) of ?object1 and ?object2 each increase
;;;;       by 1/2 the weight of ?brace
;;;;     * The weight of any compound above ?object1 and ?object2 in the 
;;;;       hierarchy increases by the weight of ?brace
;;;;     * ?brace is no longer available for use
;;;;     * The strength of ?object1 and ?object2 are multiplied by the 
;;;;       strength of ?brace
;;;;     Requirements:
;;;;     * ?object1 and ?object are members of the same compound
;;;;     * ?object1 and ?object2 are primitives of the same material
;;;;     * ?brace is an appropriate material for bracing ?object1 and ?object2
;;;;     * ?object1 and ?object2 form a joint (L-shaped or T-shaped)
;;;;     * ?object1 and ?object2 have not already been braced
;;;;
;;;; * (make-new-compound ?object)
;;;;     Effects:
;;;;     * A new compound object is created, with unique identifier
;;;;     * ?object is a member of the new compound
;;;;     * The new compound has the same location and size as ?object
;;;;     Requirements
;;;;     * ?object is an existing object (primitive or compound)
;;;;     * ?object is not a member of any other compound
;;;;
;;;; * (nudge ?object ?side)
;;;;     Effects:
;;;;     * ?object moves one unit toward ?side
;;;;     Requirements
;;;;     * ?object must weigh less than "max-movable-weight"
;;;;     * Nothing is stacked on top of ?object
;;;;     * ?object is not a member of any compound
;;;;     * ?object does not intersect any other primitive object once moved
;;;;     * ?side must be "left" or "right"
;;;;
;;;; * (place-adjacent ?object1 ?object2 ?side)
;;;;     Effects:
;;;;     * ?object2 is placed adjacent to (touching) ?object1's ?side.
;;;;       If ?side=top, then ?object2 is centered on top of ?object1 
;;;;       (failure if it won't fit).  If ?side=left or right, then the
;;;;       lowest available support is selected such that ?object1 and ?
;;;;       object2 touch (failure if none exists). ?side=bottom not allowed.
;;;;     * ?object2's location is changed
;;;;     * If ?object2 is compound, the locations of all members of the 
;;;;       compound hierarchy are appropriately updated
;;;;     Requirements:
;;;;     * ?object1 and ?object2 are not members of any compound
;;;;     * Nothing is stacked on top of ?object2
;;;;     * ?object2 must weigh less than "max-movable-weight"
;;;;     * There is some object available to support ?object2
;;;;     * ?object2 does not intersect any other primitive once moved
;;;;
;;;; * (reinforce ?object ?reinforcement)
;;;;     Effects:
;;;;     * ?object is reinforced with ?reinforcement
;;;;     * ?object's weight increases by weight of ?reinforcement
;;;;     * The weight of any compound above ?object in the hierarchy
;;;;       increases by the weight of ?reinforcement
;;;;     * ?object's strength is multiplied by the strength of ?reinforcement
;;;;     Requirements:
;;;;     * ?object is a member of some compound
;;;;     * ?reinforcement is an appropriate material for ?object
;;;;     * ?object has not already been reinforced
;;;;
;;;; * (rotate ?object)
;;;;     Effects:
;;;;     * The width and height dimensions of ?object are exchanged
;;;;     Requirements:
;;;;     * ?object is primitive
;;;;     * ?object is not of type "ground"
;;;;     * ?object is not a member of any compound
;;;;     * ?object does not intersect any primitive after rotation
;;;;
;;;; Persistants:
;;;;   (braced ?object1 ?object2 ?brace-type)
;;;;   (current-identifier ?id)
;;;;   (member ?compound ?object)
;;;;   (object ?object ?type)
;;;;   (object-location ?object ?x ?y)
;;;;   (object-size ?object ?width ?height ?weight)
;;;;   (reinforced ?object ?reinforcement-type)

;;; ---------------------------------------------------------------------------
;;; FACTS: Domain facts. These remain fixed across all game instances.

(role agent)

(next-identifier id1 id2)
(next-identifier id2 id3)
(next-identifier id3 id4)
(next-identifier id4 id5)
(next-identifier id5 id6)
(next-identifier id6 id7)
(next-identifier id7 id8)
(next-identifier id8 id9)
(next-identifier id9 id10)
(next-identifier id10 id11)
(next-identifier id11 id12)
(next-identifier id12 id13)
(next-identifier id13 id14)
(next-identifier id14 id15)
(next-identifier id15 id16)
(next-identifier id16 id17)
(next-identifier id17 id18)
(next-identifier id18 id19)
(next-identifier id19 id20)

(orientation horizontal)
(orientation vertical)

(side bottom)
(side left)
(side right)
(side top)

;;; ---------------------------------------------------------------------------
;;; ENTAILMENTS: Relations that must be logically derived from persistants.

;;; Action predicates: these are true if ?agent performed the given action
;;; in the current time step (i.e. (does agent ...) is true).   Some of
;;; these have several cases, including versions that apply when the object
;;; acted upon is a member of a larger compound that must be updated in some
;;; manner.
(<= (action-add-to-compound ?agent ?compound)
    (does ?agent (add-to-compound ?compound ?object)))

(<= (action-brace ?agent ?brace)
    (does ?agent (brace ?object1 ?object2 ?brace)))

(<= (action-brace ?agent ?object1)
    (does ?agent (brace ?object1 ?object2 ?brace)))

(<= (action-brace ?agent ?object2)
    (does ?agent (brace ?object1 ?object2 ?brace)))

(<= (action-brace ?agent ?compound)
    (does ?agent (brace ?object1 ?object2 ?brace))
    (is-recursive-member-of-compound ?compound ?object1))

(<= (action-brace ?agent ?compound)
    (does ?agent (brace ?object1 ?object2 ?brace))
    (is-recursive-member-of-compound ?compound ?object2))

(<= (action-make-new-compound ?agent)
    (does ?agent (make-new-compound ?object)))

(<= (action-nudge ?agent ?object)
    (does ?agent (nudge ?object ?side)))

(<= (action-nudge ?agent ?object)
    (does ?agent (nudge ?compound ?side))
    (is-recursive-member-of-compound ?compound ?object))

(<= (action-place-adjacent ?agent ?object2)
    (does ?agent (place-adjacent ?object1 ?object2 ?side)))

(<= (action-place-adjacent ?agent ?object)
    (does ?agent (place-adjacent ?object1 ?compound ?side))
    (is-recursive-member-of-compound ?compound ?object))

(<= (action-reinforce ?agent ?reinforcement)
    (does ?agent (reinforce ?object ?reinforcement)))

(<= (action-reinforce ?agent ?object)
    (does ?agent (reinforce ?object ?reinforcement)))

(<= (action-reinforce ?agent ?object)
    (does ?agent (reinforce ?member ?reinforcement))
    (is-recursive-member-of-compound ?object ?member))

(<= (action-rotate ?agent ?object)
    (does ?agent (rotate ?object)))

;;; Compute whether two objects are adjacent (touching) on ?object1's ?side.
;;; Cases:
;;; 1) ?object1 and ?object2 are both compound. Must find at least one member
;;;    primitive from each that is touching the other.
;;; 2) ?object1 is primitve, ?object2 is compound. Find one member primitive
;;;    of ?object2 that is touching ?object1.
;;; 3) ?object1 is compound, ?object2 is primitive. Similar to 2).
;;; 4) ?object1 and ?object2 both primitive, ?object2 below ?object1.
;;; 5) ?object1 and ?object2 both primitive, ?object2 left of ?object1.
;;; 6) ?object1 and ?object2 both primitive, ?object2 right of ?object1.
;;; 7) ?object1 and ?object2 both primitive, ?object2 on top of ?object1.
(<= (adjacent ?object1 ?object2 ?side)
    (is-recursive-member-of-compound ?object1 ?primitive1)
    (primitive-object ?primitive1)
    (adjacent ?primitive1 ?object2 ?side))

(<= (adjacent ?primitive1 ?object2 ?side)
    (primitive-object ?primitive1)
    (is-recursive-member-of-compound ?object2 ?primitive2)
    (primitive-object ?primitive2)
    (adjacent ?primitive1 ?primitive2 ?side))

(<= (adjacent ?object1 ?primitive2 ?side)
    (is-recursive-member-of-compound ?object1 ?primitive1)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (adjacent ?primitive1 ?primitive2 ?side))

(<= (adjacent ?primitive1 ?primitive2 bottom)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?x11 ?shared ?x12 ?y12)
    (object-coordinates ?primitive2 ?x21 ?y21 ?x22 ?shared)
    (> ?x12 ?x21)
    (> ?x22 ?x11))

(<= (adjacent ?primitive1 ?primitive2 left)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?shared ?y11 ?x12 ?y12)
    (object-coordinates ?primitive2 ?x21 ?y21 ?shared ?y22)
    (> ?y12 ?y21)
    (> ?y22 ?y11))

(<= (adjacent ?primitive1 ?primitive2 right)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?x11 ?y11 ?shared ?y12)
    (object-coordinates ?primitive2 ?shared ?y21 ?x22 ?y22)
    (> ?y12 ?y21)
    (> ?y22 ?y11))

(<= (adjacent ?primitive1 ?primitive2 top)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?x11 ?y11 ?x12 ?shared)
    (object-coordinates ?primitive2 ?x21 ?shared ?x22 ?y22)
    (> ?x12 ?x21)
    (> ?x22 ?x11))

;;; Compute whether two objects are adjacent on any side.
(<= (adjacent-on-any-side ?object1 ?object2)
    (true (object ?object1 ?type1))
    (true (object ?object2 ?type2))
    (side ?side)
    (adjacent ?object1 ?object2 ?side))

;;; Determine the number of objects adjacent to primitive ?object's ?side.
(<= (adjacent-primitive-count ?object ?side ?number)
    (leftmost-adjacent-primitive ?object ?leftmost ?side)
    (adjacent-primitive-count-recursive ?object ?leftmost ?side ?number))

;;; Determine the number of primitive objects adjacent to ?object's ?side
;;;  that are located right of ?left (including ?left).
(<= (adjacent-primitive-count-recursive ?object ?left ?side ?number)
    (leftmost-adjacent-primitive-to-right ?object ?left ?next ?side)
    (adjacent-primitive-count-recursive ?object ?next ?side ?n)
    (+ ?n 1 ?number))

(<= (adjacent-primitive-count-recursive ?object ?left ?side 1)
    (primitive-object ?object)
    (primitive-object ?left)
    (side ?side)
    (not (adjacent-primitive-to-right ?object ?left ?side)))

;;; Determine if any primitive is adjacent to ?object's ?side to the 
;;; right of ?left
(<= (adjacent-primitive-to-right ?object ?left ?side)
    (adjacent ?object ?left ?side)
    (adjacent ?object ?right ?side)
    (true (object-location ?left ?left-x ?left-y))
    (true (object-location ?right ?right-x ?right-y))
    (> ?right-x ?left-x))

;;; Compute whether any object is adjacent to ?object1's ?side
(<= (adjacent-to-any-object ?object1 ?side)
    (true (object ?object1 ?type1))
    (true (object ?object2 ?type2))
    (side ?side)
    (adjacent ?object1 ?object2 ?side))

;;; Compute whether two objects are aligned on one side
;;; (e.g. left sides have the same x-coordinate)
(<= (aligned ?object1 ?object2 bottom)
    (object-coordinates ?object1 ?x11 ?bottom ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?bottom ?x22 ?y22))

(<= (aligned ?object1 ?object2 left)
    (object-coordinates ?object1 ?left ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?left ?y21 ?x22 ?y22))

(<= (aligned ?object1 ?object2 right)
    (object-coordinates ?object1 ?x11 ?y11 ?right ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?right ?y22))

(<= (aligned ?object1 ?object2 top)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?top)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?top))

;;; Determine if any action is available to the agent.
(<= (available-action)
    (can-add-to-compound ?compound ?object))

(<= (available-action)
    (can-brace ?object1 ?object2 ?brace))

(<= (available-action)
    (can-make-new-compound ?object))

(<= (available-action)
    (can-nudge ?object ?side))

(<= (available-action)
    (can-place-adjacent ?object1 ?object2 ?side))

(<= (available-action)
    (can-reinforce ?object ?reinforcement))

(<= (available-action)
    (can-rotate ?object))

;;; Compute whether ?object1 and ?object2 have been braced (any type).
(<= (braced-joint ?object1 ?object2)
    (true (braced ?object1 ?object2 ?brace-type)))

(<= (braced-joint ?object1 ?object2)
    (true (braced ?object2 ?object1 ?brace-type)))

;;; Determine whether ?object has been braced
(<= (braced-object ?object)
    (true (braced ?object ?object2 ?brace-type)))

(<= (braced-object ?object)
    (true (braced ?object1 ?object ?brace-type)))

;;; Determine if a bridge extends across the open space between the objects
;;; ?left and ?right at the ends of the bridge. Requirements include:
;;; 1) The top of ?left and ?right is at the same height
;;; 2) ?left is to the left of ?right and there is space between the two
;;; 3) Every cell between ?left and ?right at the same height as their tops
;;;    has a support (this is the deck of the bridge)
(<= (bridge ?left ?right)
    (object-coordinates ?left ?x11 ?y11 ?x12 ?y)
    (object-coordinates ?right ?x21 ?y21 ?x22 ?y)
    (> ?x21 ?x12)
    (- ?x21 1 ?end-x)
    (bridge-segment ?x12 ?end-x ?y))

;;; Determine if, for every cell between ?start-x and ?end-x at height ?y, 
;;; there is a support. Cases:
;;; 1) Base: ?start-x > ?end-x
;;; 2) General: A primitive object ?support has top at ?y, is clear on top, 
;;;    and ?start-x is between ?support's left and right sides

;;(<= (bridge-segment ?start-x ?end-x ?y)
;;    (number ?y)
;;    (> ?start-x ?end-x))
;; Manually modify
(<= (bridge-segment ?start-x ?end-x ?y)
    (number ?y)
    (> ?start-x ?end-x)
    (object-coordinates ?left ?x11 ?y11 ?start-x ?y)
    (object-coordinates ?right ?x21 ?y21 ?x22 ?y)
    (> ?x21 ?start-x)
    (- ?x21 1 ?end-x)
    )


;;(<= (bridge-segment ?start-x ?end-x ?y)
;;    (primitive-object ?support)
;;    (object-coordinates ?support ?x1 ?y1 ?x2 ?y)
;;    (true (object-size ?support ?width ?height ?weight))
;;    (>= ?start-x ?x1)
;;    (> ?x2 ?start-x)
;;    (+ ?start-x ?width ?next-x)
;;    (clear ?support top)
;;    (bridge-segment ?next-x ?end-x ?y))
;; Manually modify
(<= (bridge-segment ?start-x ?end-x ?y)
    (primitive-object ?support)
    (object-coordinates ?support ?x1 ?y1 ?x2 ?y)
    (true (object-size ?support ?width ?height ?weight))
    (>= ?start-x ?x1)
    (> ?x2 ?start-x)
    (+ ?start-x ?width ?next-x)
    (clear ?support top)
    (bridge-segment ?next-x ?end-x ?y)
    ;;(int ?start-x) ;; start-x is unbound, it is actually bound by the math relation!
    )


;;; Determine if ?object may be added to ?compound. Legal if:
;;; 1) ?compound is an existing compound
;;; 2) ?compound and ?object are different
;;; 2) ?compound is not a recursive sub-compound of ?object
;;; 3) ?object is not a member of any other compound
;;; 4) ?object is adjacent to (touching) some primitive member of ?compound
(<= (can-add-to-compound ?compound ?object)
    (true (object ?compound compound))
    (true (object ?object ?type))
    (distinct ?compound ?object)
    (distinct ?type ground)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (is-member-of-any-compound ?object))
    (not (is-recursive-member-of-compound ?object ?compound))
    (adjacent-on-any-side ?compound ?object))

;;; Determine if the joint between ?object1 and ?object2 may be braced 
;;; with ?brace. Legal if:
;;; 1) ?object1 and ?object2 are in the same compound
;;; 2) ?object1 and ?object2 are primitives of same material
;;; 3) ?brace is an appropriate material for bracing given objects
;;; 4) Nothing is on top of ?brace
;;; 5) ?brace is not a member of any compound
;;; 5) ?object1 and ?object2 form a joint (L-shape or T-shape)
;;; 6) ?object1 and ?object2 have not already been braced
(<= (can-brace ?object1 ?object2 ?brace)
    (true (object ?brace ?type))
    (same-compound ?compound ?object1 ?object2)
    (same-primitive-material ?material ?object1 ?object2)
    (brace-type ?type ?material)
    (clear ?brace top)
    (not (is-member-of-any-compound ?brace))
    (joint ?object1 ?object2)
    (not (braced-joint ?object1 ?object2)))

;;; Determine if a new compound may be made from ?object. Legal if:
;;; 1) ?object is any existing object
;;; 2) ?object is not a member of any existing compound
(<= (can-make-new-compound ?object)
    (true (object ?object ?type))
    (distinct ?type ground)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (is-member-of-any-compound ?object)))

;;; Determine if ?object can be nudged toward ?side. Legal if:
;;; 1) ?object weighs less than WMAX
;;; 2) nothing is stacked on top of ?object
;;; 3) ?object is not in any compound
;;; 4) ?object does not intersect any other object once moved
;;; 5) ?object is supported once moved
(<= (can-nudge ?object ?side)
    (movable ?object)
    (clear ?object top)
    (not (is-member-of-any-compound ?object))
    (coordinates-after-nudge ?object ?side ?x1 ?y1 ?x2 ?y2)
    (not (region-intersected-by-object ?object ?x1 ?y1 ?x2 ?y2))
    (support-for-nudge ?object ?support ?side))

;;; Move ?object2 adjacent to (touching) ?object1's ?side. Legal if:
;;; 1) ?object1 and ?object2 are different
;;; 2) ?object1 and ?object2 are not in any compound
;;; 3) nothing is stacked on top of ?object2
;;; 4) ?object2 weighs less than WMAX
;;; 5) there is some object available to support ?object2
;;; 6) ?object2 does not intersect any other object once moved
(<= (can-place-adjacent ?object1 ?object2 ?side)
    (true (object ?object1 ?object1-type))
    (true (object ?object2 ?object2-type))
    (distinct ?object1 ?object2)
    (not (is-member-of-any-compound ?object1))
    (not (is-member-of-any-compound ?object2))
    (clear ?object2 top)
    (movable ?object2)
    (coordinates-after-place ?object1 ?object2 ?side ?x1 ?y1 ?x2 ?y2)
    (not (region-intersected-by-object ?object2 ?x1 ?y1 ?x2 ?y2)))

;;; Reinforce ?object with ?reinforcement. Legal if:
;;; 1) ?object is in a compound
;;; 2) ?reinforcement can be used on ?object
;;; 3) Nothing is on top of ?reinforcement
;;; 4) ?reinforcement is not a member of any compound
;;; 5) ?object has not already been reinforced
(<= (can-reinforce ?object ?reinforcement)
    (true (object ?object ?object-type))
    (true (object ?reinforcement ?reinforcement-type))
    (true (member ?compound ?object))
    (reinforcement-type ?reinforcement-type ?object-type)
    (clear ?reinforcement top)
    (not (is-member-of-any-compound ?reinforcement))
    (not (reinforced-object ?object)))

;;; Determine if an object may be rotated. True if:
;;; 1) ?object is primitive
;;; 2) ?object is not of type "ground"
;;; 3) Nothing is on top of ?object
;;; 4) ?object is not a member of any compound
;;; 5) ?object does not intersect any primitive after rotation
(<= (can-rotate ?object)
    (true (object ?object ?type))
    (true (object-location ?object ?x1 ?y1))
    (true (object-size ?object ?width ?height ?weight))
    (material-type ?type ?strength)
    (distinct ?type ground)
    (clear ?object top)
    (+ ?x1 ?height ?x2)
    (+ ?y1 ?width ?y2)
    (not (is-member-of-any-compound ?object))
    (not (region-intersected-by-object ?object ?x1 ?y1 ?x2 ?y2)))

;;; Determine if ?object is clear of other objects on ?side 
(<= (clear ?object ?side)
    (true (object ?object ?type))
    (side ?side)
    (not (adjacent-to-any-object ?object ?side)))

;;; Determine if any ?object causes the current structure to collapse. Cases:
;;; 1) ?object is supporting too much weight and is crushed
;;; 2) ?object is not supported by any other object, and falls
(<= collapsed
    (crushed ?object))

(<= collapsed
    (unsupported ?object))

;;; Determine new coordinates for ?compound when ?object is added.
(<= (coordinates-after-add ?compound ?object ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx1 ?ox1 ?test-x1)
    (- ?cx2 ?ox2 ?test-x2)
    (- ?cy1 ?oy1 ?test-y1)
    (- ?cy2 ?oy2 ?test-y2)
    (if-gt0-then-else ?test-x1 ?ox1 ?cx1 ?x1)
    (if-gt0-then-else ?test-x2 ?cx2 ?ox2 ?x2)
    (if-gt0-then-else ?test-y1 ?oy1 ?cy1 ?y1)
    (if-gt0-then-else ?test-y2 ?cy2 ?oy2 ?y2))

;;; Determines new coordinates for ?object when pushed toward ?side. Cases:
;;; 1) ?side = left
;;; 2) ?side = right
(<= (coordinates-after-nudge ?object left ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (- ?ox1 1 ?x1)
    (- ?ox2 1 ?x2))

(<= (coordinates-after-nudge ?object right ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (+ ?ox1 1 ?x1)
    (+ ?ox2 1 ?x2))

;;; Determines potential coordinates for ?object2 on ?object1's ?side. Cases:
;;; 1) ?side = left
;;; 2) ?side = right
;;; 3) ?side = top
(<= (coordinates-after-place ?object1 ?object2 left ?x1 ?y1 ?x2 ?y2)
    (true (object-location ?object1 ?x2 ?oy1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (support-for-place ?object1 ?object2 ?support left)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (- ?x2 ?width2 ?x1)
    (+ ?y1 ?height2 ?y2))

(<= (coordinates-after-place ?object1 ?object2 right ?x1 ?y1 ?x2 ?y2)
    (primitive-object ?support)
    (support-for-place ?object1 ?object2 ?support right)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (object-coordinates ?object1 ?ox1 ?oy1 ?x1 ?oy2)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (+ ?x1 ?width2 ?x2)
    (+ ?y1 ?height2 ?y2))

(<= (coordinates-after-place ?object1 ?object2 top ?x21 ?y21 ?x22 ?y22)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y21)
    (/ ?width1 2 ?tmp1)
    (/ ?width2 2 ?tmp2)
    (round ?tmp1 ?half-width1)
    (round ?tmp2 ?half-width2)
    (+ ?x11 ?half-width1 ?centerx)
    (- ?centerx ?half-width2 ?x21)
    (+ ?x21 ?width2 ?x22)
    (+ ?y21 ?height2 ?y22))

;;; Determine if ?object is crushed by the objects resting on it.
(<= (crushed ?object)
    (strength ?object ?strength)
    (supported-weight ?object ?weight)
    (> ?weight ?strength))

;;; A simple terinary operator: determine if ?test is greater than 0, 
;;; if so, then ?result (4th arg) takes value of ?then, otherwise ?result
;;; takes value of ?else.  
(<= (if-gt0-then-else ?test ?then ?else ?then)
    (number ?then)
    (number ?else)
    (> ?test 0))

(<= (if-gt0-then-else ?test ?then ?else ?else)
    (number ?then)
    (number ?else)
    (>= 0 ?test))
    
;;; Determine if ?object is a member of any compound
(<= (is-member-of-any-compound ?object)
    (true (member ?compound ?object)))

;;; Determine if ?object is a member of ?compound.  Strictly speaking, this
;;; should be unnecessary, but GDL requires that any variable used as an 
;;; argument in a recursive predicate must also be used in a non-recursive
;;; predicate, where (true ...) does not satisfy the requirement. This 
;;; rule is used to satisfy that requirement.
(<= (is-member-of-compound ?compound ?object)
    (true (member ?compound ?object)))

;;; Determine if ?object is a nested member of ?compound. Cases:
;;; 1) ?object is a direct member of ?compound
;;; 2) ?object is a nested member of ?compound
(<= (is-recursive-member-of-compound ?compound ?object)
    (true (member ?compound ?object)))

(<= (is-recursive-member-of-compound ?compound ?object)
    (is-member-of-compound ?compound ?intermediate)
    (is-recursive-member-of-compound ?intermediate ?object))

;;; Determine if ?object1 and ?object2 form an L- or T-shaped joint. 
(<= (joint ?object1 ?object2)
    (L-joint ?object1 ?object2))

(<= (joint ?object1 ?object2)
    (L-joint ?object2 ?object1))

(<= (joint ?object1 ?object2)
    (T-joint ?object1 ?object2))

(<= (joint ?object1 ?object2)
    (T-joint ?object2 ?object1))

;;; L-joint case 1:
;;; * ?object1 has same left x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 top)
    (wider ?object2 ?object1))

;;; L-joint case 2:
;;; * ?object1 has same right x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 right)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 top)
    (wider ?object2 ?object1))

;;; L-joint case 3:
;;; * ?object1 has same left x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object2 is on ?object1
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object2 ?object1))

;;; L-joint case 4:
;;; * ?object1 has same right x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object2 is on ?object1
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 right)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object2 ?object1))

;;; T-joint case 1:
;;; * ?object1 left x-coordinate is greater than ?object2 left x-coordinate
;;; * ?object1 right x-coordinate is less than ?object2 right x-coordinate
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height)
;;; * ?object2 is on ?object1
(<= (T-joint ?object1 ?object2)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?y22)
    (> ?x11 ?x21)
    (> ?x22 ?x12)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 bottom))

;;; T-joint case 2:
;;; * ?object1 left x-coordinate is greater than ?object2 left x-coordinate
;;; * ?object1 right x-coordinate is less than ?object2 right x-coordinate
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height)
;;; * ?object1 is on ?object2
(<= (T-joint ?object1 ?object2)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?y22)
    (> ?x11 ?x21)
    (> ?x22 ?x12)
    (object-orientation ?object1 vertical)
    (object-orientation ?object1 horizontal)
    (adjacent ?object1 ?object2 top))

;;; Determine if there exists some primitive object adjacent to 
;;; ?object1's ?side that is further left than ?object2
(<= (left-further-adjacent-primitive ?object1 ?object2 ?side)
    (adjacent ?object1 ?other ?side)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?obj2-x ?other-x))

;;; Determine if there exists some primitive object adjacent to 
;;; ?object1's ?side that is left of ?right and right of ?object2
(<= (left-further-adjacent-primitive-to-right ?object1 ?object2 ?right ?side)
    (adjacent ?object1 ?other ?side)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?right ?right-x ?right-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?other-x ?obj2-x)
    (> ?right-x ?other-x))

;;; Determine if ?leftmost is the leftmost primitive adjacent to 
;;; ?object's ?side.
(<= (leftmost-adjacent-primitive ?object ?leftmost ?side)
    (adjacent ?object ?leftmost ?side)
    (primitive-object ?leftmost)
    (not (left-further-adjacent-primitive ?object ?leftmost ?side)))

;;; Determine if ?leftmost is adjacent to ?object1's ?side and is
;;; the leftmost object to the right of ?object2.
(<= (leftmost-adjacent-primitive-to-right ?object1 ?object2 ?leftmost ?side)
    (adjacent ?object1 ?object2 ?side)
    (adjacent ?object1 ?leftmost ?side)
    (primitive-object ?leftmost)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?leftmost ?left-x ?left-y))
    (> ?left-x ?obj2-x)
    (not (left-further-adjacent-primitive-to-right ?object1 ?object2
						   ?leftmost ?side)))

;;; Determine if ?material is a type of brace.
(<= (material-is-brace-type ?material)
    (brace-type ?material ?braceable-material))

;;; Determine if ?material is a type of reinforcement
(<= (material-is-reinforcement-type ?material)
    (reinforcement-type ?material ?reinforceable-material))

;;; Determine if an object is movable (weight < WMAX).
(<= (movable ?object)
    (true (object-size ?object ?width ?height ?weight))
    (max-movable-weight ?max)
    (> ?max ?weight))

;;; Determine if ?var is numeric.
(<= (number ?var)
    (+ ?var 0 ?var))

;;; Determine the location of the lower-left and upper-right corners of ?object
(<= (object-coordinates ?object ?x1 ?y1 ?x2 ?y2)
    (true (object-location ?object ?x1 ?y1))
    (true (object-size ?object ?width ?height ?weight))
    (+ ?x1 ?width ?x2)
    (+ ?y1 ?height ?y2))

;;; Compute whether ?object intersects the region (?x11 ?y11 ?x12 ?y12).
;;; Cases:
;;; 1) ?object is primitive
;;; 2) ?object is compound
(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
    (primitive-object ?object)
    (object-coordinates ?object ?x21 ?y21 ?x22 ?y22)
    (> ?x22 ?x11)
    (> ?x12 ?x21)
    (> ?y22 ?y11)
    (> ?y12 ?y21))

(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
    (true (object ?object compound))
    (is-member-of-compound ?object ?member)
    (object-intersects-region ?member ?x11 ?y11 ?x12 ?y12))

;;; Determine the orientation of ?object
(<= (object-orientation ?object horizontal)
    (true (object-size ?object ?width ?height ?weight))
    (> ?width ?height))

(<= (object-orientation ?object vertical)
    (true (object-size ?object ?width ?height ?weight))
    (> ?height ?width))

;;; Deterime whether ?object is a primitive
(<= (primitive-object ?object)
    (true (object ?object ?type))
    (material-type ?type ?strength))

;;; Determine if any object ?intersecting intersects the given 
;;; rectangular region. ?intersecting must be different from ?object
(<= (region-intersected-by-object ?object ?x11 ?y11 ?x12 ?y12)
    (true (object ?object ?type))
    (object-intersects-region ?intersecting ?x11 ?y11 ?x12 ?y12)
    (distinct ?object ?intersecting))

;;; Determine if ?object is a primitive that has been reinforced.
(<= (reinforced-object ?object)
    (true (reinforced ?object ?reinforcement)))

;;; Determine if ?object1 and ?object2 are in the same compound
(<= (same-compound ?compound ?object1 ?object2)
    (true (member ?compound ?object1))
    (true (member ?compound ?object2)))

;;; Determine if ?object1 and ?object2 are of same primitive material
(<= (same-primitive-material ?material ?object1 ?object2)
    (true (object ?object1 ?material))
    (true (object ?object2 ?material))
    (distinct ?material compound))

;;; Computes the value of ?strength for primitive ?object. Cases:
;;; 1) ?object is not reinforced or braced
;;; 2) ?object is braced (as object1)
;;; 3) ?object is braced (as object2)
;;; 4) ?object is reinforced 
(<= (strength ?object ?strength)
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (not (braced-object ?object))
    (not (reinforced-object ?object))
    (material-type ?type ?material-strength)
    (* ?width ?material-strength ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (braced ?object ?object2 ?brace-type))
    (material-type ?obj-type ?material-strength)
    (material-type ?brace-type ?brace-strength)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?brace-strength ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (braced ?object1 ?object ?brace-type))
    (material-type ?obj-type ?material-strength)
    (material-type ?brace-type ?brace-strength)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?brace-strength ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (reinforced ?object ?reinforcement-type))
    (material-type ?obj-type ?material-strength)
    (material-type ?reinforcement-type ?reinforcement-strength)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?reinforcement-strength ?strength))

;;; Determine if ?support will touch ?object's ?side when ?object is nudged
(<= (support-for-nudge ?object ?support left)
    (object-coordinates ?object ?old-x1 ?y1 ?old-x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y)
    (+ ?old-x1 1 ?new-x1)
    (+ ?old-x2 1 ?new-x2)
    (> ?new-x2 ?sx1)
    (> ?sx2 ?new-x1))

(<= (support-for-nudge ?object ?support right)
    (object-coordinates ?object ?old-x1 ?y1 ?old-x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (+ ?old-x1 1 ?new-x1)
    (+ ?old-x2 1 ?new-x2)
    (> ?new-x2 ?sx1)
    (> ?sx2 ?new-x1))

;;; Determine if ?object2 will touch ?object1's ?side when placed on ?support.
(<= (support-for-place ?object1 ?object2 ?support left)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (- ?x1 ?width2 ?minx)
    (- ?y1 ?height2 ?miny)
    (> ?x1 ?sx1)
    (> ?sx2 ?minx)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2))

(<= (support-for-place ?object1 ?object2 ?support right)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (+ ?x2 ?width2 ?maxx)
    (- ?y1 ?height2 ?miny)
    (> ?maxx ?sx1)
    (> ?sx2 ?x2)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2))

;;; Calculate the amount of weight supported by ?object
(<= (supported-weight ?object ?weight)
    (leftmost-adjacent-primitive ?object ?leftmost top)
    (supported-weight-recursive ?object ?leftmost ?weight))

(<= (supported-weight ?object 0)
    (clear ?object top))

;;; Calculate the amount of weight supported by ?object from objects
;;; to the right of ?left (including ?left)
(<= (supported-weight-recursive ?object ?left ?weight)
    (leftmost-adjacent-primitive-to-right ?object ?left ?next top)
    (supported-weight-recursive ?object ?next ?wt)
    (weight-contribution ?left ?left-wt)
    (+ ?wt ?left-wt ?weight))

(<= (supported-weight-recursive ?object ?left ?weight)
    (primitive-object ?object)
    (primitive-object ?left)
    (not (adjacent-primitive-to-right ?object ?left top))
    (weight-contribution ?left ?weight))

;;; Determine if ?object1 is taller than ?object2
(<= (taller ?object1 ?object2)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (> ?height1 ?height2))

;;; Determine whether ?object is unsupported (nothing below it). This
;;; ignores objects of type GROUND, which are usually not supported.
(<= (unsupported ?object)
    (true (object ?object ?type))
    (distinct ?type ground)
    (not (adjacent-to-any-object ?object bottom)))

;;; Calculate the amount of weight that ?object contributes to each 
;;; object below it
(<= (weight-contribution ?object ?weight)
    (weight-of-stack ?object ?stack-wt)
    (adjacent-primitive-count ?object bottom ?number)
    (/ ?stack-wt ?number ?temp)
    (round ?temp ?weight))

;;; Calculate the total weight that ?object exerts collectively 
;;; on the objects below it
(<= (weight-of-stack ?object ?weight)
    (true (object-size ?object ?obj-wid ?obj-ht ?obj-wt))
    (supported-weight ?object ?supported-wt)
    (+ ?obj-wt ?supported-wt ?weight))

;;; Determine if ?object1 is wider than ?object2
(<= (wider ?object1 ?object2)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (> ?width1 ?width2))

;;; ---------------------------------------------------------------------------
;;; LEGAL AXIOMS

;;; Add ?object to ?compound.
(<= (legal agent (add-to-compound ?compound ?object))
    (can-add-to-compound ?compound ?object))

;;; Brace joint between ?object1 and ?object2 with ?brace.
(<= (legal agent (brace ?object1 ?object2 ?brace))
    (can-brace ?object1 ?object2 ?brace))

;;; Make a new compound object with ?object.
(<= (legal agent (make-new-compound ?object))
    (can-make-new-compound ?object))

;;; Move ?object one cell in the specified direnction
(<= (legal agent (nudge ?object ?side))
    (can-nudge ?object ?side))

;;; Move ?object2 adjacent to (touching) ?object1's ?side.
(<= (legal agent (place-adjacent ?object1 ?object2 ?side))
    (can-place-adjacent ?object1 ?object2 ?side))

;;; Reinforce ?object with ?reinforcement.
(<= (legal agent (reinforce ?object ?reinforcement))
    (can-reinforce ?object ?reinforcement))

;;; Rotate a primitive object.
(<= (legal agent (rotate ?object))
    (can-rotate ?object))


;;; ---------------------------------------------------------------------------
;;; NEXT AXIOMS

;;; Add object to existing compound: 
;;; 1) Declare object membership in compound
;;; 2) Update compound location
;;; 3) Update compound size
(<= (next (member ?compound ?object))
    (does agent (add-to-compound ?compound ?object)))

(<= (next (object-location ?compound ?x ?y))
    (does agent (add-to-compound ?compound ?object))
    (coordinates-after-add ?compound ?object ?x ?y ?x2 ?y2))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (add-to-compound ?compound ?object))
    (coordinates-after-add ?compound ?object ?x1 ?y1 ?x2 ?y2)
    (true (object-size ?compound ?old-width ?old-height ?old-weight))
    (true (object-size ?object ?obj-width ?obj-height ?obj-weight))
    (- ?x2 ?x1 ?width)
    (- ?y2 ?y1 ?height)
    (+ ?old-weight ?obj-weight ?weight))

;;; Brace the joint between two objects:
;;; 1) Declare the brace
;;; 2) Update compound weight for every compound of which both objects 
;;;    are a recursive member.
;;; 3) Update the primitive weight for both objects by 1/2 of brace weight
(<= (next (braced ?object1 ?object2 ?brace))
    (does agent (brace ?object1 ?object2 ?brace)))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace))
    (is-recursive-member-of-compound ?compound ?object1)
    (is-recursive-member-of-compound ?compound ?object2)
    (true (object-size ?compound ?width ?height ?c-weight))
    (true (object-size ?brace ?b-width ?b-height ?b-weight))
    (+ ?c-weight ?b-weight ?weight))

(<= (next (object-size ?object1 ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace))
    (true (object-size ?object1 ?width ?height ?obj-weight))
    (true (object-size ?brace ?b-width ?b-height ?b-weight))
    (+ ?obj-weight ?b-weight ?weight))

(<= (next (object-size ?object2 ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace))
    (true (object-size ?object2 ?width ?height ?obj-weight))
    (true (object-size ?brace ?b-width ?b-height ?b-weight))
    (+ ?obj-weight ?b-weight ?weight))

;;; Make a new compound object: 5 steps.
;;; 1) Declare the compound
;;; 2) Declare object membership in compound
;;; 3) Initialize compound location
;;; 4) Initialize compound size
;;; 5) Update current-identifier
(<= (next (object ?identifier compound))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?identifier)))

(<= (next (member ?identifier ?object))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?identifier)))

(<= (next (object-location ?identifier ?x ?y))
    (does agent (make-new-compound ?object))
    (true (object-location ?object ?x ?y))
    (true (current-identifier ?identifier)))

(<= (next (object-size ?identifier ?width ?height ?weight))
    (does agent (make-new-compound ?object))
    (true (object-size ?object ?width ?height ?weight))
    (true (current-identifier ?identifier)))

(<= (next (current-identifier ?id))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?old-id))
    (next-identifier ?old-id ?id))

;;; Move an object one cell in a given direction.
;;; 1) Update the location of the nudged object (primitive or compound)
;;; 2) If object is compound, then update all nested members
(<= (next (object-location ?object ?x ?y))
    (does agent (nudge ?object ?side))
    (coordinates-after-nudge ?object ?side ?x ?y ?x2 ?y2))

(<= (next (object-location ?object ?x ?y))
    (does agent (nudge ?compound ?side))
    (true (object ?compound compound))
    (is-recursive-member-of-compound ?compound ?object)
    (coordinates-after-nudge ?object ?side ?x ?y ?x2 ?y2))

;;; Move one object adjacent to another on a specified side:
;;; 1) Update the location of moved object (primitive or compound)
;;; 2) If object is compound, then update all nested members
(<= (next (object-location ?object2 ?x ?y))
    (does agent (place-adjacent ?object1 ?object2 ?side))
    (coordinates-after-place ?object1 ?object2 ?side ?x ?y ?x2 ?y2)
    (not (region-intersected-by-object ?object2 ?x ?y ?x2 ?y2)))

(<= (next (object-location ?member ?x ?y))
    (does agent (place-adjacent ?object1 ?object2 ?side))
    (true (object ?object2 compound))
    (true (object-location ?object2 ?old-x2 ?old-y2))
    (coordinates-after-place ?object1 ?object2 ?side ?new-x2 ?new-y2 ?x22 ?y22)
    (not (region-intersected-by-object ?object2 ?new-x2 ?new-y2 ?x22 ?y22))
    (- ?new-x2 ?old-x2 ?dist-x)
    (- ?new-y2 ?old-y2 ?dist-y)
    (is-recursive-member-of-compound ?object2 ?member)
    (true (object-location ?member ?old-x ?old-y))
    (+ ?old-x ?dist-x ?x)
    (+ ?old-y ?dist-y ?y))

;;; Reinforce primitive ?object with ?material: 
;;; 1) Declare reinforcement
;;; 2) Update object size (weight) of primitive ?object
;;; 3) Update object size (weight) of all compounds of which ?object 
;;;    is a recursive member.
(<= (next (reinforced ?object ?material))
    (does agent (reinforce ?object ?reinforcement))
    (true (object ?reinforcement ?material)))

(<= (next (object-size ?object ?width ?height ?weight))
    (does agent (reinforce ?object ?reinforcement))
    (true (object-size ?object ?width ?height ?obj-weight))
    (true (object-size ?reinforcement ?r-width ?r-height ?r-weight))
    (+ ?obj-weight ?r-weight ?weight))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (reinforce ?object ?reinforcement))
    (is-recursive-member-of-compound ?compound ?object)
    (true (object-size ?compound ?width ?height ?comp-weight))
    (true (object-size ?reinforcement ?r-width ?r-height ?r-weight))
    (+ ?comp-weight ?r-weight ?weight))

;;; Rotate a primitive object (switches width and height)
(<= (next (object-size ?object ?height ?width ?weight))
    (does agent (rotate ?object))
    (true (object-size ?object ?width ?height ?weight)))

;;; Advance time one step
(<= (next (time ?t))
    (true (time ?oldt))
    (+ ?oldt 1 ?t))


;;; ---------------------------------------------------------------------------
;;; FRAME AXIOMS (NEXT)

;;; Carry all brace declarations into next state
(<= (next (braced ?object1 ?object2 ?material))
    (true (braced ?object1 ?object2 ?material)))

;;; Carry current identifier into next state if the agent does not
;;; make a new compound in the current time step
(<= (next (current-identifier ?id))
    (true (current-identifier ?id))
    (not (action-make-new-compound agent)))

;;; Carry all membership declarations into next state
(<= (next (member ?compound ?object))
    (true (member ?compound ?object)))

;;; Most object declarations always get carried into the next state.
;;; However, primitive objects used as braces and reinforcements remain 
;;; only until used, then they "disappear".   Cases:
;;; 1) ?object is not a brace or reinforcement
;;; 2) ?object is a brace, but was not used in agent's action
;;; 3) ?object is a reinforcement, but was not used in agent's action
(<= (next (object ?object ?type))
    (true (object ?object ?type))
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type)))

(<= (next (object ?brace ?brace-type))
    (true (object ?brace ?brace-type))
    (brace-type ?brace-type ?brace-material)
    (not (action-brace agent ?brace)))

(<= (next (object ?reinforcement ?reinforcement-type))
    (true (object ?reinforcement ?reinforcement-type))
    (reinforcement-type ?reinforcement-type ?reinforcement-material)
    (not (action-reinforce agent ?reinforcement)))

;;; Most (object-location ...) declarations get carried into the next state,
;;; but some get modified, and some disappear.  Cases:
;;; 1) ?object is compound, nothing was added, and was not moved directly 
;;;    or indirectly (via larger compound)
;;; 2) ?object is primitive, is not a brace or reinforcement, and was not 
;;;    moved directly or indirectly (via compound)
;;; 3) ?object is a brace, and was not moved or used
;;; 4) ?object is a reinforcement, and was not moved or used
(<= (next (object-location ?object ?x ?y))
    (true (object ?object compound))
    (true (object-location ?object ?x ?y))
    (not (action-add-to-compound agent ?object))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (material-type ?type ?strength)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (brace-type ?type ?brace-material)
    (not (action-brace agent ?object))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (reinforcement-type ?type ?reinforcement-material)
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object))
    (not (action-reinforce agent ?object)))

;;; Most (object-size ...) declarations get carried into the next state,
;;; but some get modified, and some disappear.  Cases:
;;; 1) ?object is compound, has no subcomponent that was braced or reinforced,
;;;    and no new object was added
;;; 2) ?object is primitive, is not a brace or reinforcement, was not braced 
;;;    or reinforced, and was not rotated
;;; 3) ?object is a brace, and was not used or rotated
;;; 4) ?object is a reinforcement, and was not used or rotated
(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object compound))
    (true (object-size ?object ?width ?height ?weight))
    (not (action-add-to-compound agent ?object))
    (not (action-brace agent ?object))
    (not (action-reinforce agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (distinct ?type compound)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (action-brace agent ?object))
    (not (action-reinforce agent ?object))
    (not (action-rotate agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (brace-type ?type ?brace-material)
    (not (action-brace agent ?object))
    (not (action-rotate agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (reinforcement-type ?type ?reinforcement-material)
    (not (action-reinforce agent ?object))
    (not (action-rotate agent ?object)))

;;; Carry all reinforcement declarations into next state
(<= (next (reinforced ?object ?material))
    (true (reinforced ?object ?material)))

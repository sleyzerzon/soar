;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; micro-rogue gdl rule set
; tom hinrichs (northwestern u.), 
; sam wintermute (umich), & 
; david w. aha (nrl) 
; 2007 july 15
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; tl level ? 
; scenario: name ??
; - source problem: ??
; - target problem: ??
; debugger: "http://games.stanford.edu:5999/director/debugrawgame?"
;  
; environment: micro-rogue (a simplification of rogue)
; 
; description: a hero ("@") must traverse 1 or more levels of a
; 2-dimensional "dungeon" in search of the amulet of darpa ("!"), which
; he must bring to the dungeon's exit at level 1. the dungeon is 
; populated by monsters with varying capabilities,
; which can attack the hero. to combat them, the hero can
; read scrolls, quaff potions, and use weapons and armor, all found
; while traversing the dungeon. the hero carries a sack of up to n items, 
; where "n" is the sack's capacity. the hero, and all monsters,
; have an initial (maximum) health value. unlike monsters, the hero 
; regains 1 point of health for each turn he is not attacked. 
; 
; initial state: hero has an empty sack, the amulet is on level 1,
; as are a variety of objects and monsters.
;
; goal state: hero is at dungeon exit, with the amulet in the sack.
;
; visualizing maps:
; - <0,0> is top-left room square (".") below
; - <7,7> is the lower-right square
; - y axis increases from top to bottom (0 indexing)
; - x axis increases from left to right (0 indexing)
; - characters/objects can be in any room or corridor location,
;   and no two characters can be in the same location
; 
; map example and legend:
;    01234567     + = corner
;   +--------+    - = horizontal wall
;  0|p.......|    | = vertical wall
;  1|.w......|    . = a room location 
;  2|a.......|    # = a corridor location
;  3|@..s.*..|    @ = hero 
;  4+------#-+    a = armor, p = potion, s = scroll,
;  5|..!.s..p|    w = weapon, ! = amulet, * = gold
;  6|........|    < = staircase (down), > = staircase (up)
;  7|h......>|    k = kestral
;   +--------+    h = hobgoblin
;                 b = bat
;                 s = snake
;
;
; hero commands/actions: 
; - rest() 
;   - hero does not move or do anything else
; - move(dir): n, ne, e, se, s, sw, w, nw, up, down
;   - all but up and down can cause attacks on an adjacent monster
; - drop(item): drop item currently in the sack
;   - can only have one object per location on its floor
; - read(scroll): read scroll currently in the sack
; - quaff(potion): quaff potion currently in the sack
; - throw(arrow,dir): throws arrow in quiver currently in sack (direction dir)
;   - arrows travel instantaneously and as far as possible
;
; removed actions
; - remove(): removes armor currently being worn; remains in sack
;   - instead: you can only drop it, and only if the sack is full
; - wear(armor): wears armor that is currently in the sack
;   - instead: automatically wear armor when you walk over it, unless
;     the sack is full
; - wield(weapon): wields weapon that is currently in the sack
;   - instead: you'll wield it automatically when walking over it (unless
;     the sack is full), and in so doing drop whatever else you were 
;     wielding (if anything).
;
; properties of objects:
; - all objects (armor, amulet, potions, scrolls, weapons)
;   - are picked up automatically when moved on, if room in sack
;   - burden=1
;   - can be dropped
;   - gold: does not count towards burden
; - armor: defense values in [1,3]
;   - none: 1         ; no defense against monsterattacks
;   - ring mail: 2    ; first monster attack does not decrease health
;   - banded mail: 3  ; first 2 monster attacks do not decrease health
;   - counts towards burden while worn
; - potions
;   - speed (doubles speed for 5 turns)
;   - strength (increases attack value by 1 for 5 turns)
;   - invisibility (note: cannot implement blindness)
;   - deleted after use
; - scrolls:
;   - restore health (to maximum value)
;   - armor enhance (increases armor strength by 1, to max 3)
;   - sleep (forces "rest" command for 2 turns)
;   - deleted after use
; - weapon: offensive value in [1,3]
;   - none: 1 (melee only)
;   - mace: 2 (melee only)
;   - sword: 3 (melee only)
;   - bow: 1 (when throwing arrow)
;   - counts towards burden while wielded
;
; simplifications from the game of rogue:
; - no fog of war (all rooms are lit), doors, traps, food, wands, or rings
; - no levels of experience
; - can only throw an arrow when wielding a bow
;   - decrements number of arrows in a quiver
;   - assume arrow always hit a target if it is thrown towards target
;   - assume arrow has unlimited range (as in rogue)
;   - assume arrow otherwise disappears
; - sack
;   - max capacity: 5 
;   - items wielded or worn continue to count towards carrying burden
;   - a set of bow and arrows takes 1 item location in a sack
; - monsters: name (character) [initial health, damage when attacking, base speed]
;   - bat (b) [3, 1, 1]
;     - asleep unless/until attacked
;   - hobgoblin (h) [5, 2, 1] 
;     - toughest monster in game
;   - kestral (k) [2, 1, 2]
;     - moves at twice speed unless hitting
;   - snake (s) [4, 1, 0.5]
;     - moves at half speed
; 
; notes (things you'd notice in a detailed read of this gdl rule set)
;   0. turn-taking: the hero and the monsters rotate turns; they
;      do not take place simultaneously. 
;   1. the hero cannot share a location with a monster. 
;   2. when in the same room or corridor as a monster that is not asleep,
;      the monster will advance towards the hero. likewise, they
;      will advance towards an adjacent hero that is running away.
;   3. to use different dungeons per "run", we could use separate gdl rule sets,
;      differing only in the "init" clauses, for each new dungeon.
;
; recent updates (e.g., to fix bugs):
;   - replaced plus and lessthan with the appropriate built-in arithmetic
;   - eliminated diagonal movement and reduced map to 8x8
;     this should make the game more tractable for this years experiments
;     without significantly reducing functionality.
;
; known bugs:
;   - none yet
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; gdl state machine model components: 
;   1. role: players of the game
;   2. init: facts true in the initial state (initial state of fluents)
;   3. transitions: rules that can be used to determine what is and will 
;                   be true in the world
;   4. legal: legal moves for a <player,state> pair
;   5. goal: value of a (final) state for a player
;   6. terminal: terminal state
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1. role
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; meaning: this is a one-player game
(role hero)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2. init 
; da: 2 rooms, 1 monster & 3-4 objects per room
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; step: <stepnumber>
; meaning: player starts at step/state 1. game has finite length.
(init (step 1))

; hero, monster, & object locations: <object_name x y>
; room 1&2
(init (location hero 0 3))           ; our hero
(init (location armor1 0 2))
(init (location weapon1 1 1))
(init (location potion1 0 0))
(init (location snake1 3 3))         ; monster
(init (location gold 5 3))

; room 3
(init (location amulet 2 5))
(init (location scroll1 4 5))
(init (location potion2 7 5))
(init (location hobgoblin1 0 7))     ; monster
(init (location exit 7 7))           ; staircaseup

; health: <character initial_health>
(init (health hero 6))
(init (health hobgoblin1 5))
(init (health snake1 4))

; burden: <burdenamount>
; meaning: initially the sack is empty. 
(init (burden 0))

; quiversize <quiver> <size>
(init (quiversize 5))

; parity counters for half & quarter speed movement:
(init odd)
(init (slomo-time 1))

;----------------------------------------------------------------------
; type predicates
;----------------------------------------------------------------------

; room: <topleft_x topleft_y bottomright_x bottomright_y>
(room 0 0 7 3)    ; room 1&2 combined (top)
(room 0 5 7 7)    ; room 3 (lower left)

; corridor location: <x y>
(corridor 6 4) ; vertical corridor/doorway between r1&2 and r3

; sw- we need the same representation of walls as mm and escape,
; since we make lots of assumptions based on it to speed up search.
; this could potentially be derived from the above by a script on our end.

; room 1&2 combined
(init (blocked west 0 0))
(init (blocked west 0 1))
(init (blocked west 0 2))
(init (blocked west 0 3))
(init (blocked north 0 0))
(init (blocked north 1 0))
(init (blocked north 2 0))
(init (blocked north 3 0))
(init (blocked north 4 0))
(init (blocked north 5 0))
(init (blocked north 6 0))
(init (blocked north 7 0))
(init (blocked east 7 0))
(init (blocked east 7 1))
(init (blocked east 7 2))
(init (blocked east 7 3))
(init (blocked south 0 3))
(init (blocked south 1 3))
(init (blocked south 2 3))
(init (blocked south 3 3))
(init (blocked south 4 3))
(init (blocked south 5 3))
(init (blocked south 7 3))

; corridor between combined r1&2 and r3
(init (blocked west 6 4))
(init (blocked east 6 4))

; room 3
(init (blocked west 0 5))
(init (blocked west 0 6))
(init (blocked west 0 7))
(init (blocked north 0 5))
(init (blocked north 1 5))
(init (blocked north 2 5))
(init (blocked north 3 5))
(init (blocked north 4 5))
(init (blocked north 5 5))
(init (blocked north 7 5))
(init (blocked east 7 5))
(init (blocked east 7 6))
(init (blocked east 7 7))
(init (blocked south 0 7))
(init (blocked south 1 7))
(init (blocked south 2 7))
(init (blocked south 3 7))
(init (blocked south 4 7))
(init (blocked south 5 7))
(init (blocked south 6 7))
(init (blocked south 7 7))

; meaning: specific monsters (and their types) in *this* dungeon
(monster hobgoblin1 hobgoblin)
(monster snake1 snake)

; meaning: items in this dungeon (identified here, defined later)
; note: the bow includes the quiver and arrows
(armor armor1 bandedmail)
(weapon weapon1 mace)
(potion potion1 speed)
(potion potion2 strength)
(scroll scroll1 armorenhance)

; an item is anything you can pick up.
(item armor1)
(item weapon1)
(item potion1)
(item potion2)
(item scroll1)
(item amulet)
(item gold)

;----------------------------------------------------------------------
; constants
;----------------------------------------------------------------------

; meaning: sack can contain at most this number of items
(maxburden 5)

; meaning: maximum health a hero can ever attain
(maxhealth hero 6)

; meaning: the maximum defined time-step (t = 30)
(maxtime 30)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 3. transitions: rules used to reason about states
;    - specifies the dynamics of fluents
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;----------------------------------------------------------------------
; 3.1 location updates
;----------------------------------------------------------------------

; meaning: blocked locations are persistent
(<= (next (blocked ?dir ?x ?y))
    (true (blocked ?dir ?x ?y)))

; meaning: updates hero location 
(<= (next (location hero ?x ?y))
    (nextherolocation ?x ?y))                 ; action 

; meaning: updates monster location
(<= (next (location ?monster ?x ?y))
    (monster ?monster ?monster-type)
    (true (health ?monster ?health))
    (> ?health 0)                             ; built-in
    (nextmonsterlocation ?monster ?x ?y))     ; action 

; meaning: the exit does not move
(<= (next (location exit ?x ?y))
    (true (location exit ?x ?y)))

; meaning: the staircase does not move
(<= (next (location staircasedown ?x ?y))
    (true (location staircasedown ?x ?y)))

; meaning: items remain on the ground until they are picked up
(<= (next (location ?item ?x ?y))
    (item ?item)
    (true (location ?item ?x ?y))
    (not (pickedup ?item)))        ; object-interaction

; meaning: dropped objects are placed at the hero's current location
(<= (next (location ?item ?x ?y))
    (does hero (drop ?item))
    (true (location hero ?x ?y)))

; da (7/13): must also drop a weapon if picking up another
(<= (next (location ?oldweapon ?x ?y))
    (changeweapon ?oldweapon)            ; da: we pickedup another!
    (true (location hero ?x ?y)))

;----------------------------------------------------------------------
; 3.2 health updates for hero
;     - if the hero is attacked, his health is decreased by difference
;       of 1 + (monster's attack value - hero defense value)
;     - regains health if not attacked! (rate is described below)
;     - health goes to max if hero reads restorehealth scroll
;----------------------------------------------------------------------

; meaning: hero incurs damage
; note: totalmonsterdamage maxes out at hero's current health, so
; we shouldn't need to check for negative health here.
; da: if the restore health scroll is simultaneously read, and
; monster damage is nonzero, then the scroll has no effect!
(<= (next (health hero ?hpnew))
    (totalmonsterdamage ?hitpointslost)
    (> ?hitpointslost 0)
    (true (health hero ?hpold))
    (minus ?hpold ?hitpointslost ?hpnew))

; meaning: hero heals 1 hp when not attacked.
; - we'll probably slow this recovery rate in a later version
(<= (next (health hero ?hpnew))
    (totalmonsterdamage 0)
    (not (healthrestoredbyscroll))
    (true (health hero ?hpold))
    (maxhealth hero ?maxhealth)
    (> ?maxhealth ?hpold)
    (plus ?hpold 1 ?hpnew))

; meaning: hero already at maxhealth and not attacked
(<= (next (health hero ?maxhealth))
    (totalmonsterdamage 0)
    (maxhealth hero ?maxhealth)
    (true (health hero ?maxhealth)))

; meaning: hero read a restorehealth scroll to regain maximum health
(<= (next (health hero ?maxhealth))
    (totalmonsterdamage 0)
    (healthrestoredbyscroll)
    (maxhealth hero ?maxhealth))

;----------------------------------------------------------------------
; 3.3 health updates for monsters
;     - if attacked by hero, health decreases by attack value of hero's 
;       wielded weapon!
;     - simplification: only arrows can be thrown, and only when hero
;       wields a bow
;----------------------------------------------------------------------

; meaning: hero kills the monster (melee)
(<= (next (health ?monster 0))
    (monster ?monster ?monster-type)
    (monsterattacked ?monster)
    (true (health ?monster ?hpold))
    (herooffense ?wdamage)
    (>= ?wdamage ?hpold))

; meaning: hero hurts the monster (melee)
(<= (next (health ?monster ?hpnew))
    (monster ?monster ?monster-type)
    (monsterattacked ?monster)
    (true (health ?monster ?hpold))
    (herooffense ?wdamage)
    (> ?hpold ?wdamage)
    (minus ?hpold ?wdamage ?hpnew))

; meaning: hero kills the monster (by throwing an arrow)
; hardcoding the damage value of arrows: 2
(<= (next (health ?monster 0))
    (monster ?monster ?monster-type)
    (hitbyarrow ?monster)
    (true (health ?monster ?hpold))
    (>= 2 ?hpold))

; meaning: hero hurts the monster (by throwing an arrow)
; hardcoding the damage value of arrows: 2
(<= (next (health ?monster ?hpnew))
    (monster ?monster ?monster-type)
    (true (health ?monster ?hpold))
    (> ?hpold 2)
    (hitbyarrow ?monster)
    (minus ?hpold 2 ?hpnew))

; meaning: unattacked monster's health is unchanged
(<= (next (health ?monster ?hp))
    (monster ?monster ?monster-type)
    (not (monsterattacked ?monster))
    (not (hitbyarrow ?monster))
    (true (health ?monster ?hp)))

;----------------------------------------------------------------------
; 3.4 burden-related updates
;     - sack, armor, and weaponry
;----------------------------------------------------------------------

;--------------------------------------------------
; 3.4.1: burden maintenance relations
;--------------------------------------------------

; meaning: items remain in hero's sack when picked up
(<= (next (carrying ?item))
    (item ?item)
    (pickedup ?item))                  ; object-interaction

; meaning: items in sack stay in sack unless dropped
(<= (next (carrying ?item))
    (true (carrying ?item))
    (not (changeweapon ?item))         ; it's not a weapon we're auto-dropping
    (not (decrementsburden ?item)))

; meaning: maintain size of burden if it's not changed
(<= (next (burden ?burden))
    (not burdenchanged)
    (true (burden ?burden)))

; meaning: increment burden by picking up an item
; note: we don't have to check maxburden here, because it's checked in pickedup.
(<= (next (burden ?newburden))
    (pickedup ?item)                   ; object-interaction
    (distinct ?item gold)
    (not (weaponchange ?item))         ; da (7/13): burden doesn't change when changing weapons
    (true (burden ?oldburden))
    (succ ?oldburden ?newburden))      ; arithmetic

; meaning: decrement burden by dropping an item or using a scroll or potion
(<= (next (burden ?newburden))
    (decrementsburden ?item)
    (true (burden ?oldburden))
    (succ ?newburden ?oldburden))      ; arithmetic

;--------------------------------------------------
; 3.4.2 quiver size (i.e., # arrows in it)
;--------------------------------------------------

; meaning: quiver size doesn't change when no arrows are thrown.
; note: we don't have to check here for wielding the bow or 
; carrying it.  if that's not true, then hero can't legally 
; throw an arrow.
; also: don't reify the quiver apart from the bow.  it's a 
; package, like a clip of ammo in a gun.
(<= (next (quiversize ?oldsize))
    (not arrowthrown)
    (true (quiversize ?oldsize)))

; meaning: quiver size decreases when throwing arrow w/ a bow
; - ensures quiver contains at least one arrow
(<= (next (quiversize ?newsize))
    (does hero (throw arrow ?dir))
    (true (quiversize ?oldsize))
    (minus ?oldsize 1 ?newsize))           ; arithmetic

;--------------------------------------------------
; 3.4.3: armor-wearing relations
; -- da (7/13): only 1 armor max in game!!!
;--------------------------------------------------

; meaning: hero continues wearing armor until it is dropped
; da: this changed on 7/13
(<= (next (wearing ?item))
    (true (wearing ?item))
    (not (does hero (drop ?item))))  ; note: drops can occur only if sack is full

; meaning: hero is wearing armor that is newly picked up
; da: this changed on 7/13
(<= (next (wearing ?armor))
    (armor ?armor ?armor-type)
    (pickedup ?armor))

;--------------------------------------------------
; 3.4.4: weapon-wielding relations
;--------------------------------------------------

; meaning: continue wielding a weapon wielded unless exchanging or dropping
(<= (next (wielding ?weapon))
    (true (wielding ?weapon))
    (not (changeweapon ?weapon))      ; da: def'n of changeweapon changed 7/13
    (not (does hero (drop ?weapon)))) ; note: drops can occur only if sack is full

; meaning: wield a weapon automatically if it is picked up 
; note: any currently-wielded weapon would be dropped (elsewhere)
; da: this changed on 7/13
(<= (next (wielding ?weapon))
    (weapon ?weapon ?weapon-type)
    (pickedup ?weapon))

;--------------------------------------------------
; 3.4.5: sleep relations
;--------------------------------------------------

; meaning: reading the sleep scroll induces 2 turns of sleep
(<= (next (asleep hero 2))
    (does hero (read ?scroll))
    (scroll ?scroll sleepinduce))

; meaning: sleep decrement
(<= (next (asleep hero ?n))
    (true (asleep hero ?old-n))
    (distinct ?old-n 1)
    (minus ?old-n 1 ?n))

; meaning: let sleeping monsters sleep
(<= (next (asleep ?monster ?n))
    (monster ?monster ?monster-type)
    (true (asleep ?monster ?n))
    (true (health ?monster ?hp))
    (distinct ?hp 0)
    (not (provoked ?monster))) ; in this case, attacked or hit with an arrow

;--------------------------------------------------
; 3.4.6: visibility
;--------------------------------------------------

;;; meaning: hero is invisible to monsters for the next 5 turns
(<= (next (invisible hero 5))
    (does hero (quaff ?potion))
    (potion ?potion invisibility))

(<= (next (invisible hero ?n))
    (true (invisible hero ?old-n))
    (distinct ?old-n 1)
    (minus ?old-n 1 ?n))

;--------------------------------------------------
; 3.4.7: enhanced speed, strength, armor
;--------------------------------------------------

; meaning: hero's speed is enhanced by 1 for 5 turns
(<= (next (enhancedspeed hero 5))
    (does hero (quaff ?potion))
    (potion ?potion speed))

(<= (next (enhancedspeed hero ?n))
    (true (enhancedspeed hero ?old-n))
    (distinct ?old-n 1)
    (minus ?old-n 1 ?n))

; meaning: hero's attack strength is enhanced by 1 for 5 turns
(<= (next (enhancedstrength hero 5))
    (does hero (quaff ?potion))
    (potion ?potion strength))

(<= (next (enhancedstrength hero ?n))
    (true (enhancedstrength hero ?old-n))
    (distinct ?old-n 1)
    (minus ?old-n 1 ?n))

(<= (next (enhancedarmor hero 5))
    (does hero (read ?scroll)) 
    (scroll ?scroll armorenhance)
    (true (wearing ?armor))  ; you have to be wearing armor first
    (armor ?armor ?armor-type)
    (armorstrength ?armor-type ?amt)
    (>= 3 ?amt))

(<= (next (enhancedarmor hero ?n))
    (true (enhancedarmor hero ?old-n))
    (distinct ?old-n 1)
    (minus ?old-n 1 ?n))

;---------------------------------------------------------------------------
;;; 3.5 standard gdl support rule
;---------------------------------------------------------------------------

; meaning: time advances in one step increments
(<= (next (step ?next))
    (true (step ?current))
    (succ ?current ?next))          ; arithmetic

;---------------------------------------------------------------------------
;;; 3.6 movement speed rules
;---------------------------------------------------------------------------

; sw: changed to only update the parity counters when they are being used.
; this isn't a useless groundings problem, but it actually breaks our spatial assumptions, since
; if we see a game state change, the agent can use no knowledge about what directions are redundant
; to move in. so we need to minimize useless game state changes.

(<= (monsterismoving)
    (provoked ?monster))

(<= (slomomonstermoving ?monster)
    (currentlyenhancedspeed hero)
    (provoked ?monster)
    (monster ?monster ?monster-type)
    (monsterspeed ?monster-type .5))

; parity counter for 1/2 speed movement
(<= (next odd)
    (monsterismoving)
    (true even))
(<= (next even)
    (monsterismoving)
    (true odd))
(<= (next even)
    (not (monsterismoving))
    (true even))
(<= (next odd)
    (not (monsterismoving))
    (true odd))

; meaning: slow-motion or "matrix" time counter for sluggish snakes
(<= (next (slomo-time 1))
    (slomomonstermoving ?monster)
    (true (slomo-time 4)))
(<= (next (slomo-time 2))
    (slomomonstermoving ?monster)
    (true (slomo-time 1)))
(<= (next (slomo-time 3))
    (slomomonstermoving ?monster)
    (true (slomo-time 2)))
(<= (next (slomo-time 4))
    (slomomonstermoving ?monster)
    (true (slomo-time 3)))

(<= (next (slomo-time ?t))
    (true (slomo-time ?t))
    (not (currentlyenhancedspeed hero)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 4. legal: specifies legal moves for players
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; meaning: the hero can rest (and do nothing) at any time
(legal hero (rest))

; meaning: the hero may move anywhere within rooms and corridors
; - but: moving to a monster's location is an attack, not a move!
(<= (legal hero (move ?dir))
    (not (currentlyasleep hero))
    (true (location hero ?xold ?yold))
    (direction ?dir)                        ; generic spatial
    (nextcell ?dir ?xold ?yold ?xnew ?ynew) ; movement
    (traversible ?xnew ?ynew))              ; generic spatial

; meaning: hero can drop an item (being carried)
; da: now, only allowed if the sack is full!
(<= (legal hero (drop ?item))
    (true (burden ?max-burden))             ; new constraint (7/13)
    (maxburden ?max-burden)                 ; new constraint (7/13)
    (not (currentlyasleep hero))
    (true (carrying ?item)))  

; meaning: hero can read a scroll (being carried)
(<= (legal hero (read ?scroll))
    (not (currentlyasleep hero))
    (true (carrying ?scroll))
    (scroll ?scroll ?scrolltype))            ; init

; meaning: hero can quaff a potion (being carried)
(<= (legal hero (quaff ?potion))
    (not (currentlyasleep hero))
    (true (carrying ?potion))
    (potion ?potion ?potiontype))            ; init

; meaning: hero can throw an arrow (if carrying a non-empty quiver)
(<= (legal hero (throw arrow ?dir))
    (not (currentlyasleep hero))
    (true (wielding ?weapon))
    (weapon ?weapon bow)                    ; init
    (true (quiversize ?numarrows))
    (> ?numarrows 0)
    (direction ?dir))                       ; generic spatial

; meaning: hero can wear armor (being carried)
; da: deleted on 7/13
; (<= (legal hero (wear ?item))
;     (not (currentlyasleep hero))
;     (true (carrying ?item))       
;     (not (armored hero))  
;     (armor ?item ?itemtype))

; meaning: hero can remove armor (currently being worn)
; da: deleted on 7/13
; (<= (legal hero (remove ?item))
;     (not (currentlyasleep hero))
;     (true (wearing ?item)))

; meaning: hero can wield a weapon (being carried)
; da: deleted on 7/13
; (<= (legal hero (wield ?weapon))
;     (not (currentlyasleep hero))
;     (true (carrying ?weapon))
;    (weapon ?weapon ?weapon-type))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 5. goal: value of a (final) state for a player
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; meaning: hero receives 100 points if he escapes with the amulet
(<= (goal hero 100)
    (not (true (health hero 0)))    ; endgame
    (true (carrying amulet))    
    atexit)                         ; endgame

; meaning: 75 points if hero has obtained the amulet but not exited
(<= (goal hero 75)
    (not (true (health hero 0)))    ; endgame
    (true (carrying amulet))      
    (not atexit))                   ; endgame

; meaning: 50 points if hero has obtained gold but not exited
(<= (goal hero 50)
    (not (true (health hero 0)))    ; endgame
    (not (true (carrying amulet)))
    (true (carrying gold))
    (not atexit))                   ; endgame

; meaning: 30 points if you just survive
(<= (goal hero 30)
    (not (true (health hero 0)))    ; endgame
    (not (true (carrying amulet)))
    (not (true (carrying gold)))
    (not atexit))                   ; endgame

; meaning: the hero receives 0 points if he is killed
(<= (goal hero 0)
    (true (health hero 0)))         ; endgame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 6. terminal: terminal state
;    - specifies the conditions under which the game has ended
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; meaning: the game is over if the hero is killed
(<= terminal
    (true (health hero 0)))         ; endgame

; meaning: the game is over if time runs out
(<= terminal
    (true (step ?t))
    (maxtime ?t))                   ; endgame

; meaning: the game is over if the hero has escaped with the amulet
(<= terminal
    (true (carrying amulet))      
    atexit)                         ; endgame

;=============================================================================
; supporting (low-level) relations
;=============================================================================

;----------------------------------------------------------------------
; battle relations
;----------------------------------------------------------------------

; meaning: the amount of damage incurred by monster attacks (on possibly
; two fronts).  this should return 0 if hero is not attacked and should
; max out at hero's current health.
(<= (totalmonsterdamage 0)
    (nextherolocation ?x ?y)
    (not (attackedbysomemonster ?x ?y)))

; meaning: first monster damage
(<= (totalmonsterdamage ?damage)
    (nextherolocation ?x ?y)
    (monster ?monster ?monster-type)
    (attackedbymonster ?monster ?x ?y)
    (monsterstrength ?monster-type ?strength)
    (totalmonsterdamage1 ?monster ?strength ?x ?y ?damage))

; meaning: no second monster attack
(<= (totalmonsterdamage1 ?monster ?strength ?x ?y ?damage)
    (nextherolocation ?x ?y) ; sw added
    (monster ?monster ?monster-type) ; sw added
    (attackedbymonster ?monster ?x ?y) ; sw added   ****
    (not (attackedby2ndmonster ?monster ?x ?y))
    (amountofmonsterdamage ?strength ?d1)
    (true (health hero ?hp))
    (min ?d1 ?hp ?damage))

; meaning: check second monster damage
(<= (totalmonsterdamage1 ?monster1 ?strength ?x ?y ?damage)
    (totalmonsterdamage2 ?monster1 ?strength ?x ?y ?damage))

; meaning: combined damage from two monsters
(<= (totalmonsterdamage2 ?monster1 ?strength1 ?x ?y ?damage)
    (nextherolocation ?x ?y) ; sw added
    (monster ?monster2 ?monster-type)
    (monster ?monster1 ?monster-type) ; sw added   ****
    (distinct ?monster2 ?monster1)
    (attackedbymonster ?monster1 ?x ?y) ; sw added   ****
    (attackedbymonster ?monster2 ?x ?y)
    (monsterstrength ?monster-type ?strength1) ; sw added  ****
    (monsterstrength ?monster-type ?strength2)
    (plus ?strength1 ?strength2 ?strength)
    (amountofmonsterdamage ?strength ?combined-damage)
    (true (health hero ?hp))
    (min ?combined-damage ?hp ?damage))

; meaning: there exists some monster that attacks hero at ?x ?y
(<= (attackedbysomemonster ?x ?y)
    (monster ?monster ?monster-type)
    (attackedbymonster ?monster ?x ?y))

; meaning: monster attacks hero when provoked and within one spot of 
; hero's next location
(<= (attackedbymonster ?monster ?x2 ?y2)
    (provoked ?monster)                            ; generic monster
    (nextherolocation ?x2 ?y2) ; sw added  ****
    (true (location ?monster ?x1 ?y1))
    (adjacent ?x1 ?y1 ?x2 ?y2))                    ; generic spatial

; meaning: monster1 and monster2 both attack simultaneously.
(<= (attackedby2ndmonster ?monster1 ?x ?y)
    (monster ?monster2 ?monster-type)
    (monster ?monster1 ?monster-type) ; sw   ****
    (distinct ?monster2 ?monster1)
    (attackedbymonster ?monster2 ?x ?y)
    (attackedbymonster ?monster1 ?x ?y))

; meaning: no damage if monster's attack is less than defense
; offensive-strength is the combined strength of attacking monsters.
; - open to debate
(<= (amountofmonsterdamage ?offensive-strength 0)
    (attackedbymonster ?monster ?x ?y)                  ; sw   ****
    (monster ?monster ?monster-type)                    ; sw   ****
    (monsterstrength ?monster-type ?offensive-strength) ; sw   ****
    (herodefense ?defense)                          ; battle
    (> ?defense ?offensive-strength)) ; sw ****: changed from >=, bug? would imply that no damage occurs if offense == defense..

; meaning: attacks whose value is equal to or greater than armor value
; - open to debate (i.e., attack value is 1 + (offense - defense))
(<= (amountofmonsterdamage ?offensive-strength ?hitpointslost)
    (attackedbymonster ?monster ?x ?y)                  ; sw   ****
    (monster ?monster ?monster-type)                    ; sw   ****
    (monsterstrength ?monster-type ?offensive-strength) ; sw   ****
    (herodefense ?defense)                          ; battle
    (>= ?offensive-strength ?defense) ; sw: this seems necessary
    (minus  ?offensive-strength ?defense ?diff)         ; arithmetic
    (plus ?diff 1 ?hitpointslost))                     ; arithmetic

; meaning: the current defensive strength of armor worn (if any)
(<= (herodefense 1)
    (not (armored hero)))

(<= (herodefense ?defense)
    (not (currentlyenhancedarmor hero))
    (true (wearing ?item))
    (armor ?item ?armor-type)
    (armorstrength ?armor-type ?defense))

(<= (herodefense ?defense)
    (int ?n)         ; ?n is how many turns it will remain in effect (0 - 5)
    (true (enhancedarmor hero ?n))
    (true (wearing ?item))
    (armor ?item ?armor-type)
    (armorstrength ?armor-type ?base-defense)
    (plus ?base-defense 1 ?defense))

; meaning: the current offense strength of weapons wielded (if any)
(<= (herooffense 1)
    (not (armed hero)))

(<= (herooffense ?offense)
    (not (currentlyenhancedstrength hero))
    (true (wielding ?weapon))
    (weapon ?weapon ?weapon-type)                  ; init
    (weaponstrength ?weapon-type ?offense))        ; generic weapon

(<= (herooffense ?offense)
    (currentlyenhancedstrength hero)
    (true (wielding ?weapon))
    (weapon ?weapon ?weapon-type)                  ; init
    (weaponstrength ?weapon-type ?offense))        ; generic weapon sw: fixed variable name 

; meaning: hero attacks the monster
(<= (monsterattacked ?monster)
    (true (location hero ?x1 ?y1))
    (true (location ?monster ?x2 ?y2))
    (monster ?monster ?monster-type)
    (adjacent ?x1 ?y1 ?x2 ?y2)
    (does hero (move ?dir))
    (nextcell ?dir ?x1 ?y1 ?x2 ?y2))

;----------------------------------------------------------------------
; movement relations
;----------------------------------------------------------------------

;;; monster moves n steps toward hero 

; meaning: exhausted our travel distance
(<= (nstepstowardshero 0 ?startx ?starty ?startx ?starty)
    (cellnearmonster ?startx ?starty)) ; sw 

(<= (nstepstowardshero 1 ?startx ?starty ?finalx ?finaly)
    (cellnearmonster ?startx ?starty) ; sw 
    (cellnearmonster ?finalx ?finaly) ; sw 
    (singlesteptowardshero ?startx ?starty ?x ?y)
    (nstepstowardshero 0 ?x ?y ?finalx ?finaly))

(<= (nstepstowardshero 2 ?startx ?starty ?finalx ?finaly)
    (cellnearmonster ?startx ?starty) ; sw 
    (cellnearmonster ?finalx ?finaly) ; sw 
    (singlesteptowardshero ?startx ?starty ?x2 ?y2)
    (nstepstowardshero 1 ?x2 ?y2 ?finalx ?finaly))

; meaning: take one step toward destination only if you won't run into hero.
(<= (singlesteptowardshero ?startx ?starty ?nextx ?nexty)
    (onesteptowardshero ?startx ?starty ?nextx ?nexty)
    (traversible ?nextx ?nexty)
    (nextherolocation ?herox ?heroy)
    (not (samelocation ?nextx ?nexty ?herox ?heroy)))

; meaning: stay put and attack the hero.
(<= (singlesteptowardshero ?startx ?starty ?startx ?starty)
    (nextherolocation ?herox ?heroy)
    (onesteptowardshero ?startx ?starty ?herox ?heroy))

;;; rather than having horizontal or vertical movement preferences
;;; as in mummymaze, we alternate each turn.

; meaning: move one step (horizontally or vertically) towards destination
(<= (onesteptowardshero ?x1 ?y1 ?x3 ?y1)  ; go west
    (nextherolocation ?x2 ?y1)
    (cellnearmonster ?x1 ?y1) 
    (> ?x1 ?x2)
    (minus ?x1 1 ?x3))

(<= (onesteptowardshero ?x1 ?y1 ?x3 ?y1)  ; go east
    (nextherolocation ?x2 ?y1)
    (cellnearmonster ?x1 ?y1) 
    (> ?x2 ?x1)
    (plus ?x1 1 ?x3))

(<= (onesteptowardshero ?x1 ?y1 ?x1 ?y3)  ; go north
    (nextherolocation ?x1 ?y2)
    (cellnearmonster ?x1 ?y1) 
    (> ?y1 ?y2)
    (minus ?y1 1 ?y3))

(<= (onesteptowardshero ?x1 ?y1 ?x1 ?y3)  ; go south
    (nextherolocation ?x1 ?y2)
    (cellnearmonster ?x1 ?y1) 
    (> ?y2 ?y1)
    (plus ?y1 1 ?y3))

(<= (onesteptowardshero ?x1 ?y1 ?x3 ?y1)    ; go west
    (nextherolocation ?x2 ?y2)
    (cellnearmonster ?x1 ?y1) 
    (> ?x1 ?x2)
    (distinct ?y1 ?y2)
    (true odd)
    (minus ?x1 1 ?x3))

(<= (onesteptowardshero ?x1 ?y1 ?x3 ?y1)    ; go east
    (nextherolocation ?x2 ?y2)
    (cellnearmonster ?x1 ?y1) 
    (> ?x2 ?x1)
    (distinct ?y1 ?y2)
    (true odd)
    (plus ?x1 1 ?x3))

(<= (onesteptowardshero ?x1 ?y1 ?x1 ?y3)  ; go north
    (nextherolocation ?x2 ?y2)
    (cellnearmonster ?x1 ?y1) 
    (> ?y1 ?y2)
    (distinct ?x1 ?x2)
    (true even)
    (minus ?y1 1 ?y3))

(<= (onesteptowardshero ?x1 ?y1 ?x1 ?y3)  ; go south
    (nextherolocation ?x2 ?y2)
    (cellnearmonster ?x1 ?y1) 
    (> ?y2 ?y1)
    (distinct ?x1 ?x2)
    (true even)
    (plus ?y1 1 ?y3))

; meaning: direction-based relationships between coordinates
; - read: one cell in ?direction of ?x1 ?y1 is ?x2 ?y2
; i had hoped to get rid of this, but it's used in determining
; legal moves.
(<= (nextcell north ?x ?y1 ?x ?y2)
    (int ?x)
    (minus ?y1 1 ?y2))
(<= (nextcell south ?x ?y1 ?x ?y2)
    (int ?x)
    (plus ?y1 1 ?y2))
(<= (nextcell east ?x1 ?y ?x2 ?y)
    (int ?y)
    (plus ?x1 1 ?x2))
(<= (nextcell west ?x1 ?y ?x2 ?y)
    (int ?y)
    (minus ?x1 1 ?x2))

;----------------------------------------------------------------------
; generic spatial relations
;----------------------------------------------------------------------

; roomlocation: <x y>  (derived from "room")
(<= (roomlocation ?x ?y)  
    (room ?tlx ?tly ?brx ?bry)
    (between ?tlx ?x ?brx)        ; generic spatial
    (between ?tly ?y ?bry))       ; generic spatial

; meaning: ?a <= ?b <= ?c (note: permits them all to be equal)
(<= (between ?a ?b ?c)
    (>= ?b ?a)                    ; arithmetic
    (>= ?c ?b)
    (int ?a)
    (int ?b)
    (int ?c))                   ; arithmetic

; meaning: <x,y> can be traversed by a character (or hold an item)
; we actually don't need this for monster movement because so long
; as they only pursue hero within a room, they'll never try to 
; go through walls or cut corners.  if we change monster behavior
; or have non-rectangular rooms, then onesteptowards will have to
; check.
(<= (traversible ?x ?y)
    (roomlocation ?x ?y))   ; generic spatial
(<= (traversible ?x ?y)
    (corridor ?x ?y))     ; generic spatial

; meaning: eight possible directions of movement
; do we add up and down sometime?  
; -- da: not for y2 evals!
(direction north)
(direction south)
(direction east)
(direction west)

(verticaldir north)
(verticaldir south)
(horizontaldir east)
(horizontaldir west)

; meaning: same location
(<= (samelocation ?x ?y ?x ?y) ; sw -- must be ints
    (int ?x)
    (int ?y))

; meaning: adjacent locations
(<= (adjacent ?x ?y1 ?x ?y2)
    (int ?x)      ; sw
    (diff ?y1 ?y2 1))
(<= (adjacent ?x1 ?y ?x2 ?y)
    (int ?y)      ; sw
    (diff ?x1 ?x2 1))
(<= (adjacent ?x1 ?y1 ?x2 ?y2)
    (diff ?x1 ?x2 1)
    (diff ?y1 ?y2 1))

;----------------------------------------------------------------------
; generic monster relations
;----------------------------------------------------------------------

(initialhealth   bat 3)
(monsterstrength bat 1)
(monsterspeed    bat 1)

(initialhealth hobgoblin 5)
(monsterstrength hobgoblin 2)
(monsterspeed hobgoblin 1)

(initialhealth kestral 2)
(monsterstrength kestral 1)
(monsterspeed kestral 2)

(initialhealth snake 4)
(monsterstrength snake 1)
(monsterspeed snake 0.5)

(speednumber 0.5) ; sw: need these so we can ground potential speeds.
(speednumber 1)
(speednumber 2)

; meaning: monsters attack when in the same room as the hero.
; if they're asleep, they wake up when hero attacks them or
; throws an arrow at them.
(<= (provoked ?monster)
    (monster ?monster ?monster-type)
    (not (currentlyasleep ?monster))
    (true (location ?monster ?x ?y))
    (room ?lx ?ty ?rx ?by)
    (between ?lx  ?x ?rx)
    (between ?ty ?y ?by)
    (nextherolocation ?hx ?hy)
    (between ?lx  ?hx ?rx)
    (between ?ty ?hy ?by))

(<= (provoked ?monster)
    (monster ?monster ?monster-type)
    (true (asleep ?monster ?n))
    (monsterattacked ?monster))

(<= (provoked ?monster)
    (monster ?monster ?monster-type)
    (true (asleep ?monster ?n))
    (hitbyarrow ?monster))

;----------------------------------------------------------------------
; generic item relations
;----------------------------------------------------------------------

; armor strength (defense)
(armorstrength ringmail 2)
(armorstrength bandedmail 3)

; weapon strength (offense)
(weaponstrength mace 2)
(weaponstrength sword 3)
(weaponstrength bow 1)


;----------------------------------------------------------------------
; endgame relations
;----------------------------------------------------------------------

; mearning: true if the hero is at the same location as the exit
(<= atexit 
    (true (location hero ?x ?y))
    (true (location exit ?x ?y)))

;----------------------------------------------------------------------
; arithmetic relations
;----------------------------------------------------------------------

; meaning: absolute value of difference
(<= (diff ?n1 ?n2 ?diff)
    (> ?n1 ?n2)
    (minus ?n1 ?n2 ?diff))

(<= (diff ?n1 ?n2 ?diff)
    (>= ?n2 ?n1)
    (minus ?n2 ?n1 ?diff))


; meaning: minimum
(<= (min ?n1 ?n2 ?n2)
    (> ?n1 ?n2)
    (int ?n1)
    (int ?n2))
(<= (min ?n1 ?n2 ?n1)
    (>= ?n2 ?n1)
    (int ?n1)
    (int ?n2))


; meaning: defines a (finite) succesor relation
(succ 0 1)
(succ 1 2)
(succ 2 3)
(succ 3 4)
(succ 4 5)
(succ 5 6)
(succ 6 7)
(succ 7 8)
(succ 8 9)
(succ 9 10)
(succ 10 11)
(succ 11 12)
(succ 12 13)
(succ 13 14)
(succ 14 15)
(succ 15 16)
(succ 16 17)
(succ 17 18)
(succ 18 19)
(succ 19 20)
(succ 20 21)
(succ 21 22)
(succ 22 23)
(succ 23 24)
(succ 24 25)
(succ 25 26)
(succ 26 27)
(succ 27 28)
(succ 28 29)
(succ 29 30)
(succ 30 31)
(succ 31 32)
(succ 32 33)
(succ 33 34)
(succ 34 35)
(succ 35 36)
(succ 36 37)
(succ 37 38)
(succ 38 39)
(succ 39 40)
(succ 40 41)
(succ 41 42)
(succ 42 43)
(succ 43 44)
(succ 44 45)
(succ 45 46)
(succ 46 47)
(succ 47 48)
(succ 48 49)
(succ 49 50)
(succ 50 51)

; meaning: the integers in [0,7]
; sw -- these are used in lots of other places now
(int 0)
(int 1)
(int 2)
(int 3)
(int 4)
(int 5)
(int 6)
(int 7)

;---------------------------------------------------------------------------
; action relations
;---------------------------------------------------------------------------

; meaning: hero moves one cell in direction ?dir from ?x1 ?y1
; - if <x1,y1> is not currently occupied by a monster.
(<= (nextherolocation ?x2 ?y2)
    (true (location hero ?x1 ?y1))
    (does hero (move ?dir))
    (nextcell ?dir ?x1 ?y1 ?x2 ?y2)
    (not (monsterat ?x2 ?y2)))

; meaning: hero's location is unchanged if attacking a monster
(<= (nextherolocation ?x1 ?y1)
    (true (location hero ?x1 ?y1))
    (does hero (move ?dir))
    (nextcell ?dir ?x1 ?y1 ?x2 ?y2)
    (monsterat ?x2 ?y2))

; meaning: non-moving hero actions
(<= (nextherolocation ?x ?y)
    (true (location hero ?x ?y))
    (not (heromoves)))

; meaning: hero moved in some direction
(<= (heromoves)
    (does hero (move ?dir)))

; ignored: handle staircasedown when there are multiple levels.

; meaning: there's a monster currently at ?x ?y
(<= (monsterat ?x ?y)
    (true (location ?monster ?x ?y))
    (monster ?monster ?monster-type))

; meaning: move provoked monsters towards hero according to ?speed
; - but: cannot stop on same location as hero's location
;   we'll make nstepstowardshero stop when the next location will be
;   occupied by the hero.
(<= (nextmonsterlocation ?monster ?x2 ?y2)
    (not (currentlyinvisible hero))
    (provoked ?monster)
    (true (location ?monster ?x1 ?y1))
    (monster ?monster ?monster-type)
    (monsterspeed ?monster-type ?base-speed)
    (relativespeed ?base-speed ?speed)
    (nstepstowardshero ?speed ?x1 ?y1 ?x2 ?y2))

; meaning: unprovoked monsters don't move
(<= (nextmonsterlocation ?monster ?x ?y)
    (monster ?monster ?monster-type)
    (not (provoked ?monster))
    (true (location ?monster ?x ?y)))

(<= (nextmonsterlocation ?monster ?x ?y)
    (monster ?monster ?monster-type)
    (true (invisible hero ?n))                      ; invisible for n more turns
    (true (location ?monster ?x ?y)))


; meaning: how many steps can monster take this turn?
; we slow all monsters down when hero has enhancedspeed
(<= (relativespeed 0.5 ?speed)
    (not (currentlyenhancedspeed hero))
    (halfspeed ?speed))
(<= (relativespeed 0.5 ?speed)
    (true (enhancedspeed hero ?n))
    (quarterspeed ?speed))
(<= (relativespeed ?base-speed ?base-speed)
    (speednumber ?base-speed)                        ; sw ****    
    (distinct ?base-speed 0.5)
    (not (currentlyenhancedspeed hero)))
(<= (relativespeed 1 ?speed)
    (true (enhancedspeed hero ?n))
    (halfspeed ?speed))
(<= (relativespeed 2 1)
    (true (enhancedspeed hero ?n)))

; anything that moves slower than hero is handled by 
; flipping speed from 1 to 0 every other turn
; (or every fourth turn for 1/4 speed monsters)
(<= (halfspeed 1)
    (true odd))
(<= (halfspeed 0)
    (true even))
(<= (quarterspeed 1)
    (true (slomo-time 4)))
(<= (quarterspeed 0)
    (true (slomo-time ?n))
    (distinct ?n 4))

; meaning: conditions when health is restored via restorehealth scroll
(<= (healthrestoredbyscroll)
    (does hero (read ?scroll))
    (scroll ?scroll restorehealth)
    (true (health hero ?health))
    (maxhealth hero ?maxhealth)
    (distinct ?health ?maxhealth))

;----------------------------------------------------------------------
; object-interaction relations
;----------------------------------------------------------------------

; meaning: the monster is hit by an arrow (unlimited range)
; sw: changed to two rules, for x==x and y==y, so we don't need arbitrary ncells (very expensive for us)
(<= (hitbyarrow ?monster)
    (monster ?monster ?monster-type)               ; generic monster
    (does hero (throw arrow ?dir))
    (true (location hero ?x ?y1))
    (true (location ?monster ?x ?y2)))             ; action

(<= (hitbyarrow ?monster)
    (monster ?monster ?monster-type)               ; generic monster
    (does hero (throw arrow ?dir))
    (true (location hero ?x1 ?y))
    (true (location ?monster ?x2 ?y)))             ; action

; meaning: hero adds item to sack if on it at end of time step 
; - and it wasn't dropped in this time step
(<= (pickedup ?item)
    (item ?item)                         ; generic item
    (distinct ?item gold)
    (true (burden ?burden))
    (maxburden ?max-burden)              ; generic sack
    (> ?max-burden ?burden)              ; arithmetic
    (true (location hero ?x1 ?y1))
    (nextherolocation ?x2 ?y2)           ; action
    (not (samelocation ?x1 ?y1 ?x2 ?y2)) ; don't re-pick up an item after dropping it
    (true (location ?item ?x2 ?y2)))

; handle gold specially since it is not limited by maxburden
(<= (pickedup gold)
    (nextherolocation ?x ?y)
    (true (location gold ?x ?y)))

; meaning: read scrolls and quaffed potions are eliminated from burden
(<= (decrementsburden ?item)
    (use ?item))

; meaning: dropped items are elminated from burden
(<= (decrementsburden ?item)
    (does hero (drop ?item)))

; meaning: picking up a non-gold item changes the burden
(<= burdenchanged
    (pickedup ?item)            ; acquired new item
    (not (weaponchange ?item))  ; da: no change if changing a weapon
    (distinct ?item gold))      ; no change if it's gold

; meaning: any decrement to the burden changes the burden
(<= burdenchanged
    (decrementsburden ?item)            ; successful drop or use
    (distinct ?item gold))

; meaning: this can happen when we pickup a new weapon
(<= (changeweapon ?currentweapon)
    (true (wielding ?currentweapon))       ; sw: need to ground ?weapon
    (weapon ?newweapon ?newweapon-type)    ; da: sam - is this ordering ok?
    (pickedup ?newweapon)                  ; da: also new
    (distinct ?currentweapon ?newweapon))

; da (7/13): newly inserted - used in next (to prevent burden updates) and burdenchanged/0
; -- same as changeweapon/1, but this time the argument represents the *new* weapon
(<= (weaponchange ?newweapon)
    (weapon ?newweapon ?newweapon-type)
    (pickedup ?newweapon)
    (true (wielding ?currentweapon))
    (distinct ?newweapon ?currentweapon))

(<= arrowthrown
    (direction ?dir)
    (does hero (throw arrow ?dir)))

; meaning: hero is invisible at the moment.
; helper predicate to avoid unbound vars in negative statement
(<= (currentlyinvisible hero)
    (true (invisible hero ?n)))

(<= (currentlyasleep ?agent)
    (true (asleep ?agent ?n)))

(<= (currentlyenhancedarmor hero)
    (true (enhancedarmor hero ?n)))

(<= (currentlyenhancedstrength hero)
    (true (enhancedstrength hero ?n)))

(<= (currentlyenhancedspeed hero)
    (true (enhancedspeed hero ?n)))

(<= (armored hero)
    (true (wearing ?armor))
    (armor ?armor ?armor-type))

(<= (armed hero)
    (true (wielding ?weapon))
    (weapon ?weapon ?weapon-type))

; meaning: hero quaffs a potion currently in the sack
; this is just a convenience relation that indicates an item has been 
; used up and no longer counts as a burden.  the effect of the
; quaff or read must be handled in a next rule.
(<= (use ?potion)
    (does hero (quaff ?potion)))

; meaning: hero reads a scroll currently in the sack
(<= (use ?scroll)
    (does hero (read ?scroll)))

; sw: constrain the monster movement predicates to only match near
; monsters that could possibly move.  this means all cells within 
; manhattan distance 2 of a monster

(<= (relevantmonstercell ?x ?y)
    (monster ?monster ?any) 
    (true (location ?monster ?x ?y))
    (provoked ?monster)
    (not (currentlyinvisible hero))
    (nextherolocation ?x2 ?y2)
    (room ?lx ?ty ?rx ?by)
    (between ?lx ?x2 ?rx)
    (between ?ty ?y2 ?by)
    (between ?lx ?x ?rx)
    (between ?ty ?y ?by))

;;; what is the semantics of this?  should this include the current monster
;;; location?  it must, if we're using it to test the start location of
;;; nstepstowardshero.
(<= (cellnearmonster ?x ?y)
    (relevantmonstercell ?x ?y))

(<= (cellnearmonster ?x1 ?y)
    (relevantmonstercell ?x ?y)
    (int ?d)        ; must ground ?d
    (> ?d 0)
    (> 3 ?d)        ; there is no < (lessthan)
    (minus ?x ?d ?x1))

(<= (cellnearmonster ?x1 ?y)
    (relevantmonstercell ?x ?y)
    (int ?d)
    (> ?d 0)
    (> 3 ?d)
    (plus ?x ?d ?x1))

(<= (cellnearmonster ?x ?y1)
    (relevantmonstercell ?x ?y)
    (int ?d)
    (> ?d 0)
    (> 3 ?d)
    (minus ?y ?d ?y1))

(<= (cellnearmonster ?x ?y1)
    (relevantmonstercell ?x ?y)
    (int ?d)
    (> ?d 0)
    (> 3 ?d)
    (plus ?y ?d ?y1))

; four diagonal cases
(<= (cellnearmonster ?x1 ?y1) 
    (relevantmonstercell ?x ?y)
    (plus ?x 1 ?x1)
    (plus ?y 1 ?y1))

(<= (cellnearmonster ?x1 ?y1) 
    (relevantmonstercell ?x ?y)
    (plus ?x 1 ?x1)
    (minus ?y 1 ?y1))

(<= (cellnearmonster ?x1 ?y1) 
    (relevantmonstercell ?x ?y)
    (minus ?x 1 ?x1)
    (minus ?y 1 ?y1))

(<= (cellnearmonster ?x1 ?y1) 
    (relevantmonstercell ?x ?y)
    (minus ?x 1 ?x1)
    (plus ?y 1 ?y1))


;;; end of file

